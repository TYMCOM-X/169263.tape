	TITLE	WROCT - OCTAL OUTPUT ROUTINE

	SEARCH	PASSYM
	EXTERN	PUTCH.

	ENTRY	WROCT.

	$RELOC

WROCT.: JUMPLE REG2,OCTRET		;FIELDWIDTH = 0 ?
WRTOIN: CAIG   REG2, 14 		;LEADING BLANKS REQUIRED ?
	JRST	      OCTEST		;NO
	MOVEI	  AC0," "
	PUSHJ	 TOPP,PUTCH.
	SOJA   REG2,WRTOIN		;MORE BLANKS TO BE INSERTED ?

OCTEST: MOVE   REG3,[POINT 3,REG1]
	HRREI	  AC1,-14(REG2)
	JUMPE	  AC1,OCTWRT		;LESS THAN 12 POSITIONS REQUIRED ?
	IBP	      REG3		;YES
	AOJL	  AC1, .-1
OCTWRT: ILDB	  AC0,REG3		;GET DIGIT
	ADDI	  AC0, 60		;CONVERT TO ASCII
	PUSHJ	 TOPP,PUTCH.
	SOJG   REG2,OCTWRT		;MORE DIGITS TO BE OUTPUT ?
OCTRET: POPJ	 TOPP,			;NO - RETURN

	PRGEND
	TITLE	WRINT - DECIMAL OUTPUT ROUTINE

	SEARCH	PASSYM
	EXTERN	WROPN.
	EXTERN	WRBLK.
	EXTERN	WRSGN.
	EXTERN	PUTCH.
	EXTERN	TOSML.

	ENTRY	WRINT.

	$RELOC

WRINT.: JUMPLE REG2,INTRET		;FIELDWIDTH = 0?
	PUSHJ  TOPP,WROPN.
	JUMPE  REG1, .+4
	IDIVI  REG1, 12 		;GETS LOWEST DIGIT TO REG2
	PUSH   TOPP, REG2		;AND SAVES IT IN PUSH-LIST
	AOJA   REG4, .-3
	TRNE   REG4, 777777		;VALUE EQUAL 0?
	JRST	.+4			;NO
	SETZ   REG2,			;YES - PUTS ONE ZERO INTO PUSH-LIST
	PUSH   TOPP,REG2
	AOJ    REG4,
	CAIL   REG5,(REG4)		;FORMAT LARGE ENOUGH ?
	JRST	.+6			;YES
	TLZ    REG4,400000		;CLEARS SIGN BIT IF ANY
	SOJL   REG4,.+3 		;RESET PUSH-LIST
	POP    TOPP,REG2
	JRST	.-2
	JRST	TOSML.			;WRITES "*" 'S INTO FORMAT AND RETURNS
	SUBI   REG5,(REG4)		;GETS NUMBER OF LEADING BLANKS
	MOVEI  REG2,(REG5)		;WRITEBLANK-ROUTINE WORKS ON REG2
	PUSHJ  TOPP,WRBLK.		;WRITES BLANKS IF ANY
	PUSHJ  TOPP,WRSGN.		;WRITES SIGN : " " IF POSITIV,"-" IF NEGATIV
	POP    TOPP,AC0 		;GETS DIGIT IN PUSH-LIST
	ADDI   AC0, "0" 		;CONVERTS TO ASCII
	PUSHJ  TOPP, PUTCH.		;WRITES THEM OUT
	SOJG   REG4, .-3		;MORE DIGITS ?
INTRET: POPJ   TOPP,			;NO - RETURN

	PRGEND
	TITLE	WRHEX - HEX OUTPUT ROUTINE

	SEARCH	PASSYM
	EXTERN	PUTCH.

	ENTRY	WRHEX.

	$RELOC

WRHEX.: JUMPLE REG2,HEXRET		;FIELD = 0?
WRTHIN:	CAIG	REG2,	 11		;LEADING BLANKS REQUIRED?
	JRST	     HEXTST		;NO
	MOVEI	AC0 ,  " "
	PUSHJ	TOPP,PUTCH.
	SOJA	REG2,WRTHIN

HEXTST:	MOVE	REG3,[POINT 4,REG1]
	HRREI	 AC1,-11(REG2)
	JUMPE	 AC1,HEXWRT		;LESS THEN 11 POSITIONS
	  IBP	       REG3		;YES
	 AOJL	 AC1,.-1

HEXWRT:	ILDB	 AC0,REG3
	ADDI	 AC0, 60
	CAIL	 AC0, 72		;DIGIT?
	ADDI	 AC0,  7		;NO LETTER
	PUSHJ	TOPP,PUTCH.
	SOJG	REG2,HEXWRT
HEXRET:	POPJ	TOPP,

	PRGEND
	TITLE	PASDIO - DOUBLE PRECISION REAL INPUT

	SEARCH	PASSYM

	ENTRY	READD.

	EXTERN	READR.

	$RELOC
;
; READS A SINGLE PRECISION REAL NUMBER AND STORES IT IN A 
; DOUBLE PRECISION VARIABLE, ZEROING THE SECOND WORD
;
READD.:	SETZM	1(REG1)		;ZERO SECOND MANTISSA WORD
	JRST	READR.		;AND COMPLETE READ
	PRGEND
	TITLE	CNVTOD - STRING TO DOUBLE REAL CONVERSION

	SEARCH	PASSYM

	ENTRY	CNVTOD

	EXTERN	CNVTOR

	$RELOC

CNVTOD:	SETZM	1(REG1)		;ZERO LOW ORDER WORD
	JRST	CNVTOR		;CONTINUE 
	PRGEND
	TITLE	PASNIO - NUMERIC I/O MODULE

	SEARCH	PASSYM
	EXTERN	PUTCH.
	EXTERN	TOSML.
	EXTERN	WRBLK.
	EXTERN	WRMIN.
	EXTERN	ROUND.

	ENTRY	WRTRL.
	ENTRY	READI.
	ENTRY	CVTOI.
	ENTRY	CNVTOR
	ENTRY	STR2R.
	ENTRY	CVTOR.
	ENTRY	READR.

REG7==REG6+1
;WRITE A REAL VALUE IN SPECIFIED FORMAT
;ARGS:	REG1	VALUE
;	REG2	IOW
;	REG3	IOD
;USES:  REG4,REG5,REG6    ALSO AC0,AC1

	$RELOC

WRTRL.: JUMPLE	REG2,REARET		;FIELDWIDTH = 0?
	HRL	REG2,	REG3		;(PACK IOW,IOD)
	MOVM	REG4,	REG1		;(GET THE MAGNITUDE)
	MOVEI	REG3,	0		;(READY FOR BINARY EXP)
	ASHC	REG3,	8		;(BUST OFF THE EXP,LEAVING SIGN)
	SUBI	REG3,	200		;(UNBIAS EXP)
	MOVEI	REG5,	NTENS		;(NUMBER OF SCALING FACTORS)
	MOVEI	REG6,	0		;(INIT DECIMAL EXP)
;SCALING LOOP---REG6	DECIMAL EXP
;		REG5	SCALING INDEX
;		REG4	FRACTION
;		REG3	BINARY EXP
;		REG2	FORMAT
;		REG1	NUMBER WITH SIGN
	JUMPN	REG4,	TEST		;(GO DO THE NON ZERO FRACTION)
	MOVEI  AC0,555555		;YES - REMEMBER IT IN AC0
	JRST	WRTFF			;      AND WRITE IT OUT
;CONVERTING FLOATING PT NUMBER TO DECIMAL EXP AND FRACTION
;     1/2 *2**1  <=  FRACTION,BE  < 5/8 *2**4
;	1.0	 <=    NUMBER     < 10.0
TEST:	JUMPLE	REG3,	LOW		;(BE<=0, MUST SCALE UP)
	CAILE	REG3,	4
	JRST		HIGH		;(BE> 4, MUST SCALE DOWN)
	CAIE	REG3,	4
	JRST 		OK		;(BE< 4, IS IN RANGE)
	CAMGE	REG4,	[240000,,0]	;(BE=4, FRACTION MUST BE <5/8)
	JRST 		OK		;(DO IT)
HIGH:	SUB 	REG3,	TENE(REG5)	;(ADJUST BE BY SCALING BE)
	JUMPE	REG3,	[CAML	REG4,TENF(REG5)	;BAD DIV?)
			JRST 	HIGH1	;(NO, USE THIS ONE)
			ADD	REG3,	TENE(REG5)
			SOJA	REG5,	HIGH]
	JUMPL	REG3,	[ ADD REG3,TENE(REG5)	;(UNDO THE SCALE)
			 SOJG	REG5,HIGH	;(SELECT NEXT FACTOR)
			AOJA	REG5,TEST]	;(BUG?)
HIGH1:	ADD	REG6,	TENP(REG5)	;(ADJUST DEC EXP)
	PUSHJ	TOPP,	DIV10P		;(ADJUST FRACTION)
	JRST 		TEST		;(ARE WE DONE?)
;
DIV10P:	PUSH	TOPP,	REG3		;(SAVE BE)
	LSHC	REG3,	^D36		;(MAKING 72BIT NUMBER)
	CAMGE	REG3,	TENF(REG5)	;(WILL IT OVERFLOW?)
	JRST		.+3		;(NO)
	ASHC	REG3,	-1		;(REMOVE OVERFLOW PROBLEM)
	AOS		(TOPP)		;(ADJUST BE)
	DIV	REG3,	TENF(REG5)	;(SCALE FRACTION)
	ADD	REG4,	REG4		;(DOUBLE REMAINDER)
	JUMPL	REG4,	.+2 		;(IF >= .5, ROUND UP)
	CAML	REG4,	TENF(REG5)	;(WAS IT>= .5*TENF(REG5)?)
	ADDI	REG3,	1		;(ROUND UP THE RESULT)
	MOVE	REG4,	REG3		;(RESTORE NUMBER)
	POP	TOPP,	REG3		;(REPLACE BE)
	POPJ	TOPP,
;
LOW:	ADD	REG3,	TENE(REG5)	;(ADJUST BE BY SCALING FACTOR)
	CAILE	REG3,	4		;(TOO MUCH??)
	JRST		[SUB 	REG3,TENE(REG5)
			SOJG	REG5,	LOW	;(SELECT NEXT FACTOR)
			AOJA	REG5,	TEST]	;(BUG?)
	SUB 	REG6,	TENP(REG5)	;(ADJUST DE)
	PUSHJ	TOPP,	MUL10P		;ADJUST FRACTION)
	JRST		TEST
;
MUL10P:	PUSH	TOPP,	REG5		;(SAVE INDEX)
	MUL	REG4,	TENF(REG5)
	TLNE	REG4,	200000		;(IS IT NORMALIZED REALLY?)
	JRST 		.+3
	ASHC	REG4,	1		;(POST NORMALIZE)
	SUBI	REG3,	1		;(ADJUST BINARY EXP)
	POP	TOPP,	REG5
	POPJ	TOPP,
;
;*TABLES OF SCALING FACTORS FOR FLTING PT: 10.0, 1.0E4, 1.0E13
TENP=	.-1		;DECIMAL EXPONENTS
	EXP	1,4,^D13
TENE=	.-1		;BINARY EXPONENTS
	EXP	4,^D14,^D44
TENF=	.-1		;FRACTIONS
	EXP	240000000000,234200000000,221411634520
NTENS=TENE-TENP
FRRND=	.-1
	EXP	17,7,3,1		;(ROUNDING FRACTION BEFORE SHIFT)
;
OK:	ADD	REG4,	FRRND(REG3)		;(IF ANY BITS, ROUND UP)
	LSH	REG4,	-5(REG3)	;(POSITION BINARY PT BTW 5,6)
WRTFF:
	HLRZ	REG3,	REG2		;(RESTORE IOD)
	TLZ	REG2,	-1		;(RESTORE IOW)
	CAIN   REG3,123456		;FIXEDREAL OR FLOATING REAL ?
	JRST	WRTFLO			;FLOATING REAL(E FORMAT)
;	REG1	SIGN
;	REG2	IOW
;	REG3	IOD
;	REG4	FRACTION
;	REG5	---
;	REG6	DECIMAL EXP
WRTFF1:	MOVE	REG5,	REG6		;(MAG= DIGITS BEFORE POINT-1)
	ADDI	REG5,	1(REG3)		;(MAG+1+DIGITS AFTER POINT=SIGFIGS)
	CAIGE 	REG5,	0		;(CANT BE NEGATIVE)
	MOVEI	REG5,	0		;(ROUND WITH 5.0)
	CAILE 	REG5,	^D10		;(MAX 10 DIGITS)
	MOVEI	REG5,	^D10
	ADD	REG4,	RNDTBL(REG5)	;(ROUND UP AT SIGFIGS)
	MOVEI	REG5,(REG2)		;FIXED REAL - GET FORMAT WIDTH
	SUBI	REG5,(REG3)		;REG3 CONTAINS NR OF DIGITS AFTER POINT
	CAMGE	REG4,	[ OCT 120000000000] ;(OVERFLOW TO 10.0?)
	JRST	.+3
	HRLZI	REG4,	010000		;(MAKE IT 1.0)
	AOJ	REG6,			;(MAKE MAGNITUDE BIGGER)
	JUMPL	REG6,WRTFF2		;EXPONENT NEGATIV ?
	HRRI	REG1,1(REG6)		;NOW REG1-R CONTAINS NR DIGITS BEFOR PT
	CAIGE  REG5,1(REG1)		;FORMAT LARGE ENOUGH ?
	JRST	WRTFLO			;NO - WRITES FLOATING FORMAT IF POSSIBLE
	SETZ   REG2,			;NO - NO LEADING ZERO'S
	CAIE   AC0,555555		;VALUE EQUAL ZERO ?
	JRST	WRTFF3
	MOVEI	REG2,	1		;(PUTOUT 1 LEADING ZERO)
	JRST WRTFF3
WRTFF2:	CAIGE	REG5,2		;(NEED ROOM FOR SIGN AND '.')
	JRST	TOSML.
	HRRI	REG1,1			;ONE ZERO BEFORE POINT
	MOVM   REG2,REG6		;NUMBER OF LEADING ZEROS'S
WRTFF3:	MOVEI	REG6,765432		;TO REMEMBER THAT NO EXPONENT SHALL
					;BE GIVEN OUT
	SUBI	REG5,2(REG1)		;FOR POINT,SIGN AND DIGITS BEFORE POINT
	JRST WRTOUT

;TABLE TO ROUND NUMBER WHOSE BINARY PT IS BETWEEN BITS 5,6
RNDTBL:	EXP 	050000000000	;(NEGATIVE SIGFIGS, USE 5.0)
	EXP	004000000000	;1
	EXP	000314631463	;2
	EXP	000024365605	;3
	EXP	000002030446+1	;4
	EXP	000000150667	;5
	EXP	000000012370+1	;6
	EXP	000000001030+1	;7
	EXP	000000000065+1	;8
	EXP	000000000005	;9
	EXP	000000000001	;10
;

;WRITE DIGITS FROM THE FRACTION
;	REG5  	NUMBER OF LEADING '0'
;	REG1	NR DIGITS TO OUTPUT
;	REG4	FRACTION TO OUTPUT FROM
WRTMAT:	SOJL   REG5,WM1			;MORE LEADING ZERO'S REQUEST
	SOJL	REG1,	MATEND
	MOVEI  AC0,"0"			;YES - WRITE THEM OUT
	PUSHJ  TOPP,PUTCH.
	JUMPG	REG1,	WRTMAT		;(IF ROOM FOR MORE CHRS)
WM1:	JUMPLE	REG1,MATEND
WM2:	JUMPE  REG4,WM3 		;MANTISSE EQUAL ZERO ?
	LDB    AC0,[POINT 6,REG4,5]	;NO - GET NEXT DIGIT
	TLZ    REG4,770000		;RESETZ THIS BITS
	IMULI  REG4,12
	ADDI   AC0,"0"			;CONVERTS THEM TO ASCII
	PUSHJ  TOPP,PUTCH.
	SOJG   REG1,WM2 		;MORE DIGITS BEFORE POINT FROM REG4 ?
WM3:	JUMPLE	REG1, MATEND	;NO - MORE DIGITS BEFORE POINT ?
	MOVEI  AC0,"0"			;     YES - WRITES ONE ZERO OUT
	PUSHJ  TOPP,PUTCH.
	SOJG   REG1,.-1
MATEND: POPJ   TOPP,
;
;WRITING IN E FORMAT
WRTFLO: HRRI	REG1,1			;ONE DIGIT BEFORE POINT
	SETZ   REG5,			;NORMALLY NO LEADING BLANKS
	CAIGE  REG2, 7			;FORMAT BIG ENOUGH ?
	JRST	TOSMALL			;NO - WRITES "*" 'S INTO FORMAT AND RETURN
	MOVEI  REG3,-7(REG2)		;DIGITS BEHIND POINT
	CAIE   AC0,555555		;VALUE EQUAL ZERO ?
	SETZ   REG2,			;NO - NO LEADING ZERO'S IN FLOATING FORMAT
					;<REG4>: VALUE OF MANTISSE
					;<REG5>: NR OF LEADING BLANKS
					;<REG3>: NR OF DIGITS BEHIND POINT
					;<REG1>: NR OF DIGITS BEFORE POINT
					;<REG2>: NR OF LEADING ZERO'S
					;<REG6> 765432 OR EXP TO OUTPUT
WRTOUT:	EXCH	REG2,	REG5
	SKIPL		REG1		;(IF POSITIVE,)
	ADDI	REG2,	1		;(OUTPUT SIGN AS ' ')
	PUSHJ  TOPP,WRBLK.		;WRITES LEADING BLANKS
	JUMPGE	REG1,	.+2		;(IS THE NUMBER NEGATIVE?)
	PUSHJ	TOPP,	WRMIN.		;(SURE, WRITE THE'-')
	HRRZ	REG1,	REG1		;(CLEARING THE BITS)
	PUSHJ  TOPP,WRTMAT		;WRITES MANTISSE BEFORE POINT
	MOVEI  AC0,"."			;WRITES DECIMAL POINT OUT
	PUSHJ  TOPP,PUTCH.
	MOVEI  REG1,(REG3)
	PUSHJ  TOPP,WRTMAT		;WRITES MANTISSE BEHIND POINT
	CAIN   REG6,765432		;WRITE EXPONENT OR NOT ?
	JRST	REARET			;NO
	JUMPN  REG6,.+3 		;EXPONENT EQUAL ZERO ?
	MOVEI  REG2,4			;YES - WRITES BLANKS INSTEAD ZERO EXPONENT
	JRST	WRBLK.			;AND RETURN TO SURCEPROGRAMM
	MOVEI	AC0,"E" 		;YES - WRITE E OUT
	PUSHJ	TOPP,PUTCH.
	MOVEI	AC0,"+" 		;WRITES SIGN OUT
	SKIPGE	REG6			;EXPONENT POSITIV
	MOVEI	AC0,"-" 		;NO - WRITE MINUS SIGN
	PUSHJ	TOPP,PUTCH.		;WRITES OUT SIGN
	MOVM	AC0,REG6		;(DECIMAL EXP TO OUTPUT)
	IDIVI	AC0,	^D10		;(GET 2 DECIMAL DIGITIS)
	ADDI	AC0,	"0"
	PUSHJ	TOPP,	PUTCH.		;(OUTPUT)
	MOVE	AC0,	AC1
	ADDI	AC0,	"0"
	PUSHJ	TOPP,	PUTCH.		;(OUTPUT 2ND ONE)
REARET: POPJ   TOPP,			;RETURN

TOSMALL:
	MOVEI	REG5,0(REG2)		;GET REQUESTED FIELD WIDTH
	JRST	TOSML.			; AND FILL WITH '*'


;
; REAL-NUMBER AND INTEGER INPUT ROUTINES
;
	EXTERN	GETCH.
	EXTERN	CONER.

	ENTRY	READI.
	ENTRY	CVTOI.
	ENTRY	CVTOR.

;READING NUMBERS FROM A FILE
;	AC0:	CURRENT CAHARACTER
;	REG1:	LOCATION FOR VALUE
;	REG2:	VALUE
;	REG3:	DECIMAL EXP
;	REG4:	DIGITS READ
;	REG5:	DIGITS SPILLED
;	REG6:	SIGN CHARACTER

READI.:	PUSHJ	TOPP,	REAINI		;(INITIAL NUMERIC READ)
	CAIE	AC0,	"."
	CAIN	AC0,	"E"
	JRST		READI1		;(TREAT AS FLT PT NR)
READEN:	CAIN	REG6,	"-"		;(SHOULD WE NEGATE VALUE?)
	MOVN	REG2,	REG2
	MOVEM	REG2,	(REG1)		;(STORE RESULTS)
	POPJ	TOPP,
READI1:	PUSHJ	TOPP,	READCM		;(PROCESS AS FLTING NR)
	MOVEI	REG6,	0		;(WONT NEGATE AGAIN)
	MOVEI	AC1,	REG2		;(LOCN OF NR TO ROUND)
	PUSHJ	TOPP,	ROUND.		;(CONVERT BACK TO INTEGER)
	JRST		READEN		;(DONE AFTER STORE)

;ROUTINE TO TAKE CARE OF LEADING CHARS IN NUMERIC FIELDS
REAINI:	MOVE 	AC0,	FILCMP(REG)	;(THE CURRENT CHARACTER)
	CAIN	AC0,	","		;(AN INITIAL COMMA??)
REAIN0:	PUSHJ	TOPP,	RGETCH		;(GET THE NEXT ONE)
	CAIN	AC0,	" "		;(LEADING BLANKS??)
	JRST 		.-2		;(IGNORE THEM )
	CAIN	AC0,	"*"		;(USE PREVIOUS VALUE??)
	JRST		RSKPCH		;(YA,HE WANTS IT)
	CAIE	AC0,	","		;(SECOND COMMA THAT TERMINATES FIELD?)
	JRST		REAIN1		;(NO, DO THE NUMBER)
	SETZM		(REG1)		;(CLEAR THE MEMORY LOCATION)
	POP	TOPP,	REG2		;(UNSTACK RETURN TO RETURN FROM CALLER)
	POPJ	TOPP,			;(DONE INPUT CONVERSION)

IDIGIT:	BLOCK	0
REAIN1:	MOVE	REG6,	AC0		;(SAVE THE SIGN CHAR)
	CAIE	AC0,	"+"
	CAIN	AC0,	"-"		;(IF NOT REALLY SIGN IGNORE IT)
	PUSHJ	TOPP,	RGETCH		;(SUCK UP THE SIGN CHAR)
	CAIL	AC0,	"0"
	CAILE	AC0,	"9"
	CAIN	AC0,	"."
	SKIPA				;(SKIP ALWAYS)
	JRST		CONER.		;(NON NUMERIC INITIAL CHAR)
	MOVEI	REG2,	0		;(FOR BUILDING THE NUMBER)
;GETTING THE INITIAL DIGITS
DIGITS:	MOVEI	REG4,	0		;(CLEAR DIGITS READ)
	MOVEI	REG5,	0		;(CLEAR DIGITS SPILLED)
DIGIT1:	CAIL	AC0,	"0"
	CAILE	AC0,	"9"
	POPJ	TOPP,			;(NOT A DIGIT)
	SUBI	AC0,	"0"		;(CONVERT TO NUMBER)
	ADDI	REG4,	1		;(READ 1 DIGIT)
	CAML	REG2,	[31463146314]	;(WILL MULTIPLY OVERFLOW?)
	AOJA	REG5,	DIGIT2		;(YA,COUNT AND GO THERE)
	IMULI	REG2,	12		;(NUMBER*10)
	ADD	REG2,	AC0		;(+CHR-"0"=NEW NUMBER)
DIGIT2:	PUSHJ	TOPP,	RGETCH		;(NEXT CHARACTER)
	JRST		DIGIT1
RSKPCH: POP	TOPP,	AC0		;(THROW AWAY RETURN)
;					;(AND RETURN WITH NEXT CHR)
RGETCH:	TLNE	REG,	-1		;(IS 'FILE' AD POINTER?)
	JRST 		RG1		;(YES JUST GET THE BYTE)
	PUSHJ	TOPP,	GETCH.
	MOVE	AC0,	FILCMP(REG)	;(GET THE NEXT ONE)
	POPJ	TOPP,
RG1:	JUMPE	REG7,	RG2		;(PHONY CHARACTER IF END OF STRING)
	SOS	REG7			;(ELSE DECREMENT LENGTH COUNT)
	ILDB	AC0,	REG		;(GET BYTE FROM PTR)
	POPJ	TOPP,
RG2:	MOVEI	AC0,	"Z"		;(BOGUS RETURN AT END OF STRING)
	POPJ	TOPP,
;PEEK AT NEXT CHAR IN INPUT STREAM
PKCH:	MOVE	AC1,	REG		;(GET THE FILE/STRING PTR)
	TLNE	AC1,	-1		;(IS IT STRING PTR?)
	JRST		PKCH1		;(YA, JUST LDB)
	MOVE	AC1,	FILBUF(AC1)	;(GET BUFFER PTR)
	MOVE	AC1,	BUFBTP(AC1)	;(GET STRING PTR)
PKCH1:	ILDB	AC0,	AC1		;(GET THE NEXT CHR)
	POPJ	TOPP,

;CONVERSION ROUTINES FOR PASCAL COMPILER
;ARGS:	REG(=2)		BUFFER POINTER
;	REG1(=3)	ADDR FOR RESULT
;USES	AC0--REG6 (0--8)
;
CVTOI.:	HRLI	REG,440700		;(MAKE BYTE POINTER TO STRING)
	HRREI	REG7,-1			;(NO LENGTH CHECK)
	PUSHJ	TOPP,	REAIN0	;(CRACK AN INTEGER)
	JRST		READEN		;(AND DDONE)
;CONVERT STRING TO REAL NUMBER
;
; PUBLIC FUNCTION CV_REAL (STRING): REAL; (* IN SINGLE OR DOUBLE PRECISION *)
;
STR2R.:
	MOVE	REG7,	0(REG)		;(GET STRING LENGTH)
	AOS	REG			;(POINT TO STRING ITSELF)
	MOVEI	REG1,FV(TOPP)		;(ADDRESS FOR RESULT)
	ADDI	TOPP,FV+1		;(ALLOCATE SPACE FOR RETURN VALUE)
	PUSHJ	TOPP,CNVTOR+1		;(SKIP NEGATE OF LENGTH REGISTER)
	SUBI	TOPP,FV+1		;(FREE STACK)
	SETZM	FV+1(TOPP)		;(ZERO LOW ORDER MANTISSA BITS)
	POPJ	TOPP,
;
CNVTOR:	
CVTOR.:
	HRREI	REG7,-1			;(NO LENGTH CHECKING)
	HRLI	REG,440700		;(MAKE STRING POINTER)
	PUSHJ	TOPP,	REAIN0		;(INIT, GETTING 1ST CHAR)
	JRST 		READCM
;AND FALL INTO COMMON CODE
;					;(CAN DIAGNOSE EXP TOO LARGE)
READR.:	PUSHJ	TOPP,	REAINI		;(SUCKING UP LEADING ',' / ' ')
READCM:	MOVE	REG3,	REG5		;(EXP=DIGITS SPILLED)
	CAIE	AC0,	"."		;(DECIMAL PT??)
	JRST 		READR1		;(NO)
	PUSHJ	TOPP,	RGETCH
	PUSHJ	TOPP,	DIGITS		;(READ THE FRACTIONAL PART)
	SUB	REG3,	REG4		;(DIGITS READ REDUCE EXP)
	ADD	REG3,	REG5		;(EXCEPT FOR SPILLED ONES)
READR1:	CAIE	AC0,	"E"		;(DO WE HAVE AN EXPONENT?)
	CAIN	AC0,"e"			;(LOWER CASE, TOO)
	JRST	.+2
	JRST		READR2		;(NO)
	PUSHJ	TOPP,	PKCH		;(PEEK AT NEXT CHAR)
	CAIE	AC0,	"+"
	CAIN	AC0,	"-"
	JRST		.+4		;(IS A LEGAL SIGN)
	CAIL	AC0,	"0"
	CAILE	AC0,	"9"
	JRST		READR2		;(NOT A DIGIT, IGNORE THE'E')
	PUSHJ	TOPP,	RGETCH		;(GET POSIBLE SIGN)
	PUSH	TOPP,	REG2		;(SAVE CURRENT VALUE)
	PUSH	TOPP,	REG6		;(SAVE CURRENT SIGN)
	PUSHJ	TOPP,	IDIGIT		;(READ THE SIGNED NR)
	JUMPE	REG4,	BADEXP		;(NO DIGITS, DIAGNOSE IT)
	CAIN	REG6,	"-"		;(WAS EXP NEGATIVE)
	MOVN	REG2,	REG2
	ADD	REG3,	REG2		;(APPLY TO CURRENT EXP)
	POP	TOPP,	REG6
	POP	TOPP,	REG2		;(RETRIEVE CURRENT VALUE)
READR2:	EXCH	REG2,	REG3		;(DECIMAL EXP IN REG2)
	JFFO	REG3,	.+3		;(READY TO MORMALIZE)
	MOVEI	REG2,	0		;(VALUE ==0.0)
	JRST		READEN		;(DONE)
	LSH	REG3,	-1(REG4)	;(NORMALIZE THE DIGITS)
	MOVNI	REG4,	-233-11(REG4)	;(CALC BIASED EXP FOR FRACTION)
	HRRE	REG4,	REG4		;(EXTEND  THE SIGN BIT)
	EXCH	REG3,	REG4		;(BINARY EXP(REG3), FRACTION(REG4)
	MOVEI	REG5,	NTENS
;*APPLY DECIMAL SCALING FACTOR(REG2) TO NUMBER (REG3,REG4)
	JUMPL	REG2,	READR5		;(SCALE DOWN)
READR3:	JUMPN	REG2,	READR4		;(SCALE UP)
	CAIL	REG3,	0		;(IS IT TOO SMALL?)
	CAILE	REG3,	377		;(IS IT TOO BIG?)
	JRST 		EXP2BG		;(YES, DIAGNOSE IF FROM FILE)
	ADDI	REG4,	377		;(ROUND IT UP)
;*STILL MUST BE POSITIVE!
	JUMPL	REG4,	[HRLZI	REG4,	200000;(NORMALIZED RESULT)
		AOJA	REG3,READR4]	;(GO TEST EXP AGAIN)
	ASHC	REG3,	-8		;(INSERT EXP INTO NUMBER)
	MOVE	REG2,	REG4
	JRST		READEN		;(GO FINISH NUMBER)
;*MAG > 1.0
READR4:	CAML	REG2,	TENP(REG5)
	JRST	[SUB	REG2,TENP(REG5)
		ADD	REG3,TENE(REG5)
		PUSHJ	TOPP,MUL10P
		JRST 	READR4]
	SOJG	REG5,	READR4		;(SELECT NEXT SCALING FACTOR)
	JRST 		READR3		;(DONE)
;*MAG < 1.0
READR5:	MOVN	REG2,	REG2
READR6:	CAML	REG2,	TENP(REG5)
	JRST	[SUB	REG2,TENP(REG5)
		SUB	REG3,TENE(REG5)
		PUSHJ	TOPP,DIV10P
		JRST	READR6]
	SOJG	REG5,	READR6
	JRST		READR3

;*EXPONENT FIELD WITHOUT ANY DIGITS
BADEXP:
;*GOT AN EXPONENT UNDER/OVERFLOW
EXP2BG:
;*SHOULD TRIGGER ON ERROR CONDITION HERE
	TLNN	REG,	-1		;(COMMING FROM FILE, OR DECODE)
	JRST		CONER.		;(DIAGNOSE FROM  FILE)
	CAIG	REG3,	0		;(EXP UNDERFLOW?)
	JRST	[MOVEI	REG2,	0	;(GIVE HIM 0.0)
		JRST		READEN]
;*GIVE HIM THE LARGEST NUMBER
	HRLOI	REG2,	377777		;(=377777777777)
	JRST		READEN
	PRGEND
	TITLE	WRITC - CHARACTER OUTPUT ROUTINE

	SEARCH	PASSYM
	EXTERN	PUTCH.

	ENTRY	WRITC.

	$RELOC

WRITC.: JUMPLE REG2,WRITRT		;FIELDWIDTH = 0 ?
	SOJE   REG2, .+4		;LEADING BLANKS REQUESTED ?
	MOVEI	  AC0," "		;YES
	PUSHJ	 TOPP,PUTCH.
	SOJG   REG2, .-1		;MORE LEADING BLANKS ?
	MOVE   AC0, REG1		;CHARACTER TO BE OUTPUT MUST BE IN AC0
	PUSHJ	 TOPP,PUTCH.
WRITRT: POPJ	 TOPP,

	PRGEND
	TITLE	WRTSTR - STRING OUTPUT ROUTINES

	SEARCH	PASSYM
	EXTERN	PUTCH.

	ENTRY	WRVST.
	ENTRY	WRSST.
	ENTRY	WRPST.
	ENTRY	WRUST.

	$RELOC

WRSST.:EXCH	REG2,REG3	; USER SUPPLIED LENGTH PUT IN REG3
	JRST	TSTLEN		; TEST FOR NULL SUBSTRING

WRVST.:	MOVE	REG3,0(REG1)		; GET ACTUAL LENGTH OF STRING
	ADDI	REG1,1			; ADVANCE TO POINT TO STRING

WRPST.: HRLI   REG1,440700		;WRITE PACKED STRING
	SKIPA
WRUST.: HRLI   REG1,444400		;WRITE NOTPACKED STRING
TSTLEN:	JUMPLE REG2,WRTRET		;FIELDWIDTH = 0 ?
WRTEST: CAIG   REG2,(REG3)		;LEADING BLANKS REQUESTED ?
	JRST	      STROUT		;NO
	MOVEI	  AC0," "
	PUSHJ	 TOPP,PUTCH.
	SOJA   REG2,WRTEST		;MORE LEADING BLANKS ?
STROUT: ILDB	  AC0,REG1
	PUSHJ	 TOPP,PUTCH.
	SOJG   REG2,STROUT		;ANY CHAR LEFT ?
WRTRET: POPJ	 TOPP,			;NO - RETURN

	PRGEND
	TITLE	WRBOL - BOOLEAN OUTPUT ROUTINE

	SEARCH	PASSYM
	EXTERN	WRBLK.
	EXTERN	PUTCH.

	ENTRY	WRBOL.

	$RELOC

WRBOL.: CAIGE  REG2, 5			;FORMAT GREATER  OR EQUAL  FIVE ?
	JRST   BSMALL			;NO - SMALL OUTPUT
	SUBI   REG2, 5
	PUSHJ  TOPP, WRBLK.		;WRITES LEADING BLANKS IF ANY
	MOVEI  REG2,5			;FIVE CHARACTERS ARE GIVEN OUT
	MOVE   REG3,[ASCII/FALSE/]
	SKIPE  REG1			;TRUE OR FALSE? - SKIP IF FALSE
	MOVE   REG3,[ASCII/ TRUE/]
	MOVE   REG1,[POINT 7,REG3,-1]
	ILDB   AC0, REG1		;GETS CHARACTER
	PUSHJ  TOPP,PUTCH.
	SOJG   REG2, .-2		;MORE CHARACTERS?
	POPJ   TOPP,			;NO - RETURN

BSMALL: JUMPE REG2,BOLEND		;FIELDWIDTH = 0?
	SUBI   REG2,1
	PUSHJ  TOPP,WRBLK.		;WRITES LEADING BLANKS IF ANY
	MOVEI AC0,"F"
	SKIPE REG1			;TRUE OR FALSE? - SKIP IF FALSE
	MOVEI  AC0,"T"
	PUSHJ  TOPP,PUTCH.
BOLEND: POPJ   TOPP,

	PRGEND
	TITLE	READC - CHARACTER INPUT?

	SEARCH	PASSYM
	EXTERN	GETCH.

	ENTRY	READC.

;EINGABETEILE FUER CHARACTER, INTEGER, REAL

	$RELOC

READC.:	MOVE	  AC0,FILCMP(REG)
	MOVEM	  AC0,(REG1)
	PUSHJ	 TOPP,GETCH.
	POPJ	 TOPP,

	PRGEND
	TITLE	WRTSUB - COMMON OUTPUT SUBROUTINES

	SEARCH	PASSYM
	EXTERN	PUTCH.

	ENTRY	WRBLK.
	ENTRY	WROPN.
	ENTRY	WRSGN.
	ENTRY	WRMIN.
	ENTRY	TOSML.

;
; CONVERSION ROUTINES FOR OUTPUT
;

	$RELOC

WRBLK.: JUMPLE REG2, .+4		;WRITES BLANKES OUT
	MOVEI AC0," "
	PUSHJ TOPP,PUTCH.
	SOJG  REG2, .-1 		;COUNT EQUAL ZERO?
	POPJ  TOPP,			;YES - RETURN

WROPN.: MOVEI REG5, (REG2)		;SAVES FORMAT BECAUSE REG2 IS USED FOR
					;IDIVI-INSTRUCTION
	SETZ  REG4,			;RH - COUNT OF DIGITS ON PUSH-LIST
					;LH - EQ 400000 IF SIGN = '-'
	JUMPGE REG1,.+4 		;NEGATIV NUMBER?
	TLO    REG4,400000		;YES - SET SIGN MARKER
	SUBI   REG5,1			;ONE PLACE IN FORMAT USE FOR SIGN
	MOVM   REG1,REG1
	JUMPL  REG1,TOSML.		;NO DECIMAL INTEGER OUTPUT
					;FOR 400 000 000 000B  - ONLY OCTAL OUTPUT !
	POPJ   TOPP,

WRSGN.: TLZN  REG4,400000		;SIGN EQUAL '-'?
	POPJ  TOPP,			;NO - RETURN
WRMIN.:	MOVEI AC0,"-"			;YES
	JRST  PUTCH.			;PUTCH RETURNS OVER PUT

TOSML.: MOVEI AC0, "*"			;FORMAT IS TOO SMALL
	PUSHJ  TOPP,PUTCH.
	SOJG   REG5, .-1
	POPJ   TOPP,			;RETURNS OUT OF WRITE-ROUTINE

	END
  ZZ