$PAGE	DEXP.2	 PDP-10/10I DOUBLE PRECISION EXP2 FUNCTION
;THIS ROUTINE CALCULATES A DOUBLE PRECISION NUMBER RAISED
;TO A FIXED POINT POWER. THE CALCULATION IS A**N, WHERE N
;IS AN INTEGER OF THE FORM
;	N= Q(0) + Q(1)*2 + Q(2)*4 + ... WHERE Q(I) = 0 OR 1
;THE ONLY RESTRICTION ON THE BASE OR EXPONENT IS THAT
;AN EXPONENT OF 400000000000 IS NOT HANDLED CORRECTLY.

;THE ROUTINE IS CALLED BY
;	MOVEI	Q, POWER
;	PUSHJ	P, DEXP2
;WHERE POWER IS THE ADDRESS OF THE FIXED POINT POWER, AND
;THE DOUBLE PRECISION BASE IS IN ACCUMULATORS A AND B. THE
;RESULT IS RETURNED IN ACCUMULATORS A AND B.

	SEARCH FORPRM
	ENTRY	DEXP2.
DEXP2.:	DMOVE	T0,@(L)		;GET THE BASE
	MOVEI	L,@1(L)		;POINT TO THE POWER
	SKIPN	(Q)		;IS EXPONENT 0?
	JRST	[MOVSI A,(1.0)	;YES, A**0 GIVES 1
		MOVEI B,0
		POPJ P,]
	JUMPE	A,[SKIPL (Q)	;IS BASE 0 WITH POSITIVE EXPONENT?
		POPJ P,		;YES, RETURN 0
		ERROR	(APR,5,1,.+1)	;BASE IS 0 WITH NEG. EXP- OVERFLOW
		HRLOI A,377777	;RETURN LARGEST POSITIVE NUMBER
	IFE CPU-KA10,<HRLOI B,344777 >
	IFN CPU-KA10,<HRLOI B,377777 >
		POPJ P,]
	MOVEM X,XSAVE		;SAVE AC TO DO BLT
	MOVE X,XBLT		;SAVE OTHER AC'S
	BLT X,XSAVE-1		;...

	SKIPL G,(Q)		;GET EXPONENT. IS IT NEGATIVE?
	JRST	[DMOVE D,A	;NO, PUT ARG IN D,D+1
		JRST DEX2]	;START MAIN LOOP
	MOVMS G			;GET POSITIVE VALUE
	MOVSI D,(1.0)		;GET DOUB. PRECISION 1.0
	MOVEI E,0		;...
				;CALCULATE (1/X)**N, SINCE N .L. 0
	DFDV D,0
	JFCL 1,OVER 


DEX2:	MOVSI A,(1.0)		;GET DOUB. PREC. 1.0
	MOVEI B,0		;...
	JRST DEX4		;START CALCULATING POWERS OF X (OR 1/X)

DEX3:				;SQUARE X (OR 1/X) AGAIN
	DFMP D,D
	JOV OVR 

	LSH G,-1		;LOOK AT NEXT BIT IN N
DEX4:	TRZN G,1		;IS LO BIT IN N A 1?
	JRST DEX5		;NO, DON'T MULTIPLY INTO ANSWER
				;MULTIPLY POWER OF X INTO ANSWER
	DFMP A,D
	JOV DEX6 

DEX5:	JUMPN G,DEX3		;IF G .N. 0, GET MORE POWERS OF X (OR 1/X)
DEX6:	MOVS X,XBLT		;RESTORE AC'S
	BLT X,X			;...
CPOPJ:	POPJ P,

OVR:				;ARITHMETIC FAULT, MOVE FIX UP TO A,B
	SKIPGE A		;SHOULD RESULT BE NEGATIVE?
	DFN D,E			;YES
OVR2:
	DMOVE A,D

	JRST DEX6		;AND EXIT

OVER:	JUMPGE D,OVR2		;IF THE ARG IS <0 AND THE EXPONENT
	TRNN	G,1		;IS ODD, THEN
	DFN	D,E		;THE ANSWER
	JRST	OVR2		;IS < 0.


XBLT:	XWD C,ACSAVE		;BLT POINTER TO RESTORE AC'S
ACSAVE:	BLOCK X-C
XSAVE:	BLOCK 1			;FOR AC X

TEMP:	BLOCK 2

	PRGEND
$PAGE	DEXP.3	 PDP-10/10I DOUBLE PRECISION EXP.3 FUNCTION
;THIS PROGRAM CALCULATES A**B, WHERE A AND B ARE DOUBLE
;PRECISION FLOATING POINT NUMBERS. THE ALGORITHM USED IS
;A**B = DEXP(B*DLOG(/A/)).  THE ABSOLUTE VALUE OF A IS USED
;IN THIS CALCULATION BECAUSE A NEGATIVE NUMBER TO A
;NON-INTEGER POWER PRODUCES A COMPLEX ANSWER, AND B IS
;PRESUMED TO BE NON-INTEGER.


;THE CALLING SEQUENCE FOR THE ROUTINE IS AS FOLLOWS:
;	MOVEI	Q, ARG2
;	PUSHJ	P, DEXP3
;ARG2 IS THE ADDRESS OF THE HIGH ORDER PART OF THE DOUBLE
;PRECISION POWER, AND THE BASE, ARG1, IS IN ACCUMULATORS
;A AND B WHEN THE ROUTINE IS CALLED. THE DOUBLE PRECISION
;ANSWER IS LEFT IN ACCUMULATORS A AND B.

	SEARCH FORPRM
	ENTRY	DEXP3.
DEXP3.:	DMOVE	T0,@(L)	;GET THE BASE
	MOVEI	L,@1(L)
	SKIPN	(Q)		;IS EXPONENT ZERO?
	JRST	DEXPZ		;YES, RETURN ANSWER OF 1.0
	JUMPE	A,[SKIPL (Q)	;IS BASE 0 WITH POS EXPONENT?
		POPJ P,		;YES, RETURN 0
		JRST OV4]	;NO, BASE 0 AND NEG EXP- OVERFLOW
	SKIPG	A		;GET
	DFN	A,B		;/A/
	DMOVEM	A,ARGAX		;IN ARGAX.
	FUNCT	DLOG.,<ARGAX>	;CALC.
				;LOG(/A/).
	DMOVEM	A,ARGAX		;STORE IT IN ARGAX.
	DMOVE	A,(Q)		;ARG B TO AC'S 0 AND 1.
	MOVEM	C,CSAVE		;SAVE AC 2.

	DFMP A,ARGAX
	JFCL OVUNFL 

	DMOVEM	A,ARGAX		;STORE B*LOG(/A/) IN ARGAX.
	FUNCT	DEXP.,<ARGAX>	;CALC. EXP[B*LOG(/A/)] AND
				;LEAVE IT IN AC'S 0 AND 1.
	MOVE	C,CSAVE		;RESTORE AC 2.
	POPJ	P,		;EXIT.

DEXPZ:	MOVSI	A, (1.0)	;ANS = 1.0
	MOVEI	B, 0		;AND
	POPJ	P,		;EXIT.

OVUNFL:	MOVE	C,CSAVE		;RESTORE AC 2.
	JUMPE	A,DEXPZ		;IF EXP= 0, ANS = 1.0.
	JUMPL	A,OV6		;GO TO UNDERFLOW.
OV4:	ERROR	(APR,5,1,.+1)	;OVERFLOW. OUTPUT
	HRLOI	A,377777	;ANS =
	HRLOI	B,377777		; INFINITY
	POPJ	P,		;EXIT.
OV6:	ERROR	(APR,7,1,.+1)	;UNDERFLOW. OUTPUT
	SETZB	A,B		;ANS = 0, AND
	POPJ	P,		;EXIT.

ARGAX:	BLOCK 2
CSAVE:	BLOCK	1		

	PRGEND
$PAGE	DEXP.	 PDP-10/10I DOUBLE PRECISION EXPONENTIAL FUNCTION

;ARGUMENT. AN ARGUMENT OF ZERO CAUSES AN IMMEDIATE EXIT WITH AN
;ANSWER OF 1.0 . AN ARGUMENT WHOSE MAGNITUDE EXCEEDS 88.028
;CAUSES THE ROUTINE TO EXIT WITH 0 IF THE ARGUMENT WAS NEGATIVE.
;AND 377777777777 IF THE ARGUMENT WAS POSITIVE. THIS IS
;BECAUSE DIRECT CALCULATION OF EXP(X) FOR ABSF(X)>88.028 WOULD
;CAUSE EXPONENT OVERFLOW OR UNDERFLOW.

;THE ROUTINE USES THE FOLLOWING ALGORITHM:
;EXP(X)	= 2**(X*LOG2(E))
;	= 2**(M+F) WHERE M IS AN INTEGER AND 0<F<1
;	= 2**(M+N+R) WHERE 0<R<1/8 AND M+N+R=X*LOG2(E)

;	= 2**(M+N) * EXP(R*LOG(2))
;2**M IS CALCULATED EASILY WITH THE FLOATING SCALE INSTRUCTION.
;2**N IS CALCULATED BY DETERMINING THE CORRECT INTERVAL OF N AND
;USING A TABLE OF POWERS OF TWO FROM 2**1/8 TO 2**7/8.

;FINALLY, EXP(R*LOG(2)) IS CALCULATED BY A CONTINUED FRACTION
;TAKEN FROM RALSTON AND WILF, "METHODS FOR DIGITAL COMPUTERS" :
;EXP(R*LOG(2)) = 1+A4/((B4/R) -C4 + D4*R + H4/(R + B4/R))

;THE FOLLOWING ERRORS HAVE BEEN OBSERVED WITH DEXP:
;	1. WITH -10.0<X<10.0, ERRORS RANGED FROM 0 TO 48
;	   UNITS IN THE 19TH SIGNIFICANT DIGIT. THE MEAN ERROR
;	   FOR 20 READINGS WAS 5.4 UNITS IN THE 19TH DIGIT.
;	2. WITH 10.0<X<40.0, ERRORS RANGED FROM 0 TO 41 UNITS
;	   IN THE 19TH SIGNIFICANT DIGIT. THE MEAN ERROR FOR
;	   7 READINGS WAS 16 UNITS IN THE 19TH SIGNIFICANT DIGIT.
;	3. WITH 40.0<X<88.0, ERRORS RANGED FROM 5 TO 57 UNITS IN
;	   THE 19TH SIGNIFICANT DIGIT. THE MEAN ERROR FOR 12
;	   READINGS WAS 44.4 UNITS IN THE 19TH SIGNIFICANT DIGIT.
;THE ERRORS REFERRED TO ABOVE ARE ABSOLUTE ERRORS. IT SHOULD
;BE NOTED THAT ADDITIONAL ERRORS ARE INTRODUCED BY ERRORS IN
;THE DOUBLE PRECISION INPUT AND OUTPUT ROUTINES.

	SEARCH FORPRM

;CONSTANTS AND TEMPORARY LOCATIONS AND STUFF

XBLT:	XWD	C,ACSAVE

DCON1:	88.028
DLOG2E:	DOUBLE	201561250731,112701376057	;LOG2(E) = 1.44269 50408 88963 40740
TABLE:	0			;0
	040000000000		;1/8
	100000000000		;2/8
	140000000000		;3/8
	200000000000		;4/8
	240000000000		;5/8
	300000000000		;6/8
	340000000000		;7/8
ONE:				;DOUBLE PRECISION 1.0
POWERS:	DOUBLE 1.0,0			;2**0 = 1.0
	DOUBLE 201427127017,037250572672	;2**1/8 = 1.09050 77326 65257 65919
	DOUBLE 201460337602,214333425134	;2**2/8 = 1.18920 71150 02721 06671
	DOUBLE 201513773265,115425047073	;2**3/8 = 1.29683 95546 51009 66590
	DOUBLE 201552023631,237635714441	;2**4/8 = 1.41421 35623 73095 04878
	DOUBLE 201612634520,212520333270	;2**5/8 = 1.54221 08254 07940 824
	DOUBLE 201656423746,126551655275	;2**6/8 = 1.68179 28305 07429 086
	DOUBLE 201725403067,076722207113	;2**7/8 = 1.83400 80864 09342 463

A4:	DOUBLE 206744575555,062215755376	;A4 = 60.59319 17173 36463 11080
B4:	DOUBLE 207535527021,213670572221	;B4 = 87.41749 72022 35527 474
MC4:	DOUBLE 572033202222,715562022402	;MC4=-C4 = -30.29659 58586 68231 555
D4:	DOUBLE 201414631463,063146314632	;D4 = 1.05
H4:	DOUBLE 210654261010,261565402456	;H4 = 214.17286 81454 77042 3113

ACSAVE:	BLOCK	X-C+1

B4F:	BLOCK 	2	;TEMP FOR B4*F
FB4F:	BLOCK	2	;TEMP FOR F+B4*F

	HELLO	(DEXP,.)	;[235] ENTRY TO DEXP ROUTINE
	MOVE	0,XBLT		;SAVE ACCUMULATORS
	BLT	0,ACSAVE+X-C	;...
	DMOVE	A,@(Q)		;PICK UP ARGUMENT
	JUMPE	A,[MOVSI A,(1.0)	;RETURN 1.0 FOR ARG OF ZERO
		JRST DEXEND]		;EXIT
	MOVM	C,A		;GET POS VALUE OF EXPONENT
	CAML	C,DCON1		;TOO BIG TO COMPUTE?
	JRST	[HRLOI A,377777	;YES, GET LARGEST POS NUM
		MOVE C,ACSAVE	;RESTORE AC C.
		SKIPGE @(Q)	;SUPPOSED TO BE SMALL ?
		MOVEI A,1	;YES, MAKE IT VERY SMALL
		FADL A,A	;CAUSE OVER/UNDERFLOW, RETURN FIX UPS
		JRST DEXEND]	;RETURN
	FLMUL A,DLOG2E

	HLRE	E,A		;EXTRACT EXPONENT
	ASH	E,-9		;...
	TSC	E,E		;TAKE 1'S COMPLEMENT IF NUM .L. 0
	SKIPGE	A		;CHANGE  EXPONENT BITS TO SIGN BITS
	TLOA	A,377000	;NUMBER NEGATIVE, SET BITS
	TLZ	A,377000	;NUMBER POSITIVE, CLEAR BITS
	ASHC	A, 8		;LEFT JUSTIFY ARG FRACTION BITS
				;GET ANOTHER COPY OF FRACTION
	DMOVE C,A

	ASHC	A, -243(E)	;SIMULATE THREE-WORD SHIFT WITH...
				;TWO LONG SHIFTS. THIS LEAVES INTEGER
				;IN A, FRAC IN B AND C.
	LSH	D,1		;SQUEEZE OUT SIGN BIT
	LSHC	C,43-200(E)	;THEN DO 2ND LONG SHIFT, (THE LSHC HERE
					;PREVENTS OVERFLOW GOING LEFT)
	TLZ	B, (1B0)	;CLEAR SIGN BIT. IF FRAC WAS <0,
				;THIS GIVES 1-FRAC AND PROPER EXP.
	HRRM	A, SCALE	;SAVE EXPONENT FOR FUTURE SCALING
	MOVEI	G, 7		;GET INDEX REGISTER POINTER TO TABLE
REDUCE:	CAMN	B, TABLE(G)	;DOES ARGUMENT MATCH TABLE ENTRY?
	JUMPE	C,[LSH G,1	;YES, IFF LO HALF=0. CHANGE INDEX TO POINTER
				;PICK UP DOUBLE WORD ANSWER
		DMOVE A,POWERS(G)
		JRST SCALE]	;SCALE RESULTS AND EXIT
	CAMGE	B, TABLE(G)	;IS ARGUMENT GREATER THAN ENTRY?
	SOJA	G, REDUCE	;NO, TRY NEXT LOWER ENTRY
	SUB	B, TABLE(G)	;YES, ALL DONE -REDUCE ARGUMENT
	LSH	G, 1		;SAVE INDEX AS A POINTER
	ASHC	B, -8		;MAKE ROOM FOR EXPONENT
	TLO	B,200000	;INSERT EXPONENT
	DFAD	B,[EXP 0,0]	;NORMALIZE RESULT
	DMOVE	A,B 		;PUT RESULT AN A,B

				;GET B4/F
	DMOVE D,B4
	FLDIV D,A
				;SAVE B4/F
	DMOVEM D,B4F
				;GET F+B4/F
	FLADD D,A
				;GET H4/(F+B4/F)
	DMOVEM D,FB4F
	DMOVE D,H4
	FLDIV D,FB4F
				;GET D4*F
	FLMUL A,D4
				;GET (B4/F)-C4+D4*F+(H4/(F+B4/F))
	FLADD D,A
	FLADD D,MC4
	FLADD D,B4F
				;GET 1.0+A4/REST
	DMOVE A,A4
	FLDIV A,D
	FLADD A,ONE

	JUMPE	G,SCALE		;MULTIPLY BY POWER OF TWO?
	FLMUL A,POWERS(G)

SCALE:	FSC	A,.-.		;SCALE RESULTS
DEXEND:	MOVS	X, XBLT		;PICK UP THE BLT POINTER
	BLT	X, X		;RESTORE THE ACCUMULATORS
	GOODBY	(1)		;EXIT

	LIT

	PRGEND
$PAGE	DLOG.	 PDP-10/10I DOUBLE PRECISION LOGARITHM FUNCTION
;THIS PROGRAM CALCULATES THE LOGARITHM OF A DOUBLE PRECISION
;ARGUMENT. THE ALGORITHM USED IS DESCRIBED ON PAGES 29-30 OF
;RALSTON AND WILF, "MATHEMATICAL METHODS FOR DIGITAL COMPUTERS".
;THE ARGUMENT X IS WRITTEN AS

;	X = (2**N)*F	WHERE 1/2 < F < 1
;THEN LOG(X) = (N*LOGE(2)) + LOG(F)
;F IS REDUCED BY FIXED POINT MULTIPLICATION BY NOT MORE THAN
;THREE CONSTANTS. THIS YIELDS

;	0 < T = A1*A2*A3*F - 1.0 < (2**-7)/5
;NOTE THAT NOT ALL THE A1,A2,A3 NEED BE INCLUDED IN THE PRODUCT.
;FINALLY, 
;	LOG(F) = LOG(1+T) - LOG(A1) - LOG(A2) - LOG(A3)
;LOG(1+T) IS CALCULATED AS A TAYLOR SERIES IN T.

;THE ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	JSA	Q, DLOG
;	EXP	ARG
;WHERE ARG IS THE ADDRESS OF THE HIGH ORDER PART OF THE DOUBLE
;PRECISION ARGUMENT. THE RESULT IS LEFT IN ACCUMULATOR A AND B.
;AVAILABLE TABLES FOR LOGARITHMS LIST 16 SIGNIFICANT DIGITS,
;ALL OF WHICH AGREE WITH VALUES PRODUCED BY THIS PROGRAM. AN
;ESTIMATE OF THE MAXIMUM THEORETICAL ERROR IS OBTAINED BY OB-
;SERVING THAT, AFTER REDUCTION, THE ARGUMENT IS LESS THAN
;(2**-7)/5 = .00625. HENCE, THE ERROR IN THE TAYLOR SERIES
;IS LESS THAN
;	(.00625**9)/9 = 1.4573*10**-20/9 = .1619*10**-20

	SEARCH FORPRM

;CONSTANTS AND TEMPORARY LOCATIONS AND STUFF

LOGLST:	DOUBLE 200471174064,325425031470	;0.61180 15411 05992 8976
	DOUBLE 200402252251,151350376610	;0.50455 60107 52395 2859
	DOUBLE 177637144373,057714113734	;0.40546 51081 08164 3810
	DOUBLE 177506061360,207057302360	;0.31845 37311 18534 6147
	DOUBLE 176710776761,346515041520	;0.22314 35513 14209 7553
	DOUBLE 176537746034,051711723600	;0.17185 02569 26659 2214
	DOUBLE 175557032242,271265512760	;0.08961 21586 89687 12374
	DOUBLE 173770123303,236031377700	;0.03077 16586 66753 68689

LIST:	354000000000		;1.11011 BINARY
	324000000000		;1.10101 BINARY
	300000000000		;1.10000 BINARY
	260000000000		;1.01100 BINARY
	240000000000		;1.01000 BINARY
	230000000000		;1.00110 BINARY
	214000000000		;1.00011 BINARY
	204000000000		;1.00001 BINARY

DLOGE2:	DOUBLE 200542710277,276434757153	;0.69314 71805 59945 30941 72321

A9:	DOUBLE 175707070707,034343434344	;1/9
A8:	DOUBLE 601400000000,0			;-1/8
A7:	DOUBLE 176444444444,222222222222	;1/7
A6:	DOUBLE 601252525252,652525252526	;-1/6
A5:	DOUBLE 176631463146,146314631463	;1/5
A4:	DOUBLE 600400000000,0			;-1/4
A3:	DOUBLE 177525252525,125252525253	;1/3
A2:	DOUBLE 577400000000,0			;-1/2
ONE:
A1:	201400000000
DZERO:	000000000000
	IFE CPU-KI10,<0	>

SUMSAV:	BLOCK 2		;STORAGE FOR PARTIAL ANSWER

XBLT:	XWD	C, ACSAVE
ACSAVE:	BLOCK	X-C+1

;DOUBLE PRECISION COMMON LOGARITHM FUNCTION
;THE ROUTINE CALCULATES THE LOGARITHM, BASE 10, OF A DOUBLE
;PRECISION ARGUMENT. THE ALGORITHM USED IS
;	DLOG10(X) = DLOG(X)*LOG10(E)

;THE CALLING SEQUENCE FOR THE ROUTINE IS THE FOLLOWING:
;	JSA	Q, DLOG10
;	EXP	ARG
;THE DOUBLE PRECISION ANSWER IS RETURNED IN AC A AND B.


	HELLO	(DLG10.,DLOG10)	;[235] ENTRY TO DLOG10 ROUTINE
	MOVEI	B,@(Q)		;GET ADDRESS OF ARGUMENT
	SKIPN	B,(B)		;IF ARG = 0,
	JRST	ZERO		;THEN GO TO ZERO.
	PUSHJ	P,DLOG.		;CALCULATE LOG(ARG)

	FLMUL A,LOG10D

	GOODBY	(1)		;EXIT

LOG10D:	DOUBLE 177674557305,111562416145	;.43429448190325182765


	HELLO	(DLOG,.)	;[235] ENTRY TO DLOG ROUTINE
	MOVE	0,XBLT		;SAVE AC'S
	BLT	0,ACSAVE+X-C	;...
	DMOVE	A,@(Q)		;PICK UP ARGUMENT
	JUMPG	A,DLOGP		;ARGUMENT IS GREATER THAN 0
	JUMPE	A, ZERO		;CHECK FOR ZERO ARGUMENT
	ERROR	(LIB,12,2,[ASCIZ /Attempt to take DLOG of Negative Arg/])
	DMOVN	A,@(Q)		;GET ABSF(X)
DLOGP:	CAMN	A,ONE		;X PRECISELY 1.0?
	JUMPE	B,[SETZB A,B
		JRST DLOG5]	;YES, RETURN ZERO
DLOG1:	LDB	D,[POINT 8,A,8]	;NO,PICK UP EXPONENT FROM HI ORDER
	SUBI	D, 200		;GET EXPONENT EXCESS 200
	FSC	D,233		;MAKE FLOATING POINT NUMBER
	MOVEI	E,0		;SET UP LO HALF
				;CALCULATE N*LOGE(2)
	FLMUL D,DLOGE2
	DMOVEM D,SUMSAV

	TLZ	A,777000	;MASK OUT EXPONENT
	ASHC	A,8		;NORMALIZE FRACTION TO BIT 1
	SETZB	D,E		;INITIALIZE REDUCTION CONSTANT TO 0
DLOG2:	LDB	G,[POINT 3,A,4]	;GET HI 3 BITS BELOW 1/2
	MUL	B, LIST(G)	;FIXED POINT MULTIPLY FOR LO HALF
	MOVE	C,B		;SAVE HI HALF OF LO PRODUCT
				;(LO HALF IS ALL 0'S, THROW IT AWAY)
	MUL	A, LIST(G)	;MULTIPLY HI ORDER, TOO
	TLO	B,(1B0)		;SET BIT 0, TO AVOID OVERFLOW
	ADD	B,C		;COMBINE RESULTS OF MULTIPLY
	TLZN	B,(1B0)		;CLEAR BIT 0, WAS THERE OVERFLOW?
	ADDI	A,1		;YES, PROPOGATE CARRY
	ASH	G, 1		;TURN BITS INTO D.P. POINTER
	FLADD D,LOGLST(G)

	TLZE	A, 200000	;IS THE PRODUCT .GE. 1.0?
	JRST	DLOG3		;YES
	ASHC	A, 1		;NO, GET RID OF EXTRANEOUS ZERO
	JRST	DLOG2		;TRY ANOTHER MULTIPLICATION

DLOG3:	ASHC	A, -7		;MAKE ROOM FOR THE EXPONENT
	TLC	A,200000	;INSERT EXPONENT
	DFAD	A,DZERO 	;NORMALIZE
	DFN	D,E		;NEGATE LOG OF MAGIC NUMBERS
				;AND ADD INTO FINAL SUMMATION
	FLADD D,SUMSAV
	DMOVEM D,SUMSAV
				;PICK UP CONSTANT TO START
	DMOVE D,A9

	MOVEI	G,A8		;INIT TABLE POINTER AT A8
DLOG4:				;MULTIPLY ACCUMULATED SUM BY X

	FLMUL D,A
				;ADD NEXT CONSTANT INTO PARTIAL SUM
	FLADD D,0(G)

	ADDI	G, 2		;UPDATE POINTER TO NEXT CONSTANT
	CAIG	G, A1		;ARE WE DONE YET?
	JRST	DLOG4		;NO, LOOP BACK FOR MORE TAYLOR SERIES
				;YES, ONE LAST MULTIPLICATION
	FLMUL A,D
				;AND ADD SERIES SUM INTO FINAL ANSWER
	FLADD A,SUMSAV

DLOG5:	MOVS	X, XBLT		;PICK UP BLT POINTER
	BLT	X,X		;RESTORE ACCUMULATORS
	GOODBY	(1)		;EXIT

ZERO:	MOVSI	A,400000	;SET UP LARGE NEG. NUM.
	DFAD	A,A
	GOODBY	(1)		;TRAP ROUTINE FIXED IT UP AND
				;PRINTED MESSAGE
	PRGEND
$PAGE	DSQRT.   DOUBLE PRECISION SQUARE ROOT
;DOUBLE PRECISION SQUARE ROOT FUNCTION
;THIS ROUTINE CALCULATES THE SQUARE ROOT OF A DOUBLE PRECISION
;ARGUMENT BY DOING A LINEAR SINGLE PRECISION APPROXIMATION ON
;THE HIGH ORDER WORD, THEN TWO DOUBLE PRECISION ITERATIONS OF
;NEWTONS METHOD. THIS SHOULD GENERATE A RESULT ACCURATE TO
;20 DECIMAL SIGNIFICANT DIGITS. THE ALGORITHM IS AS FOLLOWS

;X = (2**(2N))*F, WHERE 1/2 < F < 1
;HENCE SQRT(X) = 2**N * SQRT(F)
;THE LINEAR APPROXIMATION IS OF THE FORM
;SQRT(F) = A2 - B2/(C2+F-D2/(E2+F))
;WHERE THE CONSTANTS A2,B2,C2,D2, AND E2 HAVE THE FOLLOWING
;VALUES

;CONSTANT	VALUE WHEN 0.25<F<0.50	VALUE WHEN 0.50<F<1.0
;A2		(5/14)*SQRT(70)		(5/7)*SQRT(35)
;B2		(50/49)*SQRT(70)	(200/49)*SQRT(35)
;C2		47/14			47/7
;D2		4/49			16/49
;E2		3/14			3/7


	SEARCH FORPRM


;CONSTANTS AND TEMPORARY LOCATIONS AND STUFF

A2:	202576362203		;2.98807152
	203416346045		;4.225771271
B2:	204421143713		;8.537347194
	205602266310		;24.14726441
C2:	202655555556		;3.357142857
	203655555556		;6.7142857143
D2:	175516274052		;0.0816326531
	177516274052		;0.326530612
E2:	176666666667		;0.2142857143
	177666666667		;0.4285714286

XBLT:	XWD	C,ACSAVE
ACSAVE:	BLOCK	X-C+1
N:	BLOCK 2		;STORAGE FOR ARGUMENT

	HELLO	(DSQRT,.)	;[235] ENTRY TO DSQRT ROUTINE
	MOVE	0, XBLT		;SET UP BLT POINTER
	BLT	0, ACSAVE+X-C	;SAVE SOME ACCUMULATORS
	DMOVE	A,@(Q)		;GET D.P. ARG
	JUMPG	A, DSQRTP	;ARGUMENT IS GREATER THAN 0
	JUMPE	A, DSQRT4	;ARGUMENT OF ZERO?
;**; [554] CHANGE @ N + 7L IN DSQRT.	CLRH	11-JUN-76
	ERROR	(LIB,13,2,[ASCIZ /Attempt to take DSQRT of Negative Arg/])
	DMOVN	A,@(Q)		;GET ARGS AGAIN (ABSF)
DSQRTP:	MOVE	F, A		;GET SPARE COPY OF HIGH ORDER
	LSH	F, -33		;GET RID OF FRACTION BITS
	SUBI	F, 201		;GET RID OF THE BASE 200 PART OF
				;EXPONENT. EXTRA 1 IS A FUDGE.
	ROT	F, -1		;CUT EXPONENT IN HALF, SAVE EXTRA
				;BIT FOR LATER USE AS INDEX REG.
	HRRM	F, DSQRT1	;SAVE REDUCED EXPONENT FOR SCALING
	LSH	F, -43		;BRING BIT BACK - IF 0, THEN
				;1/4<F<1/2,OTHERWISE 1/2<F<1.
	TLZ	A, 777000	;WIPE OUT EXPONENT BITS IN ARG.
	FSC	A, 177(F)	;RESET IT TO EITHER 177 OR 200
	MOVE	D, A		;PICK UP ANOTHER COPY OF NEW FRAC.
	FADR	D, E2(F)	;FORM E2+F
	MOVN	C, D2(F)	;PICK UP -D2
	FDVR	C, D		;CALCULATE -D2/(E2+F)
	FADR	C, C2(F)	;GET C2-D2/(E2+F)
	FADR	C, A		;CALCULATE F+C2-D2/(E2+F)
	MOVN	D, B2(F)	;PICK UP -B2
	FDVR	D, C		;GET -B2/(F+C2-D2/(E2+F))
	FADR	D, A2(F)	;GET FINAL FIRST APPROXIMATION
	MOVEI	E,0		;LOW HALF OF 1ST APPROX. IS 0
	DMOVEM	A,N		;SAVE DSQRT ARGUMENT
				;GET N/X0
	FLDIV A,D
				;X0+N/X0
	FLADD D,A

	FSC	D,-1		;X1=.5*(X0+N/X0)
	DMOVE	A,N		;GET N BACK
				;N/X1
	FLDIV A,D
				;X1+N/X1
	FLADD A,D

DSQRT1:	FSC	A,.-.		;SCALE RESULTS FOR ANSWER 
DSQRT3:	MOVS	X, XBLT		;SET UP THE BLT POINTER
	BLT	X, X		;RESTORE THE ACCUMULATORS
DSQRT4:	GOODBY	(1)		;EXIT



	PRGEND
$PAGE	DSIN.	 DOUBLE PRECISION SIN AND COSINE ROUTINE

;DOUBLE PRECISION SINE AND COSINE FUNCTION
;THIS PROGRAM CALCULATES THE SINE AND COSINE OF A DOUBLE
;PRECISION ARGUMENT.  FOR A DESCRIPTION OF THE ALGORITHM,
;SEE THE SCIENCE LIBRARY AND FORTRAN UTILITY SUBPROGRAMS
;MANUAL.

;THE CALLING SEQUFOR THE PROGRAM IS AS FOLLOWS:
;	JSA	Q, DSIN
;	EXP	ARG
;WHERE ARG IS THE ADDRESS OF THE HIGH ORDER PORTION OF THE
;ARGUMENT. THE DOUBLE PRECISION ANSWER IS LEFT IN ACCUMULATORS
;A AND B.

	SEARCH	FORPRM

;CONSTANTS AND TEMPORARY LOCATIONS AND STUFF

C17:	DOUBLE 120625130734,014126512326	;1/17!=.28114572543455207632E-14
	DOUBLE 124656376371,314734037043	;1/16!=.47794773323873852974E-13
C15:	DOUBLE 647121401406,463043740735	;-1/15!=-.76471637318198164759E-12
	DOUBLE 643154321325,717701542677	;-1/14! =-.11470745597729724714E-10
C13:	DOUBLE 140541110604,352066411370	;1/13!=.16059043836821614599E-9
	DOUBLE 144436733073,376154227552	;1/12!=.20876756987868098979E-8
C11:	DOUBLE 630121467246,402535434340	;-1/11!=-.25052108385441718775E-7
	DOUBLE 624330066022,441660243433	;-1/10!=-.27557319223985890653E-6
C9:	DOUBLE 156561674351,125543463437	;1/9!=.27557319223985890653E-5
	DOUBLE 161640064006,200320032003	;1/8!=.24801587301587301587E-4
C7:	DOUBLE 613137713771,577457745775	;-1/7!=-.19841269841269841270E-3
	DOUBLE 610223722372,517511751175	;-1/6!=-.1388888888888888889E-2
C5:	DOUBLE 172421042104,104210421042	;1/5!=.00833333333333333333333
	DOUBLE 174525252525,125252525253	;1/4!=.041666666666666666667
C3:	DOUBLE 601252525252,652525252526	;-1/3!=-0.16666666666666666667
C2:	577400000000	;-1/2!=-0.50000000000000000000
	000000000000


PIOTLO=021026430215	;LOW HALF OF PI/2 FOR PDP-6/KI10

ADDTBL:	DOUBLE 576155700452,-PIOTLO	;-PI/2
	DOUBLE 575155700452,-PIOTLO	;-PI
	574322320340	;-3*PI/2
	IFE CPU-KA10,<150146336134>
	IFN CPU-KA10,<463157055627>
	DOUBLE 574155700452,-PIOTLO	;-2*PI

ONE:	1.0
	0
XBLT:	XWD C, ACSAVE

PIOT:	DOUBLE	201622077325,PIOTLO	;PI/2
FLAG:	0		;NEGATE ANSWER IF (FLAG) IS MINUS
COSFLG:	BLOCK 1	;2 FOR COSINE SERIES, 0 FOR SINE
ACSAVE:	BLOCK X-C+1	;SAVE ROOM FOR STORING AC'S
ARGSAV:	BLOCK 2	;TEMP FOR X

	HELLO	(DCOS,.)	;[235] ENTRY TO COSINE ROUTINE
	MOVE	0,XBLT
	BLT	0,ACSAVE+X-C	;SAVE ACCUMULATORS
	DMOVE	A,@(Q)		;GET DOUBLE WORD ARGUMENT
	FLADD	A,PIOT		;COS(X)=SIN(PI/2+X), LEAVE RESULT IN A
	JRST	DSIN0		;ENTER SINE ROUTINE

	HELLO	(DSIN,.)	;[235] ENTRY TO SINE ROUTINE
	MOVE	0,XBLT
	BLT	0,ACSAVE+X-C	;SAVE ACCUMULATORS
	DMOVE	A,@(Q)		;GET DOUBLE WORD ARGUMENT
DSIN0:	JUMPE	A, DSIN4C	;ARGUMENT OF ZERO?
	SETZB	G, FLAG		;SET FLAG FOR POSITIVE ARGUMENT
	JUMPGE	A, DSIN1	;IS ARGUMENT POSITIVE?
	SETOM	FLAG		;NO, CHANGE FLAG
	DFN	A, B		;NEGATE THE ARGUMENT
DSIN1:	DMOVEM	A,ARGSAV
			;CALCULATE X/(PI/2),LEAVE THE RESULTS IN A,A+1
	FLDIV	A,PIOT
	CAML	A,[1.0]		;IS X .L. PI/4?
	JRST	REDUCE		;NO, REDUCE IT
	CAML	A,[0.5]		;IS X .GE. PI/4
	MOVEI	G,1		;YES, 2ND OCTANT
DSIN1A:	DMOVE	A,ARGSAV
DSIN2:	TRNE	G,4		;QUADRANTS 3 OR 4?
	SETCMM	FLAG		;YES, SINE IS NEGATIVE
	JUMPE	G,DSIN3		;IS X .L. PI/4
	TRNE	G,1		;NO,GET INDEX INTO QUADRANT TABLE
	ADDI	G,1		;...
				;MAKE: -PI/4 .GE. X .LE. +PI/4
	FLADD	A,ADDTBL-2(G)
	SKIPGE	A
	DFN	A,B		;TAKE ABSOLUTE VALUE
	DMOVEM	A,ARGSAV
DSIN3:	TRZ	G,777775	;LEAVE ONLY OCTANT BIT
	HRRZM	G,COSFLG	;0 FOR SINE SERIES, 2 FOR COSINE
	CAMG	A,[XWD 147471,421605]	;IS X .L. SQRT(6)*2**-27?
	JRST	SMALL		;YES, THEN SIN(X)=X
				;CALCULATE X**2, AND LEAVE IN A,A+1
	FLMUL	A,ARGSAV

				;INITIALIZE PARTIAL SUM
	DMOVE	D,C17(G)
	MOVEI	G,C15(G)	;TURN OCTANT POINTER INTO TABLE ADR

DSIN3C:				;MULTIPLY PARTIAL SUM BY X**2
	FLMUL	D,A
				;ADD NEXT CONSTANT TO PARTIAL SUM
	FLADD	D,0(G)
	ADDI	G,4		;MOVE POINTER TO NEXT CONSTANT
	CAIG	G,C2		;DONE?
	JRST	DSIN3C		;NO, LOOP BACK FOR MORE OF SERIES
				;YES, ONE MORE MULTIPLY
	FLMUL	A,D
				;ADD 1.0 INTO SUM
	FLADD	A,ONE

	SKIPE	COSFLG	;IS THIS COSINE SERIES?
	JRST	DSIN4A		;YES
				;NO, MULTIPLY BY X, THIS IS SIN
	FLMUL	A,ARGSAV
DSIN4A:	SKIPE	FLAG		;NEGATE RESULT?
	DFN	A,B		;YES
DSIN4C:	MOVS	X,XBLT		;SET UP BLT POINTER
	BLT	X,X		;RESTORE AC'S
	GOODBY	(1)		;EXIT

SMALL:	JUMPE	G,DSIN4A	;CALCULATING COSINE?
	DMOVE	A,ONE		;YES, COS(X)=1.0
	JRST	DSIN4A

REDUCE:	MOVE	D,A		;SAVE QUADRANT NUMBER
	LDB	G,[POINT 8,A,8]	;GET EXPONENT
	LSH	B,1		;REMOVE 1 BIT FOR KI10
	TLZ	A,777000	;DITTO HI EXPONENT
	LSHC	A,-202(G)	;MAKE ARGUMENT MODULO 2 PI
	LDB	G,[POINT 3,A,11]	;GET QUADRANT AND OCTANT BITS
	CAMGE	D,[4.0]		;IS NON-REDUCED ARG OK?
	JRST	DSIN1A		;YES, SAVE THE DFMP INACCURICIES
	TLZ	A,777000	;MAKE WAY FOR EXPONENT
	TLO	A,202000	;PUT EXP IN HI WORD, NO NORMALIZE
	LSH	B,-1		;PUT LO FRACTION IN PLACE
	DFAD	A,[EXP 0,  0]	;NORMALIZE
	FLMUL	A,PIOT		;CHANGE MAKE TO RADIANS (MOD 2 PI)
	DMOVEM	A,ARGSAV
	JRST	DSIN2		;GO CHANGE ARGUMENT TO 1ST OCTANT


	LIT
	PRGEND
$PAGE	DATN2.	 TWO ARGUMENT DOUBLE PRECISION ARC TANGENT

;THIS ROUTINE CALCULATES THE ARCTANGENT OF A/B
;IF ARGUMENT IS IN 2ND QUADRANT, DATAN2(A,B)=DATAN(A/B) + PI
;IF ARGUMENT IS IN 3RD QUADRANT, DATAN2(A,B)=DATAN(A/B)-PI
;IF ARGUMENT IS IN 1ST OR 4TH QUADRANT, DATAN2(A,B)=DATAN(A/B)

;IF QUOTIENT A/B OVER OR UNDERFLOWS, RETURN AN ANGLE
;ON A CO-ORDINATE AXIS

;THE ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	JSA	Q, DATAN2
;	EXP	A
;	EXP	B
;DATAN(A/B) IS RETURNED AS A DOUBLE PRECISION ANSWER IN ACCUMULATORS
;A AND B.

	SEARCH	FORPRM

;CONSTANTS AND TEMPORARY LOCATIONS AND STUFF

DARG:	BLOCK 2			;ARGUMENT FOR DATAN


PIOT:	DOUBLE 201622077325,021026430215	;+PI/2

PI.:	DOUBLE 202622077325,021026430215	;DEC=3.14159265358979323846


	HELLO	(DATN2.,DATAN2)	;[235] ENTRY TO DATAN2 ROUTINE
	DMOVE	A,@(Q)		;PICK UP 1ST ARG

	DFDV	A,@1(Q)		;CALCULATE A/B
	JFCL	AXIS 		;TRANSFER FOR OVER/UNDER FLOW
	DMOVEM	A,DARG			;STORE ARG FOR DATAN
	FUNCT	DATAN.,<DARG>	;CALCULATE DATAN(A/B)
	SKIPL	@1(Q)		;WAS 2ND ARGUMENT POSITIVE?
	GOODBY	(2)		;YES, 1ST OR 4TH QUAD, EXIT
				;NO, 2ND OR 3RD
	SKIPGE	@(Q)		;2ND QUADRANT?
	DFN	A,B		;NO, 3RD. SUBTRACT PI

	FLADD A,PI.

	SKIPGE	@(Q)		;3RD OR 4TH QUADRANTS?
	DFN	A,B		;YES, NEGATE FINAL ANSWER
	GOODBY	(2)		;EXIT

AXIS:
	JUMPN	A,OVER		;GO TO OVER IF OVERFLOW.
	SKIPL	@1(Q)		;ANS UNDERFLOWS IF Y/X UNDERFLOWS
	JRST	UNDMSG		;AND IF X >= 0.
	DMOVE	A,PI.		;O'E, ANS = +-PI, SO
	JRST	SETSGN		;GO TO SET SIGN.
OVER:	SKIPN	@(Q)		;WAS Y =0 ?
	FDVR	0,@(Q)		;YES, THIS IS 0/0 , FORCE A DIV CHK MSG.
	DMOVE	A,PIOT		;ANS = +-PI/2.
SETSGN:	SKIPGE	@(Q)		;ANS > 0 IF Y > 0.
	DFN	A,B		;ANS < 0 IF Y > 0.
	GOODBY	(2)		;EXIT.

UNDMSG:	ERROR	(APR,7,1,.+1)	;RETURN UNDERFLOW
	SETZB	0,1		;AND ANS = 0
	GOODBY	(2)		;EXIT.




	PRGEND
$PAGE	DATAN.	 SINGLE ARGUMENT DOUBLE PRECISION ARC TANGENT

;THIS ROUTINE CALCULATES THE ACTANGENT OF A DOUBLE PRECISION
;ARGUMENT ACCORDING TO THE ALGORITHM

;DATAN(X) = LAMBDA*X/(Z+B0+A1/(Z+B1+A2/(Z+B2+A3/(Z+B3))))

;FOR X>1.0, THE IDENTITY
;			ATAN(X) = PI/2 - ATAN(1/X)
;IS USED. FOR 0.236<X<1.0, THE IDENTITY
;			ATAN(X) = ATAN(1/2) + ATAN(2X-1/X+2)
;IS USED.
;FOR X<SQRT(3)*2**-27, ATAN(X)=X IS USED

;THE ROUTINE HAS THE FOLLOWING CALLING SEQUENCE
;	JSA	Q, DATAN
;	EXP	ARG
;WHERE ARG IS THE ADDRESS OF THE HIGH ORDER PART OF THE DOUBLE
;PRECISION WORD. THE ANSWER IS RETURNED IN ACCUMULATORS A AND B.

	SEARCH	FORPRM

A=	0
B=	1
C=	2
D=	3
E=	4
F=	5
G=	6	;FLAG REGISTER
	;BIT35=1, ADD ATAN(1/2) TO ANSWER
	;BIT34=1, ADD 2*ATAN(1/2) TO ANSWER	;[513]
	;BIT17=1,ADD -PI/2 TO ANSWER		;[513]
	;BIT0=1, NEGATE FINAL ANSWER

H=	7		;LOOP POINTER

Q=	16
P=	17

X=	H		;NUMBER OF ACCUMULATORS TO SAVE

;CONSTANTS AND TEMPORARY LOCATIONS AND STUFF

LAMBDA:	DOUBLE 204613772770,017027645561	;12.37469 38775 51020 40816
B0:	DOUBLE 205644272446,121335250615	;26.27277 52490 26980 67155
A1:	DOUBLE 570276502107,437176661671	;-80.34270 56102 16599 70467
B1:	DOUBLE 203627237361,165414142742	;6.36424 16870 04411 34492
A2:	DOUBLE 576316772502,512470127251	;-1.19144 72238 50426 48905
B2:	DOUBLE 202415301602,015271031674	;2.10451 89515 40978 95180
A3:	DOUBLE 602277106546,717167531241	;-0.07833 54278 56532 11777
B3:	DOUBLE 201502125320,370207664057	;1.25846 41124 27629 031727

ATANH:	DOUBLE 177732614701,130335517321	;ATAN(1/2)

MONE:	EXP -1.0,0
TWO:	EXP +2.0,0
MPIOT:	DOUBLE 576155700452,756751347563	;-PI/2

SMALL:	XWD 146673,317272		;SQRT(3)*2**-27

XBLT:	XWD	C, ACSAVE
ACSAVE:	BLOCK	X-C+1
DX:	BLOCK 2		;HOLDS X MOST OF THE TIME
X2:	BLOCK 2		;HOLDS X**2

	HELLO	(DATAN,.)	;[235] ENTRY TO DATAN ROUTINE
	MOVE	0,XBLT		;SAVE ACCUMULATORS
	BLT	0,ACSAVE+X-C	;...

	DMOVE	A,@(Q)		;GET ARGUMENT
	JUMPE	A,DATAN6	;ARG .E. 0?
	HLLZ	G, A		;LH(G)=SGN(A), RH(G) = 0
;**;[513] INSERT @ DATAN.+7L	JNG	15-DEC-75
	TLZ	G,377777	;[513] ZAP ALL BUT SIGN FOR FLAGS
	SKIPGE	A		;IS THE ARGUMENT POSITIVE?
	DFN	A, B		;NO,NEGATE IT
	MOVSI	D, (1.0)	;GET DOUBLE PRECISION 1.0
	MOVEI	E,0		;0 LO PART
	CAMN	A,D		;IS HIGH ORDER EQUAL TO 1.0?
	SKIPE	B		;YES, IS LOW ORDER ZERO?
	CAMGE	A,D		;NO, IS ARG>1.0?
	JRST	DATAN0		;NO
	TLC	G,(1B0)		;COMPLEMENT FINAL SIGN BIT, GET 1/X
;**;[513] CHANGE @ DATAN.+17L	JNG	15-DEC-75
	TLO	G,1		;[513] ADD -PI/2 TO FINAL ANSWER
	FLDIV	D,A
	DMOVEM	D,A

DATAN0:	DMOVEM	A,DX
	CAMGE	A,[0.236]	;IS ARG .GE. (SQRT(5)-2)?
	JRST	DATAN1		;NO, PROCEED WITH ALGORITHM
				;CALCULATE X+2
	FLADD	A,TWO
	EXCH	A,DX		;GET X, SAVE X+2
	EXCH	B,DX+1		;...
	FSC	A,1		;CALCULATE 2X
	IFE CPU-KA10,<FSC	B,1		;...
	FADL	A,B >		;...
				;CALCULATE 2X-1
	FLADD	A,MONE
				;(2X-1)/(X+2) WITH RESULTS IN A,B
	FLDIV	A,DX
;**;[513] REPLACE @ DATAN0+14L	JNG	15-DEC-75
	AOJA	G,DATAN0	;[513] TRY AGAIN IN CASE STILL TOO BIG

DATAN1:	MOVM	D,A		;GET MOD(X)
	CAMGE	D,SMALL		;CAN ATAN(X)=X?
	JRST	DATAN3		;YES
			;CALCULATE X**2
	FLMUL A,DX
	DMOVEM A,X2
				;INIT CONTINUED FRACTION COMP. WITH B3
	DMOVE A,B3

	MOVEI	H,B3		;INIT POINTER TO NUMBER TABLE
	JRST	DAT2		;DIVE INTO LOOP

DAT1:				;ADD B1
	FLADD A,0(H)

DAT2:				;ADD X**2
	FLADD A,X2
				;GET A3 (OR A1)
	DMOVE D,-2(H)
	FLDIV D,A
				;ADD B2 (OR B0)
	FLADD D,-4(H)
				;ADD X**2
	FLADD D,X2
				;GET A2 (OR LAMBDA)
	DMOVE A,-6(H)
	FLDIV A,D

	SUBI	H,8		;DECREMENT TABLE POINTER
	CAILE	H,LAMBDA	;FINISHED?
	JRST	DAT1		;NO, DO IT LAST TIME
				;MULTIPLY BY X
	FLMUL A,DX

DATAN3:
;**;[513] CHANGE @ DATAN3+1L	JNG	15-DEC-75
DATAN5:
	TRNN	G,-1		;[513] NEED TO ADD ATAN(1/2)?
	JRST	DATAN7			;[513] NO, PROCEED
	DFAD	A,ATANH
	SOJA	G,DATAN5		;[513] MAKE SURE ALL DONE
DATAN7:	TLNE	G,1		;[513] NEED TO ADD -PI/2?
	DFAD	A,MPIOT 
	SKIPGE	G		;NEGATE RESULT?
	DFN	A,B		;YES
DATAN6:	MOVS	X,XBLT		;RESTORE ACCUMULATORS
	BLT	X,X		;...
	GOODBY	(1)		;EXIT



	END
  @ 4