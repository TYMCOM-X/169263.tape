	TITLE	QUICKF	QUICK FIT ALLOCATION

	SEARCH	PASSYM

	$RELOC

	DEBUG=	0
;
;     ENTRY POINTS
;
	ENTRY	NEW.
	ENTRY	DSPOS.
	ENTRY	MARK.
	ENTRY	RLEAS.
;
;     TTY BREAK
;
	EXTERN	TWAIT.,DIE.,WRTPC.
;
;     HEAP HEADER
;
	LHEAP=	0		; PTR TO LAST HEAP
	TAIL=	1		; PTR TO WORD PAST END OF HEAP
	FLIST=	2		; PTR (0:ERSIZE+1) TO FREE LIST CHAINS
	ERSIZE=	20		; EXACT RANGE SIZE
	HSIZE=	FLIST+ERSIZE+2	; TOTAL HEADER SIZE
;
;     STORAGE PARAMETERS
;
	SMALL=	1		; DON'T SPLIT LEAVING REMNANTS OF THIS SIZE
	MINSZ=	2		; LIMITS OF EXACT RANGE
	MAXSZ=	MINSZ+ERSIZE-1
	MXTCNT=	4		; NUMBER OF TAIL EXTENSIONS BEFORE COLLAPSE
;
;     BLOCK FORMAT
;
	ASIZE=	0		; BLOCK IN USE, NEG. CNT IN FIRST WORD
	FSIZE=	1		; FREE BLOCK, CNT IN SECOND WORD
				; SIZES INCLUDE HEADER WORD
	FPREV=	0		; TO LAST BLOCK ON CHAIN (LEFT HW)
				;   OR FLIST(SLOT) IF FIRST
	FNEXT=	0		; TO NEXT BLOCK ON CHAIN (RIGHT HW)
;
;     REGISTER ASSIGNMENTS
;
	REGIN=	1
	HEAP=	REGIN+1+1	; PTR TO HEAP IN USE
	CNT=	REGIN+1		; SIZE TO BE ALLOCATED
	SLOT=	REGIN+1+2	; SLOT INDEX IN FLIST FOR BLOCK
	BLK=	1		; PTR TO BLOCK TO BE FREED
	T=	REGIN+1+3	; TEMPS
	R=	REGIN+1+4	; MUST BE T+1
	NB=	REGIN+1+5	; PTR TO NEXT BLOCK IN COLLAPSE
	RES=	REGIN+1+5	; PTR TO AREA RETURNED
	HP=	REGIN+1		; HEAP PTR FOR MARK AND RELEASE

	$LOW
;
;     REQUIRED STORAGE
;
CHEAP:	EXP	0		; PTR TO CURRENT HEAP
PASS:	EXP	0		; ALLOCATION ATTEMPTS (NO. COLLAPSES)
TCNT:	EXP	-MXTCNT		; COUNT OF TAIL EXTENSIONS DONE (NEG.)

	$HIGH
;
;     INITIALIZATION:  GET SPACE IN WHICH TO PUT INITIAL PORTION
;     OF HEAP. INITIALIZE NEW HEAP.
;
INIT:	HLRZ	HEAP,.JBSA##	; GET PTR TO START OF LOW FREE
	PUSHJ	TOPP,NEWHP	; INITIALIZE HEAP
	POPJ	TOPP,		; INITIALIZATION DONE
;
;     SUBROUTINE TO INITIALIZE A NEW HEAP HEADER.  ENTERED
;     WITH HEAP POINTING TO THE NEW HEAP AND CHEAP TO
;     THE LAST HEAP. MAKES SURE THERE IS SPACE FOR HEAP.
;
NEWHP:	MOVEI	T,1K(HEAP)	; MAKE SURE THERE IS A K FOR NEW HEAP
	CORE	T,		; TRY ALLOCATION
	JRST	FAIL		; TOO LITTLE CORE
	MOVEI	T,@CHEAP	; GET POINTER TO LAST HEAP
	MOVEM	T,LHEAP(HEAP)
	MOVEI	T,HSIZE(HEAP);	; GET POINTER TO FIRST FREE WORD
	MOVEM	T,TAIL(HEAP);
	MOVSI	T,-ERSIZE-2	; FAST LOOP TO ZERO FREE LIST
	HRRI	T,(HEAP)	; BUILD CONTROL WORD
	SETZM	FLIST(T)	; ZERO IT
	AOBJN	T,.-1
	MOVEM	HEAP,CHEAP	; UPDATE CURRENT HEAP PTR
	POPJ	TOPP,		; RETURN
;
;     SUBROUTINE TO CALCULATE THE SLOT THAT BLOCK BELONGS IN.
;     ENTERED WITH SIZE LOADED IN CNT, AND RETURNS WITH SLOT
;     INDEX IN SLOT.
;
CSLOT:	CAIGE	CNT,MINSZ	; CHECK IF BELOW EXACT RANGE
	JRST	CSLOW
	CAILE	CNT,MAXSZ	; CHECK IF ABOVE
	JRST	CSHIGH
	MOVEI	SLOT,1-MINSZ(CNT)  ;COMPUTE SLOT NUMBER
	POPJ	TOPP,
CSLOW:	SETZM	SLOT		; BELOW, SLOT = 0
	POPJ	TOPP,
CSHIGH:	MOVEI	SLOT,ERSIZE+1	; ABOVE
	POPJ	TOPP,
;
;     NEW -- ALLOCATE STORAGE OF CNT WORDS
;
NEW.:	MOVEI	HEAP,@CHEAP	; GET PTR TO CURRENT HEAP
	CAIN	HEAP,0		; INIT, IF HAVE NOT ALREADY DONE SO
	PUSHJ	TOPP,INIT
	ADDI	CNT,1		; ONE WORD FOR BLOCK DESCRIPTOR WROD
	IFN	DEBUG	<PUSHJ TOPP,TELCNT>
	SETOM	PASS		; FLAG NO OF COLLAPSES
	PUSHJ	TOPP,CSLOT	; CALC SLOT INDEX FOR BLOCK
	JUMPE	SLOT,BELOW	; SLOT 0 - BELOW RANGE
	CAILE	SLOT,ERSIZE	; SKIP IF IN EXACT RANGE
	JRST	ABOVE
;
;     REQUESTED ALLOCATION IS IN EXACT RANGE.  FIRST TRY TO FIND
;     A BLOCK OF THE REQUIRED SIZE.  ONE EXISTS IF THE FREE LIST
;     FOR THAT SIZE IS NON NULL.  IF THERE IS NOT SUCH BLOCK
;     THEN CONTINUE TO ATTEMPT ALLOCATIONS BY OTHER METHODS, BELOW.
;
EXACT:	MOVEI	T,FLIST(HEAP)	; GET ADDRESS OF FREELIST SLOT TO LOOK AT
	ADD	T,SLOT
	MOVEI	RES,@0(T)	; LOAD PTR TO FIRST SLOT
	JUMPE	RES,ESRCH	; IF ZERO, LIST IS NULL, TRY OTHER METHOOS

	HRRZ	R,FNEXT(RES)	; GET PTR TO NEXT ON LIST
	MOVEM	R,0(T)		; UNCHAIN BLOCK, SET FLIST TO NEXT
	HRLM	T,FPREV(R)	; NEXT.PREV = FLIST(SLOT)
	MOVNM	CNT,ASIZE(RES)	; FLAG BLOCK AS IN USE
	JRST	.+2		; NO NEED TO UNWIND STACK

DONE:	POP	TOPP,T		; UNWIND CALL STACK
	MOVEI	REGIN+1,2(7)	; PREPARE FOR BLK TO ZERO AREA
	HRLI	2,1(7)
	SETZM	1(7)		; WILL PROPAGATE ZERO
	MOVEI	3,-1(7)
	SUB	3,0(7)		; NOW ADDRESS OF LAST WORD IN AREA
	BLT	2,0(3)
	MOVEI	REGIN+1,1(RES)	; ADVANCE TO POINT TO DATA AREA
	IFN	DEBUG	<MOVEI  BLK,-1(REGIN+1)
			 PUSHJ TOPP,TELBLK>
	POPJ	TOPP,		; RETURN FROM NEW
;
;     REST OF EXACT RANGE SIZE METHODS.  TRY EACH IN TURN. IF THEY
;     FAIL, THEY WILL RETURN; OTHERWISE, THEY JUMP TO DONE.
;
ESRCH:	PUSHJ	TOPP,TAILA	; ALLOCATE OFF THE TAIL
	PUSHJ	TOPP,SPLIT	; TRY SPLITING BIGGER EXACT RANGE BLOCKS
	PUSHJ	TOPP,GROWT	; CALL MONITOR TO EXTEND TAIL
	PUSHJ	TOPP,MISCA	; TRY SPLITTING BLOCKS ABOVE RANGE
	AOSE	PASS		; IF FIRST PASS, TRY COLLAPSE
	JRST	FAIL		; IF SECOND, GIVE UP
	PUSHJ	TOPP,COLLPS
	JRST	EXACT

FAIL:	PUSHJ	TOPP,	TWAIT.	; DUMP TTY BUFFER BEFORE ERROR MSG.
	OUTSTR	[ASCIZ/
?	HEAP overflow. Try again with more core/]
ABORT:	MOVE	AC0,0(TOPP)	; GET CALLER'S ADDRESS
	PUSHJ	TOPP,WRTPC.	; AND PRINT IT
	JRST	DIE.
;
;     ALLOCATE A BLOCK BELOW THE EXACT RANGE.  TRY FINDING A BLOCK
;     IN SLOT 0, THEN GETTING SOMETHING FROM THE TAIL, THEN SPLITING
;     EXACT RANGE AND LARGER BLOCKS.
;
BELOW:	PUSHJ	TOPP,MISCB	; SEARCH SMALL BLOCKS
	PUSHJ	TOPP,TAILA	; GET FROM TAIL
	PUSHJ	TOPP,SPLIT	; SPLIT ER BLOCKS
	PUSHJ	TOPP,GROWT	; EXTEND TAIL
	PUSHJ	TOPP,MISCA	; TRY BIG BLOCKS
	AOSE	PASS		; TRY COLLAPSE IF FIRST PASS
	JRST	FAIL
	PUSHJ	TOPP,COLLPS
	JRST	BELOW
;
;     ALLOCATE A BLOCK ABOVE THE EXACT RANGE.  SEE IF THERE IS ONE
;     ON THE SLOT (ERSIZE+1) LIST, OTHERWISE TRY THE TAIL.
;
ABOVE:	PUSHJ	TOPP,MISCA
	PUSHJ	TOPP,TAILA
	PUSHJ	TOPP,GROWT
	AOSE	PASS		; TRY COLLAPSE IF FIRST PASS
	JRST	FAIL
	PUSHJ	TOPP,COLLPS
	JRST	ABOVE

;
;     SUBROUTINE TO ALLOCATE FROM TAIL.  CHECK IF DESIRED BLOCK SIZE
;     STAYS WITHIN ALLOCATED LOW SEGMENT SIZE.
;
TAILA:	MOVEI	RES,@TAIL(HEAP)	; GET PTR TO TAIL
	MOVE	T,RES		; SET T TO NEW TAIL PR
	ADD	T,CNT
	CAMLE	T,.JBREL##	; CHECK IF EXCEEDS LOW SEG SIZE
	POPJ	TOPP,		; TOO BIG, RETURN
	MOVEM	T,TAIL(HEAP)	; OKAY, UPDATE TAIL PTR
	MOVNM	CNT,ASIZE(RES)	; MARK BLOCK AS ALLOCATED
	JRST	DONE
;
;     SUBROUTINE TO GROW TAIL.  CHECKS IF GROWTH WOULD EXCEED MAX
;     CORE AVAILABLE TO USER; IF OKAY, EXTENDS LOW SEGMENT.
;
GROWT:	AOSLE	TCNT		; ALLOW COLLAPSE EVERY MXCNT TIMES
	JRST	NOGROW
	MOVEI	RES,@TAIL(HEAP)	; GET PTR TO TAIL
	MOVE	T,RES		; SET T TO NEW END
	ADD	T,CNT
	MOVE	R,T		; REMEMBER NEW TAIL
	HRRZM	T,.JBFF##	;SAVE NEW TOP OF THE WORLD
	CORE	T,		; TRY TO EXTEND
SPLTFL:	POPJ	TOPP,		; EXTEDNING FAILS
	MOVEM	R,TAIL(HEAP)	; ADVANCE TAIL PTR
	MOVNM	CNT,ASIZE(RES)	; MARK BLOCK AS ALLOCATED
	JRST	DONE

NOGROW:	MOVNI	T,MXTCNT	; RESET COUNTER
	MOVEM	T,TCNT
	POPJ	TOPP,		; RETURN HAVING DONE NOTHING
;
;     SUBROUTINE TO SPLIT EXACT RANGE BLOCKS.  SEARCHES LIST IN SLOTS FOR
;     SIZES GREATER THAN THAT REQUIRED.  IF A BLOCK IS FOUND, IT IS
;     SPLIT AND THE REMAINDER FREED.
;
SPLIT:	MOVNI	T,ERSIZE	; BUILD SEARCH CONTROL WORD
	ADD	T,SLOT		; LEFT: - (ERSIZE - (SLOT+1) + 1)
	HRLZI	T,0(T)		; MOVE TO LEFT HALF
	HRRI	T,0(HEAP)	; RIGHT: SLOT(HEAP)
	ADD	T,SLOT
	AOBJP	T,SPLTFL	; RETURN IF END OF SEARCH
	MOVEI	RES,@FLIST(T)	; GET FREE LIST PTR
	JUMPE	RES,.-2		; EXIT IF NONNULL LIST FOUND

SPLTDO:	MOVE	BLK,RES		; UNCHAIN THE BLOCK
	PUSHJ	TOPP,UNCHN

	MOVE	R,FSIZE(RES)	; GET SIZE OF BLOCK FOUND
	SUB	R,CNT		; SEE IF REM TOO SMALL
	CAILE	R,SMALL
	JRST	SPLTOK		; LEFT OVER WEENABLE

	MOVE	R,FSIZE(RES)	; LEFT OVER TOO SMALL
	MOVNM	R,ASIZE(RES)	; MARK AS ALLOCATED WITH UNSPLIT COUNT
	JRST	DONE

SPLTOK:	MOVNM	CNT,ASIZE(RES)	; MARK AS ALLOCATED WITH SPLIT COUNT
	MOVEI	BLK,0(RES)	; SET T TO PORTION TO BE SPLIT
	ADD	BLK,CNT

	MOVE	CNT,R		; GET SIZE OF SPLIT BLOCK
	PUSHJ	TOPP,FREE	; FREE IT
	JRST	DONE
;
;     SUBROUTINES TO SEARCH SLOT(0) AND SLOT(ERSIZE+1) LISTS FOR
;     BLOCK LARGE ENOUGH TO HOLD CNT WORDS.  IF FOUND, REMAINDER
;     IS SPLIT OFF AND FREED.
;
MISCA:	MOVEI	RES,FLIST+ERSIZE+1(HEAP)   ; PTR TO FREELIST SLOT TO SEARCH
	JRST	.+2
MISCB:	MOVEI	RES,FLIST+0(HEAP)	; SLOT(0) SEARCH

MSRCH:	HRRZ	RES,FNEXT(RES)	; ADVANCE TO NEXT SLOT
	JUMPN	RES,.+2		; IF ONE EXSISTS
	POPJ	TOPP,
	CAMG	CNT,FSIZE(RES)	; SEE IF BLOCK LARGE ENOUGH
	JRST	SPLTDO
	JRST	MSRCH		; CONTINUE WITH NEXT
;
;     SUBROUTINE TO COLLAPSE ADJACENT BLOCKS OF FREE STORAGE. IN CODE
;     BLK POINTS TO CURRENT BLOCK, NB TO NEXT BLOCK.
;
COLLPS:	PUSH	TOPP,CNT	; SAVE CNT OF BLOCK BEING ALLOCATED
	PUSH	TOPP,SLOT	; AND SLOT NUMBER
	MOVEI	NB,HSIZE(HEAP)	; GET PTR TO FIRST BLOCK
CLLOOP:	MOVE	BLK,NB		; MOVE TO NEXT BLOCK
	CAML	BLK,TAIL(HEAP)	; SEE IF BLOCK IS OUT OF RANGE
	JRST	CLRET		; ALL DONE
	MOVN	CNT,ASIZE(BLK)	; IF SIZE NEG, THEN BLOCK FREE
	JUMPL	CNT,CLFREE	; BLK IS FREE, TRY TO COLLAPSE
	ADD	NB,CNT		; GET ADDRESS OF NEXT BLOCK
	JRST	CLLOOP

				; HERE, NB EQUALS BLK
CLFREE:	ADD	NB,FSIZE(BLK)	; GET ADDRESS OF NEXT
	CAML	NB,TAIL(HEAP)	; SEE IF NEXT IS REALLY END
	JRST	CLTAIL
	MOVN	R,ASIZE(NB)	; TEST IF NEXT IS FREE
	JUMPGE	R,CLLOOP	; IN USE, CONTINUE

	PUSHJ	TOPP,UNCHN	; UNCHAIN BLK
	MOVE	CNT,FSIZE(BLK)	; GET SIZE OF COMBINED BLOCK
	ADD	CNT,FSIZE(NB)
	PUSHJ	TOPP,FREE	; ADD CREATED BLOCK TO CHAIN
	EXCH	BLK,NB		; UNCHAIN SECOND PART
	PUSHJ	TOPP,UNCHN
	MOVE	BLK,NB		; RESTORE BLK POINTER
	JRST	CLFREE

CLTAIL:	PUSHJ	TOPP,UNCHN	; REMOVE THE BLK
	MOVEM	BLK,TAIL(HEAP)	; RESET THE TAIL POINTER
CLRET:	POP	TOPP,SLOT	; RESTORE SLOT NO. OF BLOCK BEING ALLOC'ED
	POP	TOPP,CNT	; AND CNT
	POPJ	TOPP,

;
;     SUBROUTINE TO UNCHAIN A BLOCK, ENTERED WITH BLK POINTING
;     TO BLOCK TO UNCHAIN
;
UNCHN:	HLRZ	T,FPREV(BLK)	; GET PTR TO PREVIOUS BLOCK
	HRRZ	R,FNEXT(BLK)	; GET PTR TO NEXT BLOCK
	JUMPE	R,.+2		; IF NEXT NONNULL, SET NEXT.PREV = BLK.PREV
	HRLM	T,FPREV(R)
	HRRM	R,FNEXT(T)	; FLIST (SLOT) OR PREV.NEXT = BLK.NEXT
	POPJ	TOPP,
;
;     DISPOSE -- OPERATOR TO FREE AN ALLOCATED BLOCK.  CHECKS THAT
;     BLOCK IS IN FACT ALLOCATED AND THAT BLOCK IS IN RANGE.
;     RETURNS A NIL PTR FOR NIL'ING PTR VAR DISPOSED.
;
DSPOS.:	MOVEI	BLK,-1(REGIN+1)	; POINT AT BLOCK DESC WORD
	IFN	DEBUG	<PUSHJ TOPP,TELBLK>
	MOVEI	HEAP,@CHEAP	; GET PTR TO HEAP
	JUMPE	HEAP,DISERR	; IF NOT INIT'ED, PTR MUST BE BAD
	CAML	BLK,TAIL(HEAP)	; CHECK THAT PTR IS NOT PAST END OF HEAP
	JRST	DISERR
DISCHK:	CAIGE	BLK,HSIZE(HEAP)	; CHECK IF BLK IN THIS HEAP
	JRST	DISPOP		; NO, CHECK FOR PREVIOUS
	MOVN	CNT,ASIZE(BLK)	; MOVE NEG. ALLOCATED COUNT
	JUMPL	CNT,EFALLOC	; IF THIS IS NEG., BLOCK WAS FREE
	PUSHJ	TOPP,FREE
	MOVEI	BLK,377777	; LOAD NIL PTR, TO BE STORED INTO PTR
	POPJ	TOPP,

DISPOP:	CAIL	BLK,0(HEAP)	; MAKE SURE NOT IN HEADER
	JRST	DISERR
	MOVEI	HEAP,@LHEAP(HEAP)	; CHECK PREVIOUS FRAME
	JUMPN	HEAP,DISCHK
DISERR:	PUSHJ	TOPP,	TWAIT.	; BREAK ON TTYOUTPUT FIRST
	OUTSTR	[ASCIZ/
?	Bad pointer in DISPOSE/]
	JRST	ABORT

EFALLOC:PUSHJ	TOPP,	TWAIT.	; BREAK ON TTYOUTPUT FIRST
	OUTSTR	[ASCIZ/
?	Attempt to free freed block/]
	JRST	ABORT
;
;     SUBROUTINE TO FREE A BLOCK.  ENTERED WITH BLK POINTING
;     TO BLOCK DESC WORD, AND SIZE IN CNT.
;
FREE:	PUSHJ	TOPP,CSLOT	; GET SLOT INDEX FOR THIS SIZE BLOCK
	MOVEI	T,FLIST(HEAP)	; SET T TO POINT AT FLIST SLOT
	ADD	T,SLOT
	MOVEI	R,@0(T)		; SET R TO ADDR OF FIRST FREE
	MOVEM	CNT,FSIZE(BLK)	; SAVE SIZE OF BLOCK
	HRRZM	R,FNEXT(BLK)	; BLK.NEXT = FLIST(SLOT)
	HRLM	T,FPREV(BLK)	; BLK.PREV = ADDR (FLIST (SLOT))
	JUMPE	R,.+2		; SKIP IF THERE IS NO NEXT
	HRLM	BLK,FPREV(R)	; NEXT.PREV = BLK
	MOVEM	BLK,0(T)	; SET SLOT TO POINT TO THIS BLOCK
	POPJ	TOPP,

;
;     MARK -- OPERATOR TO PUSH A HEAP FRAME.  INITIALIZES A NEW HEAP
;     HEADER AND UPDATES CURRENT HEAP PTR.
;
MARK.:	MOVEI	HEAP,@CHEAP	; RESTORE PTR TO CURRENT FRAME
	CAIN	HEAP,0		; IF NOT INIT'ED, GET VALID OLD HEAP
	PUSHJ	TOPP,INIT
	MOVEM	HEAP,HP		; SAVE PTR TO OLD (CURRENT) HEAP
	IFN	DEBUG	<PUSHJ TOPP,TELMAR>
	MOVEI	HEAP,@TAIL(HEAP)	; PUT NEW (NEXT) FRAME AT TAIL OF OLD
	PUSHJ	TOPP,NEWHP	; INITIALIZE
	POPJ	TOPP,
;
;     RELEASE -- OPERATOR TO POP HEAP FRAMES.  TAKES SUPPLIED HEAP
;     POINTER AND CHECKS THAT IT IS VALID.  THEN RESETS CURRENT
;     HEAP POINTER TO THAT HEAP.  MORE THAN ONE HEAP CAN BE UNWOUND.
;
RLEAS.:	MOVEI	HEAP,@CHEAP	; BACKWARDS SEARCH FOR CORRECT HEAP
	JUMPE	HEAP,RLBAD	; IF NOT INIT'ED, NO MARKS DONE
	IFN	DEBUG	<PUSHJ TOPP,TELREL>
	CAMN	HP,HEAP		; CHECK IF THE SAME AS SUPPLIED
	JRST	RLOK		; HEAP FOUND
	MOVEI	HEAP,@LHEAP(HEAP)	; CHECK PREVIOUS ONE
	JUMPN	HEAP,.-3	; TRY AGAIN
RLBAD:	PUSHJ	TOPP,	TWAIT.	; BREAK ON TTYOUTPUT FIRST
	OUTSTR	[ASCIZ/
?	Invalid HEAP pointer in RELEASE/]
	JRST	ABORT
RLOK:	MOVEM	HP,CHEAP	; UPDATE CURRENT POINTER
	POPJ	TOPP,

;
;     DEBUGGING OUTPUT ROUTINES
;
	IFN	DEBUG	<
TELCNT:	MOVE	R,CNT
	SETZ	T,
	JUMPE	R,TCLOOP
	ROTC	T,3		; REMOVE LEADING ZEROS
	JUMPE	T,.-1
TCLOOP:	ANDI	T,7
	ADDI	T,060
	OUTCHR	T
	JUMPE	R,TELRET	; END OF NUMBER
	ROTC	T,3		; GET NEXT OCTAL DIGIT
	JRST	TCLOOP

TELBLK:	OUTSTR	[ASCIZ/@/]
	MOVEI	T,6		; LOOP COUNT
	MOVSS	BLK		; ADDR IN RIGHT HALF
TBLOOP:	ROT	BLK,3		; PUT NEXT OCTAL DIGIT IN BITS 33-35
	MOVE	R,BLK		; TAKE CHAR(BLK)
	ANDI	R,7
	ADDI	R,060
	OUTCHR	R
	SOJG	T,TBLOOP
	OUTSTR	[ASCIZ/	/]	; TAB
TELRET:	POPJ	TOPP,

TELREL:	OUTSTR	[ASCIZ/R/]
	MOVE	BLK,HP
	PUSHJ	TOPP,TELBLK
	POPJ	TOPP,

TELMAR:	OUTSTR	[ASCIZ/M/]
	MOVE	BLK,HEAP
	PUSHJ	TOPP,TELBLK
	POPJ	TOPP,	>

	END
 