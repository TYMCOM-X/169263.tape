	TITLE	PRFID - FILE IDENTIFIER PARSER

;
;    PRFID. is a subroutine which parses a file name, and places the formated
;	information in a PASCAL file block. The parse permits individual fields
;	(e.g. file name or protection field) to appear in any order.  More than
;	one instance of a field may be entered. In which case the last is what
;	is used.  Thus to establish defaults, one may prefix them to the file
;	name regularly used.  The standard defaults are: device - DSK:, filename
;	and extension - '', and ppn and protection - 0 (system defaults used).
;	The calling sequence is:
;
;	  REG	is the pointer to the file block
;	  REG1	is a byte pointer, starts one char before string to parse
;	  REG2	is the length of the string
;
;	  The only other registers used are AC0, and AC1.
;
;	If the parse is successful, then PRFID. skips on return; otherwise
;	it returns with no skip.
;

	SEARCH	PASSYM

	A=	"A"-40			; SIXBIT EQUIVALENTS
	Z=	"Z"-40
	ZERO=	"0"-40
	SEVEN=	"7"-40
	NINE=	"9"-40
	POUND=  "#"-40
	COLON=	":"-40
	PERIOD=	"."-40
	LBRACK=	"["-40
	RBRACK=	"]"-40
	LCARET=	"<"-40
	RCARET=	">"-40
	LPAREN= "("-40
	RPAREN= ")"-40
	COMMA=	","-40
	BLANK=	0

	NAME=	1			; LOCAL STORAGE
	NUM=	3
	VALBP=	4
	CHAR=	5
	STKLEN=	5			; AGGREGATE TOTAL



	$RELOC
	$LOW
USERNAME:BLOCK	2
	$HIGH
	ENTRY	PRFID.
PRFID.:	MOVE	AC1,TOPP		; CREATE LOCAL STORAGE
	ADDI	TOPP,STKLEN

	MOVE	AC0,[SIXBIT/DSK   /]	; SET DEFAULTS
	MOVEM	AC0,FILDEV(REG)		; DEFAULT DEVICE IS DSK:
	SETZM	FILNAM(REG)		; NAME IS ALL BLANKS
	SETZM	FILEXT(REG)		; EXT IS ALL BLANKS
	SETZM	FILPRO(REG)		; USE DEFAULT PROTECTION
	SETZM	FILPPN(REG)		; USE DEFAULT PPN
	SETZM	USERNAME
	SETZM	USERNAME+1

CKLOOP:	PUSHJ	TOPP,NXTCHR		; GET NEXT CHAR AND CONTINUE

CKANY:	MOVE	AC0,CHAR(AC1)		; RESTORE CURRENT CHAR
	PUSHJ	TOPP,ALPNUM		; CHECK FOR ALPHANUMERIC
	JRST	CKDIR
	PUSHJ	TOPP,GETNAM
	CAIE	AC0,COLON		; IS IT DEVICE NAME
	JRST	HVFNM
	MOVE	AC0,NAME(AC1)		; GET NAME
	MOVEM	FILDEV(REG)		; SAVE IT
	JRST	CKLOOP			; LOOK FOR ANOTHER COMPONENT

HVFNM:	MOVE	AC0,NAME(AC1)		; SAVE FILENAME
	MOVEM	AC0,FILNAM(REG)
	JRST	CKANY

CKDIR:	CAIE	AC0,LPAREN		; (USERNAME)?
	JRST	CKEXT
	PUSHJ	TOPP,NXTCHR	;SKIP LEFT PAREN
	PUSHJ	TOPP,ALPNUM	;MUST BE ALPHANUMERIC
	JRST	PRFERR
	PUSHJ	TOPP,GETNAM
	CAIE	AC0,RPARENT
	JRST	PRFERR
	MOVE	AC0,NAME(AC1)
	MOVEM	AC0,USERNAME
	MOVE	AC0,NAME+1(AC1)
	MOVEM	AC0,USERNAME+1
	SETZM	FILPPN(REG)	;OVERRIDES PPN
	JRST	CKLOOP

CKEXT:	CAIE	AC0,PERIOD		; .EXT ??
	JRST	CKPPN
	PUSHJ	TOPP,NXTCHR		; GET NAME AFTER "."
	PUSHJ	TOPP,GETNAM
	MOVE	AC0,NAME(AC1)
	HLLM	AC0,FILEXT(REG)		; WANT ONLY 3 CHARS
	JRST	CKANY

CKPPN:	CAIE	AC0,LBRACK		; CHECK FOR DIRECTORY
	JRST	CKPRO
	GETPPN	AC0,			; IF WE HAVE A PARTIAL DIR, MUST FILL IN REST
	NOP				; DON'T CARE ABOUT ALTERNATE RETURN
	MOVEM	AC0,FILPPN(REG)
	PUSHJ	TOPP,NXTCHR		; LOOK FOR NUMBER 
	CAIN	AC0,COMMA		; PROGRAMMER NUMBER RIGHT OFF THE BAT
	JRST	GETPRG
	PUSHJ	TOPP,GETNUM
	MOVE	AC0,NUM(AC1)
	HRLM	AC0,FILPPN(REG)		; SAVE PROGRAMMER NUMBER 
	MOVE	AC0,CHAR(AC1)
GETPRG:	CAIE	AC0,COMMA		; LOOK FOR COMMA AFTER PROJ CODE
	JRST	PRFERR
	PUSHJ	TOPP,NXTCHR
	CAIN	AC0,RBRACK		; MAY HAVE "]" RIGHT OFF
	JRST	GETRB
	PUSHJ	TOPP,GETNUM
	MOVE	AC0,NUM(AC1)		; SAVE IT
	HRRM	AC0,FILPPN(REG)
	MOVE	AC0,CHAR(AC1)
GETRB:	CAIE	AC0,RBRACK		; LOOK FOR TERMINATING "]"
	JRST	PRFERR
	SETZM	USERNAME		;OVERRIDES USERNAME
	SETZM	USERNAME+1
	JRST	CKLOOP			; TRY FOR ANOTHER PART

CKPRO:	CAIE	AC0,LCARET		; PROTECTION IS <NNN>
	JRST	CKBLK
	PUSHJ	TOPP,NXTCHR		; GET PROTECTION CODE
	PUSHJ	TOPP,GETNUM
	MOVE	AC0,NUM(AC1)		; CHECK THAT IT IS IN RANGE
	AND	AC0,[XWD 777777,777000]	; ALLOW ONLY THREE DIGITS
	SKIPE	AC0
	JRST	PRFERR
	MOVE	AC0,NUM(AC1)		; SAVE IT
	LSH	AC0,33			; LEFT JUSTIFIED
	MOVEM	AC0,FILPRO(REG)
	MOVE	AC0,CHAR(AC1)		; CHECK FOR ">"
	CAIE	AC0,RCARET
	JRST	PRFERR
	JRST	CKLOOP

CKBLK:	CAIE	AC0,BLANK		; ONLY BLANK OR EOS ALLOWED NOW
	JRST	PRFERR
	JUMPG	REG2,CKLOOP		; BLANKS ARE IGNORED BETWEEN FIELDS
	MOVE	TOPP,AC1		; UNWIND STACK
	AOS	0(TOPP)			; RETURN SKIP
	HLRZ	AC1,FILEXT(REG)		; GET EXTENSION PARSED
	CAIE	AC1,'UFD'		; IF PASSED '.UFD' THEN SPECIAL ACTION
	JRST	TRYPPN
	MOVE	AC1,FILPPN(REG)		; PICK UP PARSED PPN
	MOVEM	AC1,FILNAM(REG)		;   AND MAKE IT THE FILE NAME (BINARY)
	MOVE	AC1,[1,,1]		; GET PPN SPEC FOR [1,1]
	MOVEM	AC1,FILPPN(REG)		;   AND PLACE AS PPN ON WHICH TO LOOKUP
	POPJ	TOPP,
TRYPPN:	SKIPG	AC1,FILPPN(REG)
	JRST	TRYUNM
	CAILE	AC1,777777
	POPJ	TOPP,
	GETPPN	AC1
	HLLM	AC1,FILPPN(REG)
	POPJ	TOPP,
TRYUNM:	SKIPN	USERNAME
	POPJ	TOPP,
	MOVEI	AC1,USERNAME
	MOVEM	AC1,FILPPN(REG)
	POPJ	TOPP,


;
;    NXTCHR returns the next character in the string (converted to SIXBIT)
;	in AC0 and in the temporary CHAR.
;

NXTCHR:	JUMPLE	REG2,EOS		; CHECK FOR END OF STRING
	SUBI	REG2,1			; GET NEXT CHAR
	ILDB	AC0,REG1
	CAIN	AC0,11			; REPLACE TAB BY BLANK
	MOVEI	AC0," "
	CAIL	AC0,"a"			; UPPERCASE IT
	CAILE	AC0,"z"
	SKIPA
	SUBI	AC0,"a"-"A"		; CONVERT TO UPPERCASE
	SUBI	AC0,40			; CONVERT TO SIXBIT
	ANDI	AC0,77
NXTRET:	MOVEM	AC0,CHAR(AC1)		; SAVE IT
	POPJ	TOPP,

EOS:	MOVEI	AC0,BLANK		; RETURN BLANK AT END OF STRING
	JRST	NXTRET


;
;    GETNAM extracts an alphanumeric string of any length and moves the
;	leading six characters into the temporary NAME. If there are
;	fewer, NAME is padded with blanks.  It is assumed that the
;	current character is alpha numeric when this is called.
;

GETNAM:	SETZM	NAME(AC1)		; START WITH ALL BLANKS
	SETZM	NAME+1(AC1)
	MOVE	AC0,[POINT 6,NAME(AC1)]	; GET BYTE PTR TO BUILD NAME
	MOVEM	AC0,VALBP(AC1)
	MOVEI	AC0,^D12			; COUNT OF STORED CHARS
	MOVEM	AC0,NUM(AC1)
	MOVE	AC0,CHAR(AC1)		; RESTORE 1ST CHAR

NMLP:	PUSHJ	TOPP,ALPNUM		; CONTINUE UNTIL WE RUN OUT OF ALPHAS
	POPJ	TOPP,
	SOSL	NUM(AC1)		; ONLY DEPOSIT SIX CHARS
	IDPB	AC0,VALBP(AC1)
	PUSHJ	TOPP,NXTCHR		; GET ANOTEHER
	JRST	NMLP


;
;    GETNUM extracts a number of up to six octal digits from the input
;	string, converts the value, and returns the result in the
;	temporary NUM. The current character is checked to see if it is
;	an octal digit when this is called.
;

GETNUM:	SETZM	NUM(AC1)		; ZERO NUMBER VALUE
	CAIL	AC0,ZERO		; FIRST CHAR MUST BE DIGIT
	CAILE	AC0,SEVEN
	JRST	PRFERR

NUMLP:	CAIL	AC0,ZERO		; CHECK FOR CURRENT CHAR BEING DIGIT
	CAILE	AC0,SEVEN
	POPJ	TOPP,			; IF NOT ALL DONE
	MOVE	AC0,NUM(AC1)		; NUM := NUM * 8 + CHAR - ORD ('0')
	LSH	AC0,3
	ADD	AC0,CHAR(AC1)
	SUBI	AC0,ZERO
	MOVEM	AC0,NUM(AC1)
	TLNE	AC0,-1			; TEST FOR OVERFLOW
	JRST	PRFERR
	PUSHJ	TOPP,NXTCHR		; GET ANOTHER CHARACTER
	JRST	NUMLP


;
;    ALPNUM  checks for alphanumeric characters, returns with no skip if false;
;	returns with a skip otherwise.
;

ALPNUM:	CAIE	AC0,POUND		; '#' OK
	CAIL	AC0,A			; CHECK FOR ALPHAS
	CAILE	AC0,Z
	JRST	CKNUM
ANTRUE:	AOS	0(TOPP)			; BUMP RETURN ADDRESS BY ONE
	POPJ	TOPP,

CKNUM:	CAIL	AC0,ZERO
	CAILE	AC0,NINE
	POPJ	TOPP,			; NOT NUMBER, RETURN FALSE
	JRST	ANTRUE


;
;    PRFERR - error return, no skip.
;

PRFERR:	MOVE	TOPP,AC1		; UNWIND STACK
	POPJ	TOPP,			; RETURN NO SKIP

	LIT
	END
