	TITLE	PRTXII	*** PASCAL RUNTIME EXPONENTIATION ROUTINES ***

 
	ENTRY EXPII.
 
	EXTERN XPRET.,XP0.,TWAIT.

	SEARCH	PASSYM

	$RELOC

	PAGE
; EXPII
;
;    CALCULATES I**J, BOTH INTEGERS
;    (AC1) = REGISTER CONTAINING I
;    (AC0) = REGISTER CONTAINING J
;    I IS REPLACED BY RESULT
;
;    RETURN:	0 IF I<>0 AND J<1
;		1 IF I=0  AND J<1
;
EXPII.:	JFCL	17,	.+1		; CLEAR FLAGS
	PUSH	TOPP,	AC1		; SAVE REGISTER # OF I
	PUSH	TOPP,	AC0		; SAVE REGISTER # OF J
	MOVE	AC0,	(AC1)		; GET I 
	MOVE	AC1,	@(TOPP)		; GET J
	MOVEM	AC0,	(TOPP)		; SAVE I
	JUMPG	AC1,	EXPII3		; CAN EXPONENTIATE IF J>0
	JUMPN	AC0,	EXPII1		; CONTINUE CHECK IF I<>0
	PUSHJ	TOPP,	TWAIT.		; DUMP TTY BUFFER BEFORE ERROR MSG.
	OUTSTR		XP0.		; ERROR:  0**(J<1) 
	JRST		EXPII2		; GET DEFAULT VALUE
EXPII1:	CLEAR	AC0			; RETURN 0 IF J<0
	JUMPL	AC1,	EXPII4
EXPII2:	MOVEI	AC0,	1		; OR 1 IF J=0
	JRST		EXPII4
EXPII3:	SOJE	AC1,	EXPII4		; ITERATE MULTIPLICATION
	IMUL	AC0,	(TOPP)		;   (J-1) TIMES
	JRST		EXPII3
EXPII4:	POP	TOPP,	AC1		; CLEAR I FROM STACK
	POP	TOPP,	AC1		; RETRIEVE REG # OF I
	JRST		XPRET.		; CHECK OVERFLOW AND RETURN
	PRGEND
	TITLE	DEXPRI  *** PASCAL DOUBLE PRECISION EXPONENTIATION ***

	SEARCH	PASSYM

	ENTRY	DXPRI.

	EXTERN	DXP0.,F1.0,TWAIT.,DXRET.

	$RELOC

;
; DXPRI
;
;	CALCULATES X**J, X : DOUBLE PRECISION REAL, J : INTEGER
;	(AC1) = REGISTER CONTAINING FIRST WORD OF X
;	(AC0) = REGISTER CONTAINING J
;	X REPLACED BY RESULT
;
;	RETURN:	    1.0 IF X=0.0 AND J<1
;
DXPRI.:	PUSH	TOPP,AC0	; SAVE REGISTER OF X
	PUSH	TOPP,AC1	; SAVE REGISTER OF X
	SKIPLE	@-1(TOPP)
	JRST	OK
	SKIPE	0(AC1)
	JRST	CHECKJ
	PUSHJ	TOPP,TWAIT.	; ERROR IF X=0 AND J<=0
	OUTSTR	DXP0.
	DMOVE	AC0,F1.0	; ERROR RETURN IS 1.0
	JRST	DXRET.
CHECKJ:	SKIPL	@-1(TOPP)
	JRST	OK
	MOVNS	@-1(TOPP)	; IF J NEGATIVE, ABSOLUTE EXPONENT AND
	DMOVE	AC0,F1.0	;   INVERT X
	DFDV	AC0,@0(TOPP)
	DMOVEM	AC0,@0(TOPP)
OK:	DMOVE	AC0,@0(TOPP)	; GET X
LOOP:	SOSG	@-1(TOPP)	; ITERATE MULTIPLICATION J-1 TIMES
	JRST	DXRET.
	DFMP	AC0,@0(TOPP)
	JRST	LOOP

	PRGEND
	TITLE	PRTXRI	*** PASCAL RUNTIME EXPONENTIATION ROUTINES ***
	
	ENTRY	EXPRI.

	EXTERN	XPRET.,XP0.,F1P0.,TWAIT.

	SEARCH	PASSYM

	$RELOC

	PAGE
; EXPRI
;
;    CALCULATES X**J,  X : REAL,  J : INTEGER
;    (AC1) = REGISTER CONAINING X
;    (AC0) = REGISTER CONTAINING J
;    X IS REPLACED BY RESULT
;
;    RETURN:	1.0 IF X=0.0 AND J<1
;
EXPRI.:	JFCL	17,	.+1		; CLEAR FLAGS
 	PUSH	TOPP,	AC1		; SAVE REGISTER # OF X
	PUSH	TOPP,	AC0		; SAVE REGISTER # OF J
	PUSH	TOPP,	F1P0.		; SET UP TEMP FLOATING 1.0
	MOVE 	AC0,	(AC1)		; GET VALUE OF X
	MOVE	AC1,	@-1(TOPP)	; GET J
	JUMPG	AC1,	EXPRI4		; CONTINUE IF J>0
	JUMPN	AC0,	EXPRI1		; WATCH OUT FOR X=0
	PUSHJ	TOPP,	TWAIT.
	OUTSTR		XP0.		; 0**(J<1)
	JRST		EXPRI2		;
EXPRI1:	JUMPL	AC1,	EXPRI3		; CAN CONTINUE IF J<0
EXPRI2:	MOVE	AC0,	F1P0.		; ELSE RETURN 1.0
	JRST		EXPRI6
EXPRI3:	MOVM	AC1,	AC1		; ABSOLUTE EXPONENT
	EXCH	AC0,	(TOPP)		; AND
	FDVR	AC0,	(TOPP)		; INVERT X
EXPRI4:	MOVEM	AC0,	(TOPP)		; SAVE X
EXPRI5:	SOJE	AC1,	EXPRI6		; ITERATE MULTIPLICATION
	FMPR	AC0,	(TOPP)		;   ABS(J-1) TIMES
	JRST		EXPRI5
EXPRI6:	POP	TOPP,	AC1		; CLEAR STACK TOP
	POP	TOPP,	AC1
	POP	TOPP,	AC1		; RETRIEVE REG # OF X
	JRST		XPRET.		; CHECK OVERFLOW AND RETURN
	PRGEND
	TITLE	DEXPRR  *** PASCAL DOUBLE PRECISION EXPONENTIATION ***

	SEARCH	PASSYM

	ENTRY	DXPRR.

	EXTERN	DLOG,DEXP,DXP0.,F1.0,DXRET.,TWAIT.

	$RELOC

;
; DXPRR
;
;	CALCULATES X**Y, BOTH DOUBLE PRECISION REAL
;	(AC1) = REGISTER CONTAINING X
;	(AC0) = REGISTER CONTAINING Y
;	X IS REPLACED BY THE DOUBLE PRECISION RESULT
;
;	RETURN:	   1.0 IF X<0.0 OR
;			  X=0.0 AND Y<=0.0
;
DXPRR.:	PUSH	TOPP,AC0	; SAVE ADDRESS OF Y
	PUSH	TOPP,AC1	; SAVE ADDRESS OF X
	SKIPL	0(AC1)
	JRST	CHECKX
	PUSHJ	TOPP,TWAIT.	; ERROR IF X NEGATIVE
	OUTSTR	NREAL.
RET1:	DMOVE	AC0,F1.0	; ERROR RETURN IS 1.0
	JRST	DXRET.
CHECKX:	SKIPG	0(AC1)
	SKIPE	@-1(TOPP)
	JRST	OK
	PUSHJ	TOPP,TWAIT.	;ERROR IF X=0 AND Y<=0
	OUTSTR	DXP0.
	JRST	RET1
OK:	DMOVE	AC0,0(AC1)	; GET X
	DMOVEM	AC0,PARAM+1	; MOVE TO PARAMETER LIST
	HRLZI	AC1,2
	HRRI	AC1,1(TOPP)
	BLT	AC1,15(TOPP)	; SAVE REGISTERS
	ADDI	TOPP,15
	MOVEI	BASIS,PARAM
	PUSHJ	TOPP,DLOG	; LOG(X)
	MOVE	REG,-16(TOPP)	; REGISTER ADDRESS OF Y
	ADDI	REG,-16(TOPP)	; NOW ADDRESS OF Y IN STACK
	DFMP	AC0,0(REG)	; Y*LOG(X)
	DMOVEM	AC0,PARAM+1
	MOVEI	BASIS,PARAM
	PUSHJ	TOPP,DEXP	; X**Y = EXP(Y*LOG(X))
	HRLZI	BASIS,-14(TOPP)
	HRRI	BASIS,2
	BLT	BASIS,BASIS	; RESTORE SAVE REGISTERS
	SUBI	TOPP,15
	JRST	DXRET.		; GO RETURN

NREAL.:	ASCIZ	/
?	Error:  Negative number to real exponent
/

	$LOW
	XWD	-1,0		; FORTRAN-FLAVORED PARAMETER LIST
PARAM:	EXP	.+1
	Z
	Z
	PRGEND
	TITLE	DXPRET  *** PASCAL DOUBLE PRECISION EXPONENTIATION ***

	SEARCH	PASSYM

	ENTRY	DXRET.,F1.0,DXP0.

	$RELOC

;
; RETURN CODE + CONSTANTS FOR DOUBLE PRECISION EXPONENTIATION ROUTINES
;
DXRET.:	DMOVEM	AC0,@0(TOPP)	; STORES RESULT
	POP	TOPP,
	POP	TOPP,		; CLEAR STACK
	POPJ	TOPP,

F1.0:	DEC	1.0		; DOUBLE PRECISION 1.0
	Z
DXP0.:	ASCIZ	/
?	Error:  Zero to exponent less than 1
/
	PRGEND
	TITLE	PRTXRR	*** PASCAL RUNTIME EXPONENTIATION ROUTINES ***
 
	ENTRY	EXPRR.

	EXTERN	ALOG.,EXP.
	EXTERN	XPRET.,XP0.,F1P0.,TWAIT.

	SEARCH	PASSYM

	$RELOC

	PAGE
; EXPRR
;
;    CALCULATES X**Y, BOTH REAL
;    (AC1) = REGISTER CONTAINING X
;    (AC0) = REGISTER CONTAINING Y
;    X IS REPLACED BY RESULT
;
;    RETURN:	1.0 IF X<0.0 OR
;		       X=0.0 AND Y<=0.0
EXPRR.:	JFCL	17,	.+1		; CLEAR FLAGS
	PUSH	TOPP,	AC0		; SAVE REG # OF Y
	MOVE	AC0,	(AC1)		; GET X
	JUMPG	AC0,	EXPRR3		; OK IF >0
	JUMPL	AC0,	EXPRR1		; AN ERROR IF X NEGATIVE
	SKIPLE		@(TOPP)		; SKIP IF Y<=0
	JRST		EXPRR4		; X=0, Y>0 ==> RESULT=0
	PUSHJ	TOPP,	TWAIT.
	OUTSTR		XP0.		; 0**0 AGAIN?
	JRST		EXPRR2
EXPRR1:	PUSHJ	TOPP,	TWAIT.		; DUMP TTY BUFFER
	OUTSTR		NTREAL		; NEG # TO REAL EXPONENT
EXPRR2:	MOVE	AC0,	F1P0.		; ERROR RETURN VALUE
	JRST		EXPRR4
EXPRR3:	HRLZI	AC0,	1
	HRRI	AC0,	1(TOPP)
	ADDI	TOPP,	17
	BLT	AC0,	(TOPP)		; SAVE REGISTERS 1-17B
	PUSH	TOPP,	0(AC1)		; MOVE X TO TEMPORARY
	HRRZ	AC1,	TOPP		; ITS ADDRESS
	HRROI	AC0,	0
	PUSH	TOPP,	AC0		; PARAMETER COUNT WORD
	PUSH	TOPP,	AC1		; PARAMETER ADDRESS
	MOVE	BASIS,	TOPP		; POINTER TO PARAMETER LIST
	PUSHJ	TOPP,	ALOG.		; GO CALCULATE LN(X)
	FMPR	AC0,	@-22(TOPP)	; Y*LN(X)
	MOVEM	AC0,	-2(TOPP)	; PARAMETER VALUE
	PUSHJ	TOPP,	EXP.		; GO CALCULATE EXP()
	HRRI	AC1,	1
	HRLI	AC1,	-21(TOPP)	; 
	BLT	AC1,	TOPP		; RESTORE REGISTERS 1-16B
	SUBI	TOPP,	17		; CLEAR STACK
EXPRR4:	EXCH	AC0,	(TOPP)		; FUDGE TO POP STACK WITH
	POP	TOPP,	AC0		; NO FREE REGISTERS
	JRST		XPRET.		; GO RETURN
NTREAL:	ASCIZ	/
?	Error: Negative number to real exponent
/
	PRGEND
	TITLE	PRTXPN	*** PASCAL RUNTIME EXPONENTIATION ROUTINES ***

	ENTRY	XPRET.

	INTERN	F1P0.,XP0.

	EXTERN	TWAIT.
	
	SEARCH	PASSYM

	$RELOC

	PAGE
;
; EXPONENTIATION RETURN
;
;    RETURN:  1   ON INTEGER  OVERFLOW
;	      1.0 ON FLOATING OVERFLOW
;	      0.0 ON FLOATING UNDERFLOW
;
XPRET.:	JFOV		XPRET3		; FLOATING ERROR?
	JOV		XPRET2		; FIXED OVERFLOW?
XPRET1:	MOVEM	AC0,	(AC1)		; RETURN VALUE
	POPJ	TOPP,			; RETURN AT LAST
XPRET2:	PUSHJ	TOPP,	TWAIT.		; DUMP TTY BUFFER FIRST
	OUTSTR		IOVERF		; INTEGER OVERFLOW
	MOVEI	AC0,	1
	JRST		XPRET1
XPRET3:	JSP	AC0,	.+1		; HASSLE TO CHECK UNDERFLOW
	TLZN	AC0,	100		; SKIP IF UNDERFLOW	
	JRST		XPRET4
	PUSHJ	TOPP,	TWAIT.		; DUMP TTY BUFFER
	OUTSTR		FUNDRF		; FLOATING UNDERFLOW
	CLEAR	AC0
	JRST		XPRET1
XPRET4:	PUSHJ	TOPP,	TWAIT.		; FINISH TTY FIRST
	OUTSTR		FOVERF		; FLOATING OVERFLOW
	MOVE	AC0,	F1P0.
	JRST		XPRET1
	PAGE
XP0.:	ASCIZ /
?	Exponentiation error: Zero to exponent less than 1
/
IOVERF:	ASCIZ /
?	Arithmetic exponentiation overflow
/
FUNDRF:	ASCIZ /
?	Exponentiation underflow
/
FOVERF:	ASCIZ /
?	Exponentiation overflow
/
F1P0.:	DEC	1.0
	END
