$PAGE	ARCCOS	 ARC COSINE ROUTINE

;FLOATING POINT SINGLE PRECISION ARCCOSINE FUNCTION

;ARCCOS(X) IS CALCULATED IN THE FOLLOWING MANNER:
;	IF X > 0,	ARCCOS(X)=ARCTAN((SQRT(1-X^2))/X)
;	IF X < 0,	ARCCOS(X)=PI + ARCTAN((SQRT(1-X^2))/X)
;	IF X = 0,	ARCCOS(X)=PI/2

;THE RANGE OF DEFINITION FOR ARCCOS IS -1.0 TO +1.0.
;ARGUMENTS OUTSIDE OF THIS RANGE WILL CAUSE AN ERROR MESSAGE.

;THE CALLING SEQUENCE FOR ARCCOS IS:

;	PUSHJ	17,R.ACOS
;	ARG	REG,ADDR(ARGUMENT)


	SEARCH	RTFOR

	$MATH	R
	$INITMATH (ACOS,R)
	MOVM	0,ARG1		;GET /ARG./ IN AC 0.
	CAMLE	0,F1.0		;IS MAGNITUDE OF ARG. GT 1.0?
	JRST	TOOLRG		;YES, GO TO ERROR RETURN.
	JUMPE	0,ZERARG	;IF ARG=0, GO TO ZERARG.
	FMPR	0,0		;X^2 IN AC 0.
	MOVNS	0		;-X^2 IN AC 0.
	FAD	0,F1.0		;1.0-X^2 IN AC 0.
	PUSHJ	TOP,SQRT.R##	;CALC SQRT (1.0-X^2).
	FDVR	0,ARG1		;(SQRT(1.0-X^2))/X IS IN AC 0.
	PUSHJ	TOP,ATAN.R##	;FIND ARCTAN(SQRT(1.0-X^2)/X).
	SKIPGE	ARG1		;SKIP IF ORIGINAL ARG >= 0.
	FAD	0,PI.		;ANSWER IS PI - ORIGINAL ANSWER.
	JRST	R.RET		;ARCCOS RETURN
ZERARG:	MOVE	0,PIOV2.		;ANSWER IS PI/2.
	JRST	R.RET2		;ARCCOS RETURN
TOOLRG:
	$MTHERR (ACOSERROR)
ACOSERROR:
	ASCIZ	/ARCCOS of arg > 1.0 in magnitude/
	PRGEND
$PAGE	ARCSIN	 ARC SINE ROUTINE


;FLOATING POINT SINGLE PRECISION ARCSINE FUNCTION
;THE ARCSINE IS CALCULATED WITH THE FOLLOWING ALGORITHM:

;	ARCSIN(X) = ARCTAN(X/SQRT(1-X^2))

;THE RANGE OF DEFINITION FOR ARCSIN IS (-1.0,1.0)
;OTHER ARGUMENTS WILL CAUSE AN ERROR MESSAGE TO BE.

	SEARCH	RTFOR

; CALLING SEQUENCE:
;
;	PUSHJ	TOP,R.ASIN
;	ARG	REG,ADDR(ARGUMENT)

	$MATH	R
	$INITMATH (ASIN,R)
	MOVM	R1,ARG1		;GET MAGNITUDE OF ARG. IN R1
	CAMLE	R1,F1.0		;IS THE MAGNITUDE OF THE ARG. LE 1.0?
	JRST	TOOLRG		;NO, GO TO ERROR RETURN.
	MOVN	R0,ARG1		;GET THE NEGATIVE OF ARG
	FMP	R0,ARG1		;CALCULATE -(X^2)
	FAD	R0, F1.0		;CALCULATE 1-(X^2)
	JUMPE	R0, ASIN1	;WAS X EITHER -1.0 OR 1.0?
	PUSHJ	TOP,SQRT.R##	;CALCULATE SQRT (1-X^2).
	MOVE	R1,ARG1		;GET THE ARGUMENT BACK AGAIN
	FDVM	R1, R0		;CALCULATE X/SQRT(1-X^2)
	PUSHJ	TOP,ATAN.R##	;CALCULATE ARCTAN (X/SQRT(1-X^2)).
	JRST	R.RET2		;ARCSIN RETURN

ASIN1:	MOVE	R0, PIOV2.		;ANSWER IS EITHER PI/2 OR-PI/2
	SKIPG	ARG1		;WAS ORIGINAL ARGUMENT POSITIVE?
	MOVNS	R0		;NO, GET -PI/2
	JRST	R.RET2		;ARCSIN RETURN

TOOLRG:
	$MTHERR (ASINERROR)
ASINERROR:
	ASCIZ	/ARCSIN of arg > 1.0 in magnitude/
	PRGEND
$PAGE	ATAN2	 ARC TAN ROUTINE WITH 2 ARGUMENTS

;FLOATING POINT SINGLE PRECISION ARCTANGENT OF TWO ARGUMENTS
;RETURNS ARCTANGENT OF R0/R1
;IF ARGUMENT IS IN 2ND QUADRANT, ATAN2(R0/R1) = PI + ARCTAN(R0/R1)
;IF ARGUMENT IS IN 3RD QUADRANT, ATAN2(R0/R1) = ARCTAN(R0/R1) - PI
;IF R0/R1 OVERFLOWS (OR DIVIDE CHECK), THEN RETURN
;	+PI/2 IF R0>=0, AND
;	-PI/2 IF R0<0.
;IF R0/R1 UNDERFLOWS, THEN RETURN
;	0 IF R1>=0, AND
;	+PI IF R1<0 AND R0 >=0,
;	-PI IF R1<0 AND R0<0.

;THERE IS NO RESTRICTION ON THE ARGUMENTS

;THE ROUTINE IS CALLED  IN THE FOLLOWING MANNER:
;	PUSHJ	17,R.ATN2
;	ARG	REG,ADDR(ARG1)
;	ARG	REG,ADDR(ARG2)
; THE RESULT IS RETURNED IN THE DESTINATION REGISTER.

	SEARCH	RTFOR

	$MATCH	R
	$INITMATH (ATN2,R)
	AOS	R1,-$MAXLOCALS(TOP)	;BUMP RETURN ADDRESS
	MOVE	R1,@-1(R1)	;GET SECOND PARAMETER
	MOVEM	R1,ARG2
	MOVE	R0,ARG1		;RETRIEVE FIRST PARM
	JUMPE	R1,DIVCHK	; INTERCEPT IF DIVCHK WILL OCCUR
	FDVR	R0, R1		;FORM R0/R1
	JSP	R1,.+1		;GET FLAGS
	TLNE	R1,100		;SKIP IF NO UNDERFLOW
	JRST	UNDER
	TLNE	R1,40000	;SKIP IF NO OVERFLOW
	JRST	DIVCHK
	PUSHJ	TOP,ATAN.R##	;CALCULATE ARCTAN (R0/R1)
	SKIPL	ARG2		;IF ARG2>0, SGN(ATAN2)=SGN(R0)
	JRST	R.RET2		;ATAN2 RETURN
	JUMPGE	R0, ATAN2A	;IS R0 POSITIVE?
	FADR	R0, PI.		;NO, SECOND QUADRANT, ADD PI
	JRST	R.RET2		;ATAN2 RETURN

ATAN2A:	FSBR	R0, PI.		;YES,3RD QUADRANT, SUBTRACT PI
	JRST	R.RET2		;ATAN2 RETURN
DIVCHK:	JUMPE	R0,R.RET2	; IF BOTH ARGS 0 THEN RETURN 0
	MOVE	R0,PIOV2.	;ANSWER SET TO PI OVER TWO.
	JRST	RET		;CHECK SIGN AND RETURN
UNDER:
	JUMPL	R1,UNDEROK	;IF R1 >= 0,
	$MTHERROR (ATAN2ERROR)	;GIVE ERROR MESSAGE
ATAN2ERROR:
	ASCIZ	/floating underflow in ATAN2/
UNDEROK:
	MOVE	R0,PI.		;SET ANSWER TO PI
RET:
	SKIPGE	ARG1		;SKIP IF 1ST ARG WAS >= 0.
	MOVNS	R0		;SET ANSWER NEGATIVE
	JRST	R.RET2		;ATAN2 RETURN

	PRGEND
$PAGE	ARCTAN	ARC TAN ROUTINE WITH ONE ARGUMENT

; FLOATING POINT SINGLE PRECISION ARCTANGENT ROUTINE
;
; CALLED DIRECTLY FROM COMPILER GENERATED CODE, BUT MERELY
; FETCHES THE PARAMETER AND CALLS THE COMMON RUNTIME ROUTINE
; ATAN.R
;
	SEARCH	RTSYM
	SEARCH	RTFOR
	$MATH	(R)
	ENTRY	R.ATAN
	EXTERN	ATAN.R

	$MATH	R
	$INITMATH (ATAN,R)
	JSP	R2,ATAN.R
	JRST	R.RET2		;DO RETURN
	PRGEND
$PAGE	ATAN.R	 COMMON ARC TAN ROUTINE WITH 1 ARGUMENT


;FLOATING POINT SINGLE PRECISION ARCTANGENT FUNCTION
;ARCTAN(X) = X(B0+A1(Z+B1-A2(Z+B2-A3(Z+B3)**-1)**-1)**-1)
;WHERE Z=X^2, IF 0<X<=1

;IF X>1, THEN ARCTAN(X) = PI/2 - ARCTAN(1/X)
;IF X>1, THEN RH(R3) =-1, AND LH(R3) = -SGN(X)
;IF X<1, THEN RH(R3) = 0, AND LH(R3) =  SGN(X)

;THE ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	MOVE	R0,ARGUMENT
;	JSP	R2,ATAN.R
;THE ANSWER IS RETURNED IN ACCUMULATOR R0

	SEARCH	RTFOR

	$MATH	()
ATAN.R:	MOVM	R1, R0		;GET ABSF OF ARGUMENT
	CAMG	R1, A1		;IF X<2^-33, THEN RETURN WITH...
	JRST	AT5		;ARCTAN(X) = X
	HLLO	R3, R0		;SAVE SIGN, SET RH(R3) = -1
	CAML	R1, A2		;IF R0>2^33, THEN RETURN WITH
	JRST	AT4		;ARCTAN(X) = PI/2
	MOVEM	R2, C1		;SAVE ACCUMULATOR R2
	MOVSI	R2, 201400	;FORM 1.0 IN R2
	CAMG	R1, R2		;IS ABSF(X)>1.0?
	TRZA	R3, -1		;IF R1 .LE. 1.0, THEN RH(R3) = 0
	FDVM	R2, R1		;R1 IS REPLACED BY 1.0/R1
	TLC	R3, (R3)		;XOR SIGN WITH .G. 1.0 INDICATOR
	MOVEM	R1, ARG0	;SAVE THE ARGUMENT
	FMP	R1, R1		;GET R1^2
	MOVE	R2, KB3		;PICK UP R0 CONSTANT
	FAD	R2, R1		;ADD R1^2
	MOVE	R0, KA3		;ADD IN NEXT CONSTANT
	FDVM	R0, R2		;FORM -A3/(R1^2 + B3)
	FAD	R2, R1		;ADD R1^2 TO PARTIAL SUM
	FAD	R2, KB2		;ADD B2 TO PARTIAL SUM
	MOVE	R0, KA2		;PICK UP -A2
	FDVM	R0, R2		;DIVIDE PARTIAL SUM BY -A2
	FAD	R2, R1		;ADD R1^2 TO PARTIAL SUM
	FAD	R2, KB1		;ADD  B1 TO PARTIAL SUM
	MOVE	R0, KA1		;PICK UP A1
	FDV	R0, R2		;DIVIDE PARTIAL SUM BY A1
	FAD	R0, KB0		;ADD B0
	FMP	R0,ARG0		;MULTIPLY BY ORIGINAL ARGUMENT
	TRNE	R3, -1		;CHECK .G. 1.0 INDICATOR
	FSB	R0, PIOV2.		;ARCTAN(R0) = -(ARCTAN(1/R0)-PI/2)
	JRST	AT4A
AT4:	MOVE	R0, PIOV2.		;GET PI/2 AS ANSWER
AT4A:
	SKIPGE	R3		;LH(R3) = -SGN(R1) IF R1>1.0
	MOVNS	R0		;NEGATE ANSWER
AT5:	POPJ	TOP,		;ATAN.R RETURN

A1:	145000000000		;2**-33
A2:	233000000000		;2**33
KB0:	176545543401		;0.1746554388
KB1:	203660615617		;6.762139240
KB2:	202650373270		;3.316335425
KB3:	201562663021		;1.448631538
KA1:	202732621643		;3.709256262
KA2:	574071125540		;-7.106760045
KA3:	600360700773		;-0.2647686202
	PRGEND
$PAGE	SQRT	SQUARE ROOT ROUTINE

	SEARCH	RTSYM
	SEARCH	RTFOR

; SQUARE ROOT ROUTINE CALLED DIRECTLY FROM COMPILER GENERATED
; CODE. MERELY FETCHES PARAMETER AND PASSES IN TO COMMON SQUARE
; ROOT ROUTINE SQRT.R.

	$MATH	()
	$INITMATH (SQRT,R)
	JSP	R2,SQRT.R	;DO CALCULATION
	JRST	R.RET2		;AND RETURN
	PRGEND
$PAGE	SQRT.R	 COMMON SQUARE ROOT ROUTINE

;FLOATING POINT SINGLE PRECISION SQUARE ROOT FUNCTION
;THE SQUARE ROOT OF THE ABSOLUTE VALUE OF THE ARGUMENT IS
;CALCULATED.  THE FIRST GUESS IS CALCULATED TO BE OPTIMUM
;FOR NUMBERS BETWEEN 1/2 AND 2
;FOLLOWED BY TWO ITERATIONS OF NEWTON'S METHOD.

;THE CALLING SEQUENCE FOR THE SQUARE ROOT IS AS FOLLOWS:
;	MOVE	R0,ARGUMENT
;	JSP	R2,SQRT.R
;THE ANSWER IS RETURNED IN ACCUMULATOR R0.

	SEARCH	RTFOR
SQRT.R:
	JUMPLE	R0,SQRTLE	;CHECK IF ARG > 0

SQRTP:	MOVE	R1,R0		;SAVE NUMBER
	MOVE	R3,R0		;TWICE
	LSH	R1,-1		;DIVIDE EXP BY 2
	TLZE	R1,400		;WAS EXPONENT ODD?
	JRST	SQRT2		;YES

;HERE WHEN EXPONENT WAS EVEN.  R1 CONTAINS AN UNNORMALIZED FLOATING
; POINT NUMBER, THE FRACTION PART OF WHICH IS 1/2 THE FRACTION OF
; THE ARGUMENT.  OUR INITIAL GUESS IS MADE BY R0 LINEAR APPROXIMATION
; USING Y0 = SE (X + C), WHERE SE AND C ARE CONSTANTS USED FOR
; EVEN EXPONENTS IN X.

	ADD	R1,[XWD 267,607000]	;COMPUTE LINEAR APPROXIMATION
	FMPRI	R1,301454	;RESCALE EXPONENT
	JRST	SQRT3

;HERE WITH ODD EXPONENT, USE Y0 = SO * (X+C).

SQRT2:	ADD	R1,[XWD 267,607000]	;LINEAR APPROXIMATION
	FMPRI	R1,301650		;RESCALE EXPONENT

SQRT3:	FDV	R0,R1		;ORIGINAL / INITIAL GUESS
	FAD	R1,R0		;AVERAGE THEM
	FSC	R1,-1
	MOVM	R0,R3		;GET ORIGINAL NUMBER
	FDV	R0,R1		;SECOND ITERATION
	FADR	R0,R1
	FSC	R0,-1		;AVERAGE THIRD GUESS WITH SECOND

SQRET:
	JRST	0(R2)		;SQRT.R RETURN

SQRTLE:	JUMPE	R1,0(R2)
	$MTHERR (SQRTERROR)
SQRTERRROR:
	ASCIZ	/Attempt to take SQRT of negative arg/
	PRGEND
$PAGE	SINH	 HYPERBOLIC SIN ROUTINE


;FLOATING POINT SINGLE PRECISION HYPERBOLIC SINE FUNCTION.

;SINH IS CALCULATED AS FOLLOWS:
;	IF ABS(X)>88.029,
;		SINH(X)=(EXP[ABS(X)-LN(2)])*SIGN(X)
;	IF ABS(X)<=0.10,
;		SINH(X)=X+(X**3)/6+(X**5)/120
;	FOR ALL OTHER VALUES OF X,
;		SINH(X)=1/2[EXP(X)-1/EXP(X)]

;THE CALLING SEQUENCE IS:
;	JSA	Q,SINH
;	EXP	ARG

;THE ANSWER IS RETURNED IN AC 0.

	SEARCH	RTFOR

	HELLO	(SINH,.)	;[235] ENTRY TO HYPERBOLIC SINE ROUTINE.
	MOVE	0,@(16)		;PICK UP THE ARG.
	MOVEM	2,SAVE2		;SAVE AC 2.
	MOVEM	0,ARGTMP	;SAVE ARG.
	MOVM	2,0		;GET MAGNITUDE OF ARG IN AC 2.
	CAMLE	2,EIGHT8	;IF ABS(X)>88.029,
	JRST	OV88		;THEN GO TO OV88.
	CAMG	2,ONE10T	;IF ABS(X)<=0.10,
	JRST	SERIES		;THEN GO TO SERIES.
	FUNCT	EXP.,<2>		;FIND EXP(ABS(X)).
				;ABS(X) IS IN AC 2.
	HRLZI	1,576400	;PUT -1.0 IN AC 1.
	FDVR	1,0		;CALC. -EXP(-ABS(X)).
	FADR	0,1		;CALC. EXP(ABS(X))-EXP(-ABS(X)).
	FDVRI	0,202400	;CALC. THIS/2.0
	SKIPGE	ARGTMP		;ANSWER IS POSITIVE.
	MOVNS	0,0		;ANSWER IS NEGATIVE.
	MOVE	2,SAVE2		;RESTORE AC 2.
	GOODBY	(1)		;SINH RETURN
SERIES:	FMPR	2,2		;CALC. X^2.
	JFCL			;SUPPRESS ERROR MESSAGE FROM OVTRAP.
	MOVEM	2,SX2		;SAVE X^2 IN SX2.
	FDVR	2,ONE120	;CALC.X^2/120
	JFCL			;SUPPRESS ERROR MESSAGE FROM OVTRAP.
	FADR	2,ONESIX	;CALC. (X^2/120)+1/6
	FMPR	2,SX2		;MULTIPLY IT BY X^2.
	JFCL			;SUPPRESS ERROR MESSAGE FROM OVTRAP.
	FADRI	2,201400	;ADD 1.0.
	FMPR	0,2		;MULTIPLY BY X.
	MOVE	2,SAVE2		;RESTORE AC 2.
	GOODBY	(1)		;SINH RETURN
OV88:	FSBR	2,LN2BE		;CALC.ABS(X)-LN(2)
	CAMG	2,EIGHT8	;OVERFLOW?
	JRST	EXPP		;NO,GO TO CALC.
	ERROR	(APR,5,1,.+1)	;TYPE AN ERROR MESSAGE
	HRLOI	0,377777	;SET ANS.=INFINITY.
	JRST	EXPP1		;GO TO SET SIGN OF ANS.

EXPP:	FUNCT	EXP.,<2>		;CALC. EXP
EXPP1:	SKIPGE	ARGTMP		;RETURN ANS. >0 IF X>0.
	MOVNS	0		;O'E, ANS. <0.
	MOVE	2,SAVE2		;RESTORE AC 2.
	GOODBY	(1)		;SINH RETURN

LN2BE:	200542710300		;LN(2)
EIGHT8:	207540074636		;88.029
ONE10T:	0.10
ONE120:	207740000000		;120.0
ONESIX:	0.16666667
	PRGEND
$PAGE	COSH.	 HYPERBOLIC COSINE ROUTINE

;FLOATING POINT SINGLE PRECISION HYPERBOLIC COSINE FUNCTION.

;COSH(X) IS CALCULATED AS FOLLOWS:
;	IF ABS(X) <= 88.029,
;		COSH(X) = 1/2(EXP(X) + 1.0/EXP(X))
;	IF ABS(X) > 88.029 AND (ABS(X)-LN(2)) <= 88.029,
;		COSH(X) = EXP(ABS(X)-LN(2))
;	IF (ABS(X)-LN(2)) > 88.029,
;		COSH(X)=377777777777
;		AND AN ERROR MESSAGE IS RETURNED.

;THE ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	JSA	16,COSH
;	EXP	ARG
;THE ANSWER IS RETURNED IN AC 0.

	SEARCH	RTFOR

	HELLO	(COSH,.)	;[235] ENTRY TO HYPERBOLIC COSINE ROUTINE.
	MOVE	0,@(16)		;PICK UP THE ARGUMENT.
	MOVEM	2,SAVE2		;SAVE AC 2.
	MOVM	2,0		;PUT ABS(X) IN AC 2.
	CAMLE	2,EIGHT8	;IF ABS(X) > 88.029,
	JRST	OV88		;GO TO OV88.
	FUNCT	EXP.,<2>		;O'E, CALC. EXP(ABS(X))
	MOVSI	2,201400	;PUT 1.0 IN AC 2.
	FDVR	2,0		;CALC. 1.0/EXP(ABS(X)).
	FADR	0,2		;CALC. EXP(ABS(X)) + EXP(-ABS(X)).
	FDVRI	0,202400	;DIVIDE THIS BY 2.0.
	MOVE	2,SAVE2		;RESTORE AC 2.
	GOODBY	(1)		;COSH RETURN

OV88:	FSBR	2,LN2BE		;FORM ABS(X)-LN(2).
	CAMG	2,EIGHT8	;OVERFLOW?
	JRST	EXPP		;NO,GO AHEAD.
	ERROR	(APR,5,1,.+1)	;TYPE AN ERROR MESSAGE
	HRLOI	0,377777	;ANSWER = +INFINITY.
	MOVE	2,SAVE2		;RESTORE AC 2.
	GOODBY	(1)		;COSH RETURN

EXPP:	FUNCT	EXP.,<2>		;CALC. EXP(ABS(X)-LN(2)).
	MOVE	2,SAVE2		;RESTORE AC 2.
	GOODBY	(1)		;COSH RETURN

SAVE2:	0
EIGHT8:	207540074636	;88.029
LN2BE:	200542710300	;LOG(2) BASE E.

	PRGEND
$PAGE	TANH.	 HYPERBOLIC TANGENT ROUTINE

;FLOATING POINT SINGLE PRECISION HYPERBOLIC TANGENT ROUTINE

;THIS ROUTINE CALCULATES THE TANH BY THE FOLLOWING ALGORITHM:
;IF ABSF(X) <.00034, THEN TANH(X) = X
;IF ABSF(X) >12.0, THEN TANH(X) = 1.0*SIGN(X)
;IF 0.17 <= X < 12.0, THEN TANH IS CALCULATED AS
;	TANH(X) = 1.0 - 2(1.0 + EXP(2*X))**-1
;IF .00034 <= X < 0.17, THEN TANH IS CALCULATED AS
;TANH(X) = F(A+F^2(B+C(D+F^2)**-1))**-1
;WHERE X = 4*LOG(E)  (BASE 2)

;THE ROUTINE IS CALLED IN THE FOLLOWING MANNER:
;	JSA	Q, TANH
;	EXP	ARG
;THE ANSWER IS RETURNED IN ACCUMULATOR A

	SEARCH	RTFOR

	HELLO	(TANH,.)	;[235] ENTRY TO TANH ROUTINE
	MOVE	A, @(Q)		;PICK UP THE ARGUMENT
	MOVM	B, A		;GET ABSF(ARGUMENT)
	CAMGE	B, KT1		;RETURN TANH(X)=X IF 
	JRST	TH2		;ABSF(X) .LE. .00034
	CAMLE	B, KT2		;RETURN TANH(X) = 1.0 IF
	JRST	TH5		;ARGUMENT GREATER THAN 12.0
	CAMGE	B, KT3		;USE RATIONAL APPROXIMATION IF
	JRST	TH3		;ARGUMENT IS LESS THAN 0.17
	MOVEM	A,SAVEA		;SAVE ARG. 
	FMPRI	B,202400	;GET 2*ARG.
	MOVEM	B,TM1		;ARG TO NE 0 OR 1.
	FUNCT	EXP.,<TM1>	;CALCULATE EXP(2X)
	MOVSI	B, 201400	;FORM 1.0
	FAD	A, B		;1 + EXP(2X)
	FDVM	B, A		;(1 + EXP(2X))**-1
	FMPRI	A,202400	;2*(1 + EXP(2X))**-1
	FSBRM	B, A		;1 - 2*(1 + EXP(2X))**-1
	SKIPGE	SAVEA		;SKIP AHEAD IF ARG WAS >=0.
	MOVNS	A		;OTHERWISE,NEGATE THE ANSWER.
TH2:	GOODBY	(1)		;TANH RETURN

TH3:	FMP	A, KT7		;FORM 4*X*LOG(E) BASE 2
	MOVEM	A, TM1		;SAVE IT IN TM1
	FMP	A, A		;SQUARE IT
	MOVEM	A, TM2		;SAVE IT
	FAD	A, KT4		;FORM F^2 + T4
	MOVE	B, KT5		;GET T5 IN ACCUMULATOR B
	FDV	B, A		;KT5/(F^2 + KT4)
	FAD	B, KT6		;KT6 + KT5/(F^2 + KT4)
	FMP	B, TM2		;MULTIPLY BY F^2
	FAD	B, KT7		;ADD T7 (4*LOG(E) BASE 2)
	MOVE	A, TM1		;GET F IN ACCUMULATOR A
TH5:	FDV	A, B		;DIVIDE F BY PARTIAL SUM
	GOODBY	(1)		;TANH RETURN

KT1:	165544410070		;0.00034
KT2:	204600000000		;12.0
KT3:	176534121727		;0.17
KT4:	211535527022		;349.6699888
KT5:	204704333567		;14.1384514018
KT6:	173433723376		;0.01732867951
KT7:	203561250731		;5.7707801636

TM1:	0
TM2:	0
SAVEA:	0
	PRGEND
$PAGE	EXP1

;SINGLE PRECISION INTEGER TO INTEGER EXP FUNCTION.

;EXP CALCULATES I**J, WHERE
;	J=Q(0) + Q(1)*2 + Q(2)*4 + ..., WHERE Q(I)=0 OR 1.

;THE CALLING SEQUENCE FOR THE ROUTINES IS:
;	PUSHJ	17,EXP1.N	WHERE N=0,2,4, OR 6.
;THE BASE IS IN AC N AND THE EXPONENT IS IN AC N+1.
;THE ANSWER IS RETURNED IN AC N.

	SEARCH	RTFOR
	ENTRY	EXP1.

EXP1.:	MOVE	T0,@(L)		;GET THE BASE
	MOVE	T1,@1(L)		;GET THE EXPONENT
	JUMPE	B,[MOVEI A,1		;BASE**0 RETURNS 1
		POPJ P,]
	JUMPN	A,BASNT0	;GO AHEAD IF BASE NE 0.
	JUMPGE	B,IEXP4		;RETURN IF BASE=0, EXP >= 0.
IOVFL:	ERROR	(APR,5,1,.+1)	;O'E, SET UP
	HRLOI	0,377777	;ANS.= INFINITY
	POPJ	17,		;AND RETURN.

BASNT0:	JUMPL	B,[TRNN B,1	;TEST FOR EXP<0.  IS EXP ODD?
		MOVMS A		;EXP IS EVEN. GET ABS(BASE)
		CAIE A,1	;IS BASE +-1?
		CAMN A,[-1]
		POPJ P,		;YES, RETURN +-1
		MOVEI A,0	;NO, RETURN 0
		POPJ P,]
	PUSH	P,C		;SAVE A WORKING AC.
	MOVEI	C,1		;INITIALIZE ANSWER TO 0.
	MOVEM	C,SAVEC		;INITIALIZE FLAG WORD TO > 0.
	JUMPG	A,IEXP2		;GO TO CALC. IF ANSWER WILL BE > 0.
	TRNN	B,1		;IS EXP ODD OR EVEN?
	JRST	IEXP2		;EXP IS EVEN, ANS WILL BE > 0.
	SETCMM	SAVEC		;EXP IS ODD, BASE < 0, ANS WILL BE <0. 
	JRST	IEXP2		;GO TO CALC.

IEXP1:	IMUL	A,A		;
	JFCL	1,OVER		;TRANSFER TO OVER IF OVERFLOW.
	LSH	B,-1		;DIVIDE B BY 2.
IEXP2:	TRZE	B,1		;CHECK LAST BIT OF B.
	IMUL	C,A		;
	JFCL	1,OVER		;TRANSFER TO OVER IF OVERFLOW.
	JUMPG	B,IEXP1		;GO TO RETURN IF B HAS BECOME 0.
IEXP3:	MOVE	A,C		;PUT ANSWER IN AC A.
IEXP3A:	POP	P,C		;RESTORE AC C.
IEXP4:	POPJ	P,		;RETURN.

OVER:	PUSHJ	P,IOVFL		;SET ANSWER TO + INFINITY.
	SKIPL	SAVEC		;SKIP IF ANS IS TO BE < 0.
	JRST	IEXP3A		;GO TO RETURN.
	MOVNS	A,A		;SET UP -
	SUBI	A,1		;INFINITY
	JRST	IEXP3A		;GO TO RETURN.

SAVEC:	0

	LIT
	PRGEND
$PAGE	EXP3	

;SINGLE PRECISION FORTRAN IV EXP.3 FUNCTIONS
;THESE ROUTINES CALCULATE A FLOATING POINT NUMBER RAISED TO A
;FLOATING POINT POWER. THE CALCULATION IS
;	A**B= EXP(B*LOG(A))

;IF THE EXPONENT IS AN INTEGER < 2**35 IN MAGNITUDE, THE
;RESULT WILL BE COMPUTED USING "EXP2.." AND THE ANSWER 
;WILL HAVE THE CORRECT SIGN. (REMEMBER THAT THE "INTEGER"
;HAS ONLY 27 SIGNIFCANT BITS.)
;SINCE NEGATIVE NUMBERS RAISED TO NON-INTEGER POWERS YIELD
;COMPLEX ANSWERS, THE MAIN ALGORITHM CALCULATES
;	EXP(B*LOG(ABSF(A)))

;THE CALLING SEQUENCE FOR THE ROUTINES IS AS FOLLOWS:
;	PUSHJ	P, EXP3.'N'
;WHERE N IS EITHER 0,2,4, OR 6. THE BASE IS IN ACCUMULATOR N
;AND THE EXPONENT IS IN ACCUMULATOR (N+1) WHEN THE ROUTINE
;IS CALLED. THE RESULT IS RETURNED IN ACCUMULATOR N.

	ENTRY	EXP3.
EXP3.:	MOVE	T0,@(L)		;GET THE BASE
	MOVE	T1,@1(L)	;GET THE EXPONENT
	JUMPE	B,[MOVSI A,(1.0)	;BASE**0, RETURNS 1
		POPJ P,]
	JUMPN	A,EXP30A	;GO AHEAD IF BASE NE 0.
	JUMPGE	B,EXP3A		;EXIT IF BASE = 0, EXP >= 0,
	ERROR	(APR,5,1,.+1)	;O'E, TYHE AN ERROR MESSAGE
	HRLOI	A,377777	;ANS.=+INFINITY
	POPJ	17,		;AND EXIT.

EXP30A:	PUSH	P,C		;SAVE AC C
	PUSH	P,D		;SAVE AC D
	MOVM	D,B		;SET EXP. POSITIVE.
	MOVEI	C,0		;CLEAR AC C TO ZERO
	LSHC	C,11		;SHIFT 9 PLACES LEFT
	SUBI	C,200		;TO OBTAIN SHIFTING FACTOR
	PUSH	P,E		;SAVE AC E.
	JUMPLE	C,EXP3GO	;IS C > 0
	HRR	E,C		;SET UP E AS AN INDEX REG.
	MOVEI	C,0		;CLEAR OUT AC C
	LSH	D,-1		;RIGHT ADJUST EXP TO BIT 1.
	ASHC	C,(E)		;SHIFT LFT BY CONTENTS OF E
	JFCL	EXP3GO		;IF OVERFLOW, GO TO EXP3GO.
	JUMPN	D,EXP3GO	;IS EXPONENT AN INTEGER ?
	JUMPGE	B,.+2		;YES, WAS  IT NEG. ?
	MOVNS	C		;YES, NEGATE IT
	MOVE	B,C		;MOVE INTEGER INTO B
	PUSHJ	P,EXP2..	;%216% OBTAIN RESULT USING EXP2..
	JRST	EXPPOP		;RETURN TO RESTORE ACS C&D&E.

EXP3GO:	MOVM	E,A		;GET ABS(BASE) IN NE 0 OR 1.
	MOVE	D,A		;SAVE SIGN OF A
	MOVE	C,B		;SAVE AC B.
	FUNCT	ALOG.,<E>	;CALCULATE LOG OF A
	FMPRM	A, C		;CALCULATE B*LOG(A)
	FUNCT	EXP.,<C>		;CALCULATE EXP(B*LOG(A))
	JUMPGE	D,EXPPOP	;SHOULD SIGN BE NEGATIVE?
	MOVN	A,A		;YES, NEGATE RESULT
EXPPOP:	POP	P,E		;RESTORE AC E.
	POP	P,D		;RESTORE AC D.
	POP	P,C		;RESTORE AC C.
EXP3A:	POPJ	P,		;EXIT

	LIT
	PRGEND
$PAGE	EXP2	

;SINGLE PRECISION EXP.2 FUNCTIONS
;THESE ROUTINES CALCULATE A FLOATING POINT NUMBER TO A FIXED
;POINT POWER. THE CALCULATION IS A**B, WHERE B IS OF THE FORM

;	B=Q(0) + Q(1)*2 + Q(2)*4 + ...WHERE Q(I)=0 OR 1

;THERE ARE NO RESTRICTIONS ON THE BR EXPONENT

;THE CALLING SEQUENCES FOR THE ROUTINES ARE AS FOLLOWS:
;	PUSHJ	P, EXP2.'N'
;WHERE N IS EITHER 0,2,4, OR 6. THE BASE IS IN ACCUMULATOR N
;AND THE EXPONENT IS IN ACCUMULATOR (N+1) WHEN THE ROUTINE IS
;CALLED. THE ANSWER IS RETURNED IN ACCUMULATOR N.

	SEARCH	RTFOR
	ENTRY	EXP2.
EXP2.:	MOVE	T0,@(L)		;GET THE BASE
	MOVE	T1,@1(L)	;GET THE EXPONENT
EXP2..:	JUMPE	B,[MOVSI A,(1.0)		;BASE**0, RETURNS 1
		POPJ P,]
	JUMPN	A,EXP2A		;GO AHEAD IF BASE NE 0.
	JUMPGE	B,FEXP4		;EXIT IF BASE =0, EXP >= 0,
	ERROR	(APR,5,1,.+1)	;O'E, SET UP
	HRLOI	0,377777	;AN ANSWER OF INFINITY.
	POPJ	17,		;RETURN.

EXP2A:	MOVEM	C,SAVEC  	;SAVE A WORKING ACCUMULATOR.
	MOVSI	C, 201400	;GET 1.0 IN ACCUMULATOR C.
	MOVEM	A,SAVEA		;STORE BASE IN SAVEA.
	MOVEM	B,SAVEB		;STORE EXP. IN SAVEB.
	JUMPGE	B, FEXP2	;IS EXPONENT POSITIVE?
	MOVMS	B		;NO, MAKE IT POSITIVE
	JFCL	MININF		;IF EXP WAS 400000,,0 GO TO MININF.
	PUSHJ	P, FEXP2	;CALL MAIN PART OF PROGRAM.
INV:	MOVSI	B, 201400	;GET 1.0 IN B.
	FDVM	B, A		;FORM 1/(A**B) FOR NEG. EXPONENT.
	POPJ	P,		;RETURN.

FEXP1:	FMP	A, A		;FORM A**N, FLOATING POINT.
	JFCL	OVER		;IF OVER/UNDERFLOW, GO TO OVER.
	LSH	B, -1		;SHIFT EXPONENT FOR NEXT BIT.
FEXP2:	TRZE	B, 1		;IS THE BIT ON?
	FMP	C, A		;YES, MULTIPLY ANSWER BY A**N.
	JFCL	OVER		;IF OVER/UNDERFLOW, GO TO OVER.
	JUMPN	B, FEXP1	;UPDATE A**N UNLESS ALL THROUGH.
FEXP3:	MOVE	A, C		;PICK UP RESULT FROM C.
FEXP3A:	MOVE	C,SAVEC		;RESTORE A WORKING ACCUMULATOR.
FEXP4:	POPJ	P,		;RETURN.
OVER:	MOVE	C,.JBTPC		;PICK UP FLAGS.
	SKIPG	SAVEB		;JUMP TO INVERT IF
	JRST	INVERT		;EXP. WAS NEGATIVE.
	TLNE	C,(1B11)	;UNDERFLOW, IN WHICH CASE,
	ERROR	(APR,7,1,OUT)	;UNDER FLOW
	ERROR	(APR,5,1,OUT)	;OVER FLOW
OUT:	HRLOI	A,377777	;ANS. IS SET TO + INFINITY.
	TLNE	C,(1B11)	;SKIP IF OVERFLOW FLAG SET.
	SETZ	A,		;O'E, SET ANSWER TO 0.
OUT2:	SKIPL	SAVEA		;ANS. IS >= 0, IF
	JRST	FEXP3A		;A WAS >= 0.
	MOVE	B,SAVEB		;PICK UP THE EXP.
	TRNE	B,1		;ANS. IS < 0, IF A < 0 AND
	MOVNS	A		;THE EXP. WAS ODD.
	JRST	FEXP3A		;GO TO RETURN.

INVERT:	SUB	P,[XWD 1,1]	;ADJUST PDP.
	TLCN	C,(1B11)	;IF TRUE UNDERFLOW, GO
	JRST	ALOGRT		;TO ALOGRT.
	ERROR	(APR,1,1,OUT)	;TYPE AN ERROR MESSAGE

ALOGRT:	MOVM	C,SAVEA		;PICK UP ABS(BASE).
	FUNCT	ALOG.,<C>	;CALC. LOG(ABS(A)).
	MOVEM	A,C		;RESULTS TO C.
IFE CPU-KI10,<FLTR	0,SAVEB>
IFE CPU-KA10,<FUNCT	FLOAT.,<SAVEB>	;MAKE EXP. A FLOATING
>
	FMPRM	A,C		;CALC. B*ALOG(ABS(A)).
	FUNCT	EXP.,<C>		;FIND EXP. OF THIS.
	JRST	OUT2		;GO AND TYPE ERROR MESSAGE.

MININF:	HRLOI	B,377777	;SET EXP = +INFINITY.
	PUSHJ	P,FEXP2		;GO TO MAIN ROUTINE.
	FMPR	A,SAVEA		;ANS. = ANS. TIMES A.
	JFCL	OVER		;GO TO OVER IF OVERFLOW.
	JRST	INV		;OTHERWISE, GO TO INV.


SAVEA:	0			;TEMP FOR A.
SAVEB:	0			;TEMP FOR B.
SAVEC:	0			;TEMP FOR C.

	LIT
	PRGEND
$PAGE	EXP.	 FLOATING POINT SINGLE PRECISION EXPONENTIAL

;FLOATING POINT SINGLE PRECISION EXPONENTIAL FUNCTION
;IF X<=-89.415..., THE PROGRAM RETURNS ZERO AS THE ANSWER
;IF X>=88.029..., THE PROGRAM RETURNS 377777777777 AS THE ANSWER
;THE RANGE OF THE ARGUMENT IS REDUCED AS FOLLOWS:
;EXP(X) = 2**(X*LOG(E)BASE2) = 2**(M+F)
;WHERE M IS AN INTEGER AND F IS A FRACTION
;2**M IS CALCULATED BY ALGEBRAICALLY ADDING M TO THE EXPONENT
;OF THE RESULT OF 2**F. 2**F IS CALCULATED AS

;2**F = 2(0.5+F(A+B*F^2 - F-C(F^2 + D)**-1)**-1

;THE ROUTINE HAS THE FOLLOWING CALLING SEQUENCE:
;	JSA	Q, EXP
;	EXP	ARG
;THE ANSWER IS RETURNED IN ACCUMULATOR A

	SEARCH	RTFOR



	HELLO	(EXP,.)		;[235] ENTRY TO EXPONENTIAL ROUTINE
	MOVE	B,@(Q)		;PICK UP THE ARGUMENT IN B
	CAMGE	B,E77		;IS EXP. < -89.41...?
	JRST	OUT2		;YES, GO TO EXIT.
	CAMG	B,E7		;IS EXP. > +88.029...?
	JRST	EXP1		;GO TO STANDARD ALGORITHM.
	ERROR	(APR,5,1,.+1)	;TYPE AN ERROR MESSAGE
	HRLOI	A, 377777	;GET LARGEST FLOATING NUMBER
	GOODBY	(1)	;RETURN

OUT2:	ERROR	(APR,7,1,.+1)	;ERROR MESSAGE
	MOVEI	A,0		;ANSWER IS 0.
	GOODBY	(1)	;RETURN

EXP1:	MOVEM	C, ES1		;SAVE ACCUMULATOR C
	MOVEM	D, ES3		;SAVE ACCUMULATOR D
	SETZM	ES2		;INITIALIZE ES2
	MULI	B, 400		;SEPARATE FRACTION AND EXPONENT
	TSC	B, B		;GET A POSITIVE EXPONENT
	MUL	C, E5		;FIXED POINT MULTIPLY BY LOG2(E)
	ASHC	C, -242(B)	;SEPARATE FRACTION AND INTEGER
	AOSG	C		;ALGORITHM CALLS FOR MULT. BY 2
	AOS	C		;ADJUST IF FRACTION WAS NEGATIVE
	HRRM	C, EX1		;SAVE FOR FUTURE SCALING
	JUMPG	D,ASHH		;GO AHEAD IF ARG > 0.
	TRNN	D,377		;ARE ALL THESE BITS 0?
	JRST	ASHH		;YES, GO AHEAD.
	ADDI	D,200		;NO, FIX UP.
ASHH:	ASH	D, -10		;MAKE ROOM FOR EXPONENT
	TLC	D, 200000	;PUT 200 IN EXPONENT BITS
	FADB	D, ES2		;NORMALIZE, RESULTS TO D AND ES2
	FMP	D, D		;FORM X^2
	MOVE	A, E2		;GET FIRST CONSTANT
	FMP	A, D		;E2*X^2 IN A
	FAD	D, E4		;ADD E4 TO RESULTS IN D
	MOVE	B, E3		;PICK UP E3
	FDV	B, D		;CALCULATE E3/(F^2 + E4)
	FSB	A, B		;E2*F^2-E3(F^2 + E4)**-1
	MOVE	C, ES2		;GET F AGAIN
	FSB	A, C		;SUBTRACT FROM PARTIAL SUM
	FAD	A, E1		;ADD IN E1
	FDVM	C, A		;DIVIDE BY F
	FAD	A, E6		;ADD 0.5
EX1:	FSC	A, 0		;SCALE THE RESULTS
	MOVE	C, ES1		;RESTORE ACCUMULATOR C
	MOVE	D, ES3		;RESTORE ACCUMULATOR D
	GOODBY	(1)	;RETURN

E1:	204476430062		;9.95459578
E2:	174433723400		;0.03465735903
E3:	212464770715		;617.97226953
E4:	207535527022		;87.417497202
E5:	270524354513		;LOG(E), BASE 2
E6:	0.5
E7:	207540074636		;88.029...
E77:	570232254037		;-89.415986
ES1:	0
ES2:	0
ES3:	0

	LIT
	PRGEND
$PAGE	ALOG.	 LOG ROUTINES

;FLOATING POINT SINGLE PRECISION LOGARITHM FUNCTION
;LOG(ABSF(X)) IS CALCULATED BY THE SUBROUTINE, AND AN
;ARGUMENT OF ZERO IS RETURNED AS MINUS INFINITY.

;ALOG IS THE ENTRY POINT FOR LOGE(X), AND
;ALOG10 IS THE ENTRY POINT FOR LOG10(X).
;FOR LOGE(X), THE ALGORITHM IS:
;	LOGE(X) = (I + LOG2(F))*LOGE(2)
;	WHERE X = (F/2)*2^(I+1), AND LOG2(F) IS GIVEN BY
;	LOG2(F) = C1*Z + C3*Z^3 + C5*Z^5 - 1/2
;	AND Z = (F-SQRT(2))/(F+SQRT(2))
;FOR LOG10(X), THE ALGORITHM IS:
;	LOG10(X) = LOGE(X)*LOG10(E)

;THE CALLING SEQUENCE FOR THE ROUTINE IS AS FOLLOWS:
;	JSA	Q, ALOG OR ALOG10
;	EXP	ARG
;THE ANSWER IS RETURNED IN ACCUMULATOR A

	SEARCH	RTFOR

	HELLO	(ALG10.,ALOG10)	;[235] ENTRY TO LOG TO THE BASE 10 ROUTINE.
	MOVE	0,@(16)		;GET /X/ IN AC 0.
	JUMPE	0,LZERO		;CHECK FOR ZERO ARG.
	MOVEM	0,TEMP		;ARG TO LOC NE 0 OR 1.
	FUNCT	ALOG.,<TEMP>		;CALC THE LOG TO THE
	FMPR	0,LOG10A	;MULTIPLY IT BY LOG10(E).
	GOODBY	(1)	;RETURN

LOG10A:	177674557305
TEMP:	0

	HELLO	(ALOG,.)	;[235] ENTRY TO LOG TO THE BASE E ROUTINE.
	MOVE	A, @(Q)		;GET ABSF(X)
	JUMPG	A,ALOGOK	;ARG IS GREATER THAN 0
	JUMPE	A, LZERO	;CHECK FOR ZERO ARGUMENT
	ERROR	(LIB,11,2,[ASCIZ /ATTEMPT TO TAKE LOG OF NEGATIVE ARG/])
	MOVM	A,@(Q)		;GET ABSF(X)
ALOGOK:	CAMN	A, ONE		;CHECK FOR 1.0 ARGUMENT
	JRST	ZERANS		;IT IS 1.0 RETURN ZERO ANS.
	ASHC	A, -33		;SEPARATE FRACTION FROM EXPONENT
	ADDI	A, 211000	;FLOAT THE EXPONENT AND MULT. BY 2
	MOVSM	A, LS		;NUMBER NOW IN CORRECT FL. FORMAT
	MOVSI	A, 567377	;SET UP -401.0 IN A
	FADM	A, LS		;SUBTRACT 401 FROM EXP.*2
	ASH	B, -10		;SHIFT FRACTION FOR FLOATING
	TLC	B, 200000	;FLOAT THE FRACTION PART
	FAD	B, L1		;B = B-SQRT(2.0)/2.0
	MOVE	A, B		;PUT RESULTS IN A
	FAD	A, L2		;A = A+SQRT(2.0)
	FDV	B, A		;B = B/A
	MOVEM	B, LZ		;STORE NEW VARIABLE IN LZ
	FMP	B, B		;CALCULATE Z^2
	MOVE	A, L3		;PICK UP FIRST CONSTANT
	FMP	A, B		;MULTIPLY BY Z^2
	FAD	A, L4		;ADD IN NEXT CONSTANT
	FMP	A, B		;MULTIPLY BY Z^2
	FAD	A, L5		;ADD IN NEXT CONSTANT
	FMP	A, LZ		;MULTIPLY BY Z
	FAD	A, LS		;ADD IN EXPONENT TO FORM LOG2(X)
	FMP	A, L7		;MULTIPLY TO FORM LOGE(X)
	GOODBY	(1)	;RETURN
LZERO:	ERROR	(APR,5,1,.+1)	;ERROR MESSAGE
	MOVE	A,MIFI		;PICK UP MINUS INFINITY
	GOODBY	(1)	;RETURN
ZERANS:	MOVEI	A, 0		;MAKE ANSWER ZERO
	GOODBY	(1)	;RETURN

;CONSTANTS

ONE:	201400000000
L1:	577225754146		;-0.707106781187
L2:	201552023632		;1.414213562374
L3:	200462532521		;0.5989786496
L4:	200754213604		;0.9614706323
L5:	202561251002		;2.8853912903
L7:	200542710300		;0.69314718056
MIFI:	400000000001		;LARGEST NEGATIVE FLOATING NUMBER

LS:	0
LZ:	0

	PRGEND
$PAGE	SIN.	 SIN AND COSINE ROUTINES

;FLOATING POINT SINGLE PRECISION SINE AND COSINE FUNCTION

;COS CALLS SIN TO CALCULATE SIN (PI/2+X)

;THIS ROUTINE CALCULATES SINES AFTER REDUCING THE ARGUMENT TO
;THE FIRST QUADRANT AND CHECKING THE OVERFLOW BITS TO DETERMINE
;THE QUADRANT OF THE ORIGINAL ARGUMENT.
;000 - 1ST QUADRANT
;001 - 2ND QUADRANT
;010 - 3RD QUADRANT
;011 - 4TH QUADRANT
;THE ALGORITHM USES A MODIFIED TAYLOR SERIES TO CALCULATE 
;THE SINE OF THE NORMALIZED ARGUMENT.

;THE ROUTINES ARE CALLED IN THE FOLLOWING MANNER:
;	JSA	Q,SIN		(OR COS,SIND, OR COSD)
;	EXP	ARG
;THE ANSWER IS RETURNED IN ACCUMULATOR A

	SEARCH	RTFOR
	HELLO	(COS,.)		;[235] ENTRY TO COSINE RADIANS ROUTINE.
	MOVE	B,@(Q)		;PICK UP THE ARG.
	FADR	B,PIOT		;ADD PI/2.
	JRST	S1		;ENTER SINE ROUTINE.


	HELLO	(SIN,.)		;[235] ENTRY TO SINE RADIANS ROUTINE.
	MOVE	B,@(Q)		;PICK UP THE ARG.
S1:	MOVEM	B,SX		;SAVE THE ARG.
	MOVMS	B		;GET ABS OF ARG.
	CAMG	B,SP2		;SIN(X)=X IF X<2^-9.
	JRST	S3A		;EXIT WITH ARG. IN A.
	MOVEM	C,SC		;SAVE AC C.
	FDV	B,PIOT		;DIVIDE X BY PI/2.
	CAMG	B,ONE		;IS X/(PI/2) < 1.0 ?
	JRST	S2		;YES,ARG IN 1ST QUADRANT ALREADY.
	MULI	B,400		;NO,SEPARATE FRACTION AND EXP.
	LSH	C,-202(B)	;GET X MODULO 2PI.
	TLZ	C,(1B0)		;SUPRESS ERROR MESSAGE FROM OVTRAP.
	MOVEI	B,200		;PREPARE FLOATING FRACTION.
	ROT	C,3		;SAVE THREE BITS TO DETERMINE QUADRANT.
	LSHC	B,33		;ARGUMENT NOW IN THE RANGE (-1,1).
	FAD	B,SP3		;NORMALIZE THE ARGUMENT.
	JUMPE	C,S2		;REDUCED TO 1ST QUAD IF BITS 000.
	TLCE	C,1000		;SUBTRACT 1.0 FROM ARG IF BITS ARE
	FSB	B,ONE		;001 OR 011.
	TLCE	C,3000		;CHECK FOR FIRST QUADRANT, 001.
	TLNN	C,3000		;CHECK FOR THIRD QUADRANT, 010.
	MOVNS	B		;001,010.
S2:	SKIPGE	SX		;CHECK SIGN OF ORIGINAL ARG.
	MOVNS	B		;SIN(-X)=-SIN(X).
	MOVEM	B,SX		;STORE REDUCED ARG.
	FMPR	B,B		;CALCULATE X^X
	MOVE	A,SC9		;GET 1ST CONSTANT.
	FMP	A,B		;MULTIPLY BY X^2
	FAD	A,SC7		;ADD IN NEXT CONSTANT.
	FMP	A,B		;MULTIPLY BY X^2.
	FAD	A,SC5		;ADD IN NEXT CONSTANT.
	FMP	A,B		;MULTIPLY BY X^2.
	FAD	A,SC3		;ADD IN NEXT CONSTANT.
	FMP	A,B		;MULTIPLY BY X^2.
	FAD	A,PIOT		;ADD IN LAST CONSTANT.
S2B:	FMPR	A,SX		;MULTIPLY BY X.
	SKIPA	C,SC		;RESTORE AC C.
S3A:	MOVE	A,SX		;ANSWER IN X.
	GOODBY	(1)		;EXIT

SC3:	577265210372
SC5:	175506321276
SC7:	606315546346
SC9:	164475536722

SP2:	170000000000
SP3:	0
SX:	0
CD1:	90.0
SCD1:	206712273406
PIOT:	201622077325
SC:	0
ONE:	1.0
	END
    RPS6»