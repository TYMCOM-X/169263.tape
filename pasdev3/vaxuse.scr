$title left 'VAX Pascal Implementation Notes - Multi-use Expressions' left 'Sept. 28, 1979'
$ski 2
Expression tuples in the intermediate form with multiple usages
present special problems for the VAX code generator. 
The method the code generator will use to deal with multi-use
expressions is described in this memo.
$ski
Multi-use expressions can arise in one of two ways.
First, the intermediate form generated by PASS1 produces multiple
references to some expression tuples.
The check operators in particular are likely to do this.
For example, a subscript check tuple and an array indexing tuple
both reference (the same) expression tuples for the base address of the
array and the array index.
There are also a small number of miscellaneous constructs
for which the compiler produces multiply referenced expression tuples.
Dynamic allocation of a flex item will produce multiple uses
of expression tuples for the resulting pointer and for the
upperbound of the flex item.
Second, the code generator may locally use a single expression result
(or its address) several times.
For example, the base address of a string may be used both to load
the length of the string and also to form a string move parameter.
$ski
The code generator uses a routine called FETCH to make most
expressions addressible.
FETCH is a function which takes an expression tuple as a
parameter and returns an 'address descriptor' describing the
location of the result.
When the result of an expression is 'used', the corresponding
address descriptor is freed.
Freeing an address descriptor essentially means freeing any
registers used in the address.
Multi-use expressions present two problems.
First, the initial use of the expression value will free
any registers used by the corresponding address descriptor,
even though uses remain.
Second, when FETCH is called for a subsequent use of the
expression value, it must have some way of knowing that
the expression has been previously evaluated and some means of
knowing where the resulting value is stored.
$ski
FETCH will track multi-use expressions in the following way.
Each expression tuple has a pointer valued field with field
name RESULT.
On entry to FETCH, the RESULT field on the expression tuple
being fetched will be examined.
If RESULT is not NIL, then the expression has been previously
fetched and RESULT points to an address descriptor for the
result.
So if RESULT is not NIL, the address descriptor is simply copied
into FETCH's return value.
Usage counts will be associated with all allocated registers.
If all the registers used in the address descriptor have usage
counts of one, then the address descriptor on the heap may
be DISPOSEd.
Immediately before FETCH returns, it examines the usage count
field of the expression tuple.  
If it is greater than one and the RESULT field is NIL, then
a copy of the address descriptor being returned is made on the
heap and RESULT is set to point to the heap copy.
Any registers used by the address descriptors have their
usage counts set to the usage count of the corresponding
expression tuple.
$ski
This mechanism will handle multi-use expressions generated by the
compiler.
Expression values (or their addresses) which the code
generator uses more than once will require some additional
utilities.
An address descriptor which will be used multiple times locally
(an address descriptor is 'used' if and only if it is freed)
should be 'duplicated' via a utility routine called
DUPLICATE_ADDR.
DUPLICATE_ADDR is passed an address descriptor.
It returns the same address descriptor after incrementing
the usage counts on any registers used by the address descriptor.
Note that the register allocation routine will set the usage
count of a register allocated to one.
The register deallocation routine will decrement the usage
count and mark the register as free if the count drops to zero.
The caller of DUPLICATE_ADDR should insure that the address
descriptor is freed once for the orginal use and once for each
call to DUPLICATE_ADDR.
$ski
Several caveats should be noted concerning the above conventions.
First, the code generator cannot assume that an arbitrary value
in a register may be destroyed.
Even if a value is known to be in a register, then if a use of the
register will alter its contents, the register should be explicitly
deallocated and a result register explicitly allocated.
This will insure the registers contents will not be destroyed
if the value has remaining uses.
Second, two classes of utilities for loading a value into a
register will be available.
The first class will copy a value already in a register to a new
register if the register has remaining uses.
The second class will simply return if the value is already in
a register.
The first class of load routines should be used if the subsequent
use of the value is destructive.
Finally routines which take address descriptors as parameters should
be clearly classified into one of two categories:
those which use (result in a free of) the address descriptor and
those which do not.
$ski
String valued expressions present an additional problem.
A simple address descriptor is not sufficient to describe the
result of a string valued expression evaluation.
In general, the length of the string expression must be known
as well.
The code generator will evaluate string valued expressions with 
a separate routine, FETCH_STRING.
This routine will return a 'string descriptor' rather than an
address descriptor.
The string descriptor will contain address descriptors
for both the base address and the length as well as additional
information relevant to the string routines.
FETCH_STRING will contain logic for handling multi-use expressions
analogous to that contained in FETCH.
However, it will store a string descriptor on the heap rather than
an address descriptor whenever a multi-use expression is passed in.
$ski
Finally, note that &all& expressions should be evaluated by either
FETCH or FETCH_STRING in order to guarantee proper handling of
multi-use expression values.
FETCH_STRING must be used if the expression is string valued;
FETCH must be used otherwise.
$ski 2
VAXUSE.SCR[52250,261]
