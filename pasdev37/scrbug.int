$TOP 4


$LENGTH 48
$MARGIN 10
$WIDTH 75
$TITLE LEFT 'MDSI Pascal M68000 Runtime Specification                  Page \' LEFT 'December 4, 1981' 
$TABS 09,17,25,33,41,49,57,65
$NUMBER off
$SKIP 0

$TITLE ''
$PAGE
$CENTER
$SKIP 9
MDSI Pascal Motorola 68000
$SKIP 1
Runtime Specification
$SKIP 16
$JUSTIFY LEFT
$PARAGRAPH 0
December 4, 1981
$PARAGRAPH 0
\
$PARAGRAPH 0
\
$PARAGRAPH 0
\
$TITLE LEFT 'MDSI Pascal M68000 Runtime Specification                  Page \' LEFT 'December 4, 1981' 
$NUMBER 1
$JUSTIFY
$PAGE
$PARAGRAPH 0
$FOOTNOTES   LEFT  'Introduction'
$SKIP 4
$NEED 5
$SECTION
$ENTRY ''
$ENTRY '^#	INTRODUCTION	\'
$ENTRY ''
^#\\&Introduction&
$SKIP 2
$PARAGRAPH 0
This document describes the overall design and the interface
specifications for the runtime routine package for the
Motorola 68000 implementation of MDSI Pascal.
Implementors and maintainers of the runtime should also see
the document ^UMDSI Pascal M68000 Runtime Conventions And Standards|U.
The I/O runtime is described in the document ^UMC68000 Pascal
I/O Runtime Notes|U.
$PARAGRAPH 0
$FOOTNOTES   LEFT  'Procedure Calling Conventions'
$SKIP 4
$NEED 5
$SECTION
$ENTRY ''
$ENTRY '^#	PROCEDURE CALLING CONVENTIONS	\'
$ENTRY ''
^#\\&Procedure Calling Conventions&
$SKIP 2
$PARAGRAPH 0
This section describes the stack frame format, parameter passing
conventions and procedure calling and returning code.
$LEVEL +1
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	Stack Frame Format	\'
^#\Stack Frame Format
$SKIP 2
$PARAGRAPH 0
The format of a stack frame is shown in the figure below.
Most of the fields are self-explanatory; however, the
remaining subsections on procedure calling conventions
describe the contents and maintenance of the stack in
more detail.
Register A6 is reserved for use as the frame pointer.
In non-quick routines, register A4 is reserved for use
as an argument block pointer.
$SKIP 1 $NEED 21  $IND +0
$VERBATIM 
	|			|	    ^
	+-----------------------+	    |
	|	 locals		|<-- SP	    |
	|	  and		|         lower
	|	 temps		|       addresses
	|			| -8(A6)
	+-----------------------+
	| copy of arg ptr (A4)	| -4(A6)
	+-----------------------+
	|	old A6		|<-- A6
	+-----------------------+
	|	HBT addr	|  4(A6)
	+-----------------------+
	|    entry block addr	|  8(A6)
	+-----------------------+
	|    return address	| 12(A6)
	+-----------------------+
	|   [static link]	| 16(A6)    (only if lvl > 1)
	+-----------------------+
	|	caller's	| 16(A6) or 20(A6)
	|	 frame		|
$JUS
$IND -0
$SKIP 1
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	Parameter Passing	\'
^#\Parameter Passing
$SKIP 2
$PARAGRAPH 0
This section describes the argument block and the conventions used in
passing parameters to Pascal routines.
$LEVEL +1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   The Argument Block	\'
^#\The Argument Block
$SKIP 1 
$PARAGRAPH 0
Addresses in an argument block occupy four bytes and are
word aligned.
Flex upperbound words for strings occupy two bytes and are
word aligned.
Flex upperbound words for arrays occupy four bytes and are
word aligned.
A parameter passed by value has the same storage allocation
and alignment as a simple variable of the same type.
Thus arguments occupying a single byte ^Umay|U have to be followed by
a padding byte.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   VAR Parameters	\'
^#\VAR Parameters
$SKIP 1 
$PARAGRAPH 0
All VAR parameters are passed by address.
If the type of the formal is a flexible type, then the
address is preceded by an upperbound word or longword.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Value Parameters	\'
^#\Value Parameters
$SKIP 1 
$PARAGRAPH 0
All strings, records, arrays and sets are passed by address.
If the type of the formal is a flexible type, then the address
is preceded by an upperbound word or longword.
All other value parameters are passed by value.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Function Return Values	\'
^#\Function Return Values
$SKIP 1 
$PARAGRAPH 0
Function return values are always treated as an implicit
zeroth parameter.
If the return type would be passed by address if it was the
type of a formal value parameter, then an address is passed
in the argument block.
If the return type would be passed by value if it was the
type of a formal value parameter, then space is simply
reserved in the argument block.
In essence, the function return value is treated as an uninitialized
value parameter.

$LEVEL -1
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	Calling A Non-quick Routine	\'
^#\Calling A Non-quick Routine
$SKIP 2
$PARAGRAPH 0
This section describes the code used to call, enter and exit
a non-quick routine.
$LEVEL +1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Calling Code	\'
^#\Calling Code
$SKIP 1 
$PARAGRAPH 0
At the point of the call, the caller constructs an argument
block in a static temp in the caller's frame.
The caller passes the callee the address of the argument
block in register A4.
Immediately before transfering control to the callee, the
caller saves any registers which are in use.
The code which appears at the call point is described in the figure
below:
$SKIP 1 $NEED 6  $IND +5
$VERBATIM 
LEA	K1(A6),A4		; set up argument pointer
<code to move args to static temp>
MOVEM.L	<regs in use>,-(SP)	; excluding WITH regs and A4
[ <code to push static link> ]	; only if callee's level > 1
JSR	<callee's entry point>
<code to restore regs>		; includes WITH regs
$JUS
$IND -5
$SKIP 1
The load effective address instruction (LEA) loads the argument
pointer register with the address of the first byte
 of the static temp which will
contain the argument block.
(If the first argument is an uninitialized function return value,
then A4 may be initialized to the address of the second argument.)
Note that ^Uif|U the caller is using A4 as an argument pointer for its
own arguments, A4 need not be saved
before the LEA instruction
 because the caller's frame
contains a copy of the caller's argument pointer.
Next, the arguments are evaluated and stored in the argument block.
Since A4 is already pointing to the argument block, the arguments
may be efficiently moved to the argument block using "(A4)+"
as the destination's address mode.
An "ADDQ.L\\\#1,A4" instruction may be used to skip any unused bytes
in the argument block.
The last move should use the addressing mode "(A4)";
this will leave the argument pointer pointing at the last
argument of the block.
The callee will then address the arguments as zero or negative offsets
from A4.
If a function call appears as an actual argument, then
A4 must be saved before evaluating the functions arguments
and restored afterwards.
If the caller's arguments must be referenced to evaluate a
parameter, then the caller's argument pointer must be loaded into
one of A0 through A4 from the copy in the caller's stack frame.
The argument pointer need not be initialized for parameterless
subroutines.
$SKIP 1
$NEED 2  $PARAGRAPH 0
Next any registers in use, other than A4 or WITH registers,
are saved by pushing them onto the stack.
$SKIP 1
$NEED 2  $PARAGRAPH 0
If the lexic level of the callee is greater than one, then
the callee's static link is pushed onto the stack.
The static link field of the stack frame is not present for
routines at lexic level zero or one.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The callee is then called with a JSR instruction.
Upon return the registers saved before the call,
possibly the caller's argument pointer, 
 and any active
WITH registers are restored.
The contents of A4 must be explicitly restored after the call in one
circumstance only.
If, before the LEA instruction, A4 did not contain the caller's argument
pointer, then A4 must have been saved before the LEA and must be restored
again after the JSR.
This can only occur when the call appears in an actual argument list.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Entry Code	\'
^#\Entry Code
$SKIP 1 
$PARAGRAPH 0
The following code and data appears at the routine's entry point:
$SKIP 1 $NEED 3  $IND +5
$VERBATIM 
JSR	M.ENTRY		; call runtime entry routine
<stack frame size>
<debug addr>
$JUS
$IND -5
$SKIP 1

"M.ENTRY" is one of two routine entry runtime routines.
The second routine, "M.CK_ENTRY", is used when the user specifies
that stack overflow checking should be done upon procedure
entry.
The stack frame size specifies the number of bytes above the
saved copy of A4 which should be allocated for the frame.
The size specification occupies four bytes.
The next four bytes are occupied by the address of a block of
information used by the debugger.
The eight bytes of data present at the entry point are known
as the ^Uroutine entry block|U.
$SKIP 1
$NEED 2  $PARAGRAPH 0
One possible coding of the subroutine entry runtime routine
"M.ENTRY" is shown below:
$SKIP 1 $NEED 8  $IND +5
$VERBATIM 
M.ENTRY:
	MOVEA.L	(SP),A0		; set ptr to entry block
	CLR.L	-(SP)		; clear HBT addr
	LINK	A6,#0		; save old frame ptr and
				;    set new one
	MOVE.L	A4,-(SP)	; save argument ptr
	SUBA.L	(A0),SP		; Alloc rest of frame
	JMP	8(A0)		; return
$JUS
$IND -5
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Return Code	\'
^#\Return Code
$SKIP 1 
$PARAGRAPH 0
The only code which appears at the return point is a
JMP to a subroutine exit runtime routine.
Two exit routines are used;
"M.L1_RET" is used to return from level one routines;
"M.L2_RET" is used to return from routines at lexic level two 
or greater.
A possible coding of the procedure exit routines is shown
below.
The optional instruction would be present in "M.L2_RET" only.
$SKIP 1 $NEED 7  $IND +5
$VERBATIM 
SF.RET	EQU	12		; offset of return addr
SF.AP	EQU	-4		; offset of arg ptr copy

M.Lx_RET:
	UNLK	A6		; cut stack back some and
				;    restore old frame ptr
	MOVEA.L	SF.AP(A6),A4	; Restore old arg ptr
	LEA	SF.RET-4(SP),SP	; Cut stack back to ret addr
      [ MOVE.L	(SP)+,(SP) ]	; only in "M.L2_RET"
	RTS			; return to caller
$JUS
$IND -5
$SKIP 1
$LEVEL -1
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	Calling A Quick Routine	\'
^#\Calling A Quick Routine
$SKIP 2
$PARAGRAPH 0
This section describes the code at the point of call, at the entry
point and at the exit point of a quick-blocked routine.
$LEVEL +1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Calling Code	\'
^#\Calling Code
$SKIP 1 
$PARAGRAPH 0
The following code appears at the point of a call to a quick routine:
$SKIP 1 $NEED 4  $IND +5
$VERBATIM 
<move args to argument block>
MOVEM.L	<regs in use>,K(A6)
JSR	<callee's entry point addr>
<code to restore regs>
$JUS
$IND -5
$SKIP 1
Unlike non-quick routines, quick routines do not use an argument
block pointer register.
Instead, the argument block is allocated at a fixed offset in
the frame of the owner of the callee.
The argument block is allocated in that portion of the frame 
corresponding to the routine which is the immediate dominator of the callee.
The space allocated for the argument block is dedicated to that purpose and
is allocated as long as the immediate dominator is active, i.e.,
the argument block is treated just like the local variables of
the immediate dominator.
$SKI
[? The argument block could also be allocated in that portion of the
owner's frame corresponding to the owner.
This would be less space efficient (in stack space), but would
be easier to implement. ?]
$SKI
$SKIP 1
$NEED 2  $PARAGRAPH 0
The calling sequence begins with code to move the arguments
to the argument block.
Next any registers currently in use, other than WITH registers and
A4, are saved.
The callee is then called with a JSR instruction.
After the point of the call, WITH registers and any registers
saved before the point of the call are restored.
(If registers other than WITH registers must be saved before the call,
then a space optimization may be achieved by saving the WITH
registers before the call also.
This would permit all registers to be restored after the call with 
a single instruction.
This could be done for calls to non-quick routines also.)
$SKIP 1
$NEED 2  $PARAGRAPH 0
Quick routines save A4 upon entry and restore it before returning.
Thus A4 need never be saved before
or restored after a call to a quick routine.
$SKIP 1
$NEED 2  $PARAGRAPH 0
Quick routines will only use A4 when calling non-quick routines.
They may not use A4 as a general purpose address register 
because the code generator has no general register spilling
mechanism.
Such a mechanism would be necessary if A4 was in use as a general
purpose register when a non-quick routine was to be called.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Entry Code	\'
^#\Entry Code
$SKIP 1 
$PARAGRAPH 0
Upon entry to a quick routine, register A4 must be saved.
Note that a code generator created local variable (i.e., a temp
whose lifetime is the entire duration of the
subroutine's activation) must be used to save the copy of A4.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Return Code	\'
^#\Return Code
$SKIP 1 
$PARAGRAPH 0
At an exit point, A4 must be restored.
After the restore instruction, an RTS instruction is used
to return to the caller.
Note that all dynamic temps must be deallocated at
the time of the return.
$LEVEL -1
$LEVEL -1
$PARAGRAPH 0
$FOOTNOTES   LEFT  'Memory Organization'
$SKIP 4
$NEED 5
$SECTION
$ENTRY ''
$ENTRY '^#	MEMORY ORGANIZATION	\'
$ENTRY ''
^#\\&Memory Organization&
$SKIP 2
$PARAGRAPH 0
This section describes the layout of the data segment and the usage
of the "sections" which form the basis of the linker's memory allocation.
$LEVEL +1
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	Section Allocation	\'
^#\Section Allocation
$SKIP 2
$PARAGRAPH 0
All code and data must be generated in a section numbered from zero
to fifteen.
The linker groups sections into at least one and at most four
"segments".
Compiler generated code and constants are generated in section ten.
Runtime code and constants are generated in section nine.
^CCompiler generated and|C
runtime read/write data are placed in section one.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The grouping of sections into segments is determined at link time.
However, the linker's default action, given the above section
allocations, will be to place the runtime and compiler generated
code and constants into a single read-only segment named "SEG1".
By default, the runtime and compiler generated read/write data
will be placed in a read/write segment named "SEG0".
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	^CStatic Storage	\'
^#\^CStatic Storage
$SKIP 2
$PARAGRAPH 0
The approach taken to code sharing on an unmapped system
prohibits reserving any read/write data at compile, assembly
or link time.
The data segment for static storage, the stack and the heap
will be created at execution time by the Pascal
initialization runtime routine.
The size of the segment created will be the sum of the
size of the "static" storage reserved in the image file
and the size of the stack and the initial heap
(as described below, the stack and heap sizes are the
values of certain global symbols).
$SKIP 1
$NEED 2  $PARAGRAPH 0
True static storage is prohibited by this scheme.
However, both the Pascal programmer and the runtime
will be permitted to declare "static" storage using
the following approach.
Static storage will be generated at compile or
assembly time in the normal fashion.
However, all references in the code to static storage will
be made as displacements from a dedicated static storage
pointer register, A5.
After linking the image file will be modified to inhibit
the loader from allocating and initializing a data segment.
The Pascal initialization routine will load the initial
contents of the data segment from the image file
after it has dynamically created the data segment.
This scheme also requires that the data segment be linked
at a fixed starting address; 
the value zero will be used as the fixed base.
In order to permit 64K bytes of static, register A5 will point
to 32768 bytes passed the base of the static storage area.
This will require that a static variable "FOO" be referenced
as "FOO-32768(A5)" rather than simply as "FOO(A5)".
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	Data Section Layout	\'
^#\Data Section Layout
$SKIP 2
$PARAGRAPH 0
The layout of the data segment created by the initialization
routine is shown below.
$SKIP 1 $NEED 15  $IND +5
$VERBATIM 
	+-----------------------+
	|	    ^		|  high addresses
	|	    |		|
	|	    |		|
	|      initial heap	|
	+-----------------------+
	|	  stack		|
	|	    |		|
	|	    |		|
	|	    v		|
	+-----------------------+
	|			|
	|     static storage	|
	|			|
	+-----------------------+  low addresses
$JUS
$IND -5
$SKIP 1
The stack will have a default size of 8192 bytes.
A user may explicitly set the stack size by using the
compiler's STORAGE option.
If the user explicitly sets the stack size via the STORAGE option,
then the compiler must emit a global definition for the symbol
M.STKSIZ, where the the value of the symbol is the 
(non-relocatable) user specified stack size.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The default size of the initial heap will be 32K bytes.
This value may be overridden at link time by defining
the symbol H.INISIZ, giving it as a value the desired
initial heap size.
The total heap size may expand and contract at execution
time, see the section on heap management for details.
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	Stack Overflow Checking	\'
^#\Stack Overflow Checking
$SKIP 2
$PARAGRAPH 0
The area reserved for the stack is fixed in size.
A stack overflow may occur at routine entry and whenever
a dynamic temp is allocated.
A compiler block option will determine if stack overflow
checking is done at these times.
A new CHECK suboption, the STACK suboption, will be used fhis purpose.
As with other CHECK options the default value will be
checking enabled.|C
$LEVEL -1
$PARAGRAPH 0
$FOOTNOTES   LEFT  'Runtime Calling Conventions'
$SKIP 4
$NEED 5
$SECTION
$ENTRY ''
$ENTRY '^#	RUNTIME CALLING CONVENTIONS	\'
$ENTRY ''
^#\\&Runtime Calling Conventions&
$SKIP 2
$PARAGRAPH 0
This section describes the runtime calling conventions
relevant to the caller.
All the runtime routines are called with a JSR instruction;
the effective address field of the instruction is a 32 bit
direct address.
All registers except those used to return results are preserved.
Any arguments pushed onto the stack are popped off before the
runtime routine returns.
However, some runtime routines may return a value on top
of the stack.
Two general approaches are used for parameter passing.
Each of these schemes is described below.
These descriptions are inteneded only to present the
general approaches used to pass parameters to the runtime;
the descriptions of the individual routines must be consulted
for specifics.
$LEVEL +1
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	The Standard Conventions	\'
^#\The Standard Conventions
$SKIP 2
$PARAGRAPH 0
The parameter passing conventions described in this section
are used in most cases.
Input and input/output parameters are pushed onto the
stack before the call to the runtime routine.
The parameters may be passed either by value or by address.
It is important to note that if more than one parameter is
passed via the stack, then the code generator must evaluate
all the parameters before pushing any of them onto the stack.
This is necessary to avoid having a dynamic temp allocated
on the stack between two of the parameters.
$SKIP 1
$NEED 2  $PARAGRAPH 0
Output parameters (return values) may be handled in one of three
ways.
First, the address of the location to receive the result may
be pushed onto the stack before the call.
$SKIP 1
$NEED 2  $PARAGRAPH 0
In the second approach, the value is returned in a register.
Since none of the registers are volatile and the code
generator controls register allocation for the in-line code,
for a given function several entry points will be provided which
perform the same function but return the result in different
registers.
Typically, a given function will have entry points for
returning the result in some subset of either the data
or address registers and an 'escape' entry point which
returns the result in a memory location whose
address is passed in on the stack.
The multiple entry points can be implemented by providing multiple
short wrapper routines for a central routine which actually implements
the given function.
The wrappers would each be placed in a separate object module so
that only the wrappers actually required by a user program
would be pulled from the runtime object library.
This approach would clearly complicate maintainance of the
runtime and should only be used for frequently called
runtime routines.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The third approach is to leave return values on the top of
the stack.
This approach may be appropriate for double precision
math routines.
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	A More Space Efficient Approach	\'
^#\A More Space Efficient Approach
$SKIP 2
$PARAGRAPH 0
The following approach would require less code in-line,
but would require many wrapper routines.
It may be an appropriate technique for very frequently
called runtime routines such as floating point add,
subtract, multiply and divide and integer multiply and
divide, if they require runtime calls.
$SKIP 1
$NEED 2  $PARAGRAPH 0
In this approach, input and input/output parameters as well
as output arguments could be passed in the registers.
As in the second approach to handling output arguments
discussed above, many registers or register combinations
would be made available through the use of multiple
entry points and wrapper routines.
A number of variations are possible.
For example, consider floating point addition.
A set of wrapper routines might be available  
where one operand was in a register and the other
operand was in memory.
The address of the memory operand would be pushed onto the stack
and the result would over write the register operand.
Another possibility would be to have wrappers specific to
two registers.
Both operands would be in registers and the result would
be left in one of the registers.
$LEVEL -1
$PARAGRAPH 0
$FOOTNOTES   LEFT  'Debugging Aids'
$SKIP 4
$NEED 5
$SECTION
$ENTRY ''
$ENTRY '^#	DEBUGGING AIDS	\'
$ENTRY ''
^#\\&Debugging Aids&
$SKIP 2
$PARAGRAPH 0
This section describes the supports necessary for a stack
traceback facility and for the Pascal debugger.
The supports proposed for the debugger represent a fundamentally
different approach to providing the debugger with line number
information.
Rather than adding debugger blocks to the code, all debugging
information, except that required to support a stack traceback,
is generated in a disk file at compile time.
This debug file will also contain the symbol table information
which is present in the ".DEB" file in the DEC10 implementation.
$SKIP 1
$NEED 2  $PARAGRAPH 0
Several other departures from the DEC10 debugger implementation
are also assumed;
however, these changes have a relatively modest impact on the issues discussed
in this section.
These changes include making the DEBUG and QBLOCK options independent.
Another possibility is having the debugger run as a separate process,
i.e., in a separate address space from the program being debugged.
This approach would primarily impact the debugger code rather than
the runtime structures and therefore is not discussed in any detail
in this section.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The approach of placing line number information in the debug file
represents a substantial departure from the approach used on the
DEC10.
There are numerous advantages to this approach;
the major ones are listed below:
$INDENT LEFT +3
$SKIP 1
$SKIP 0   $PARAGRAPH -3
1.\Since a debug compilation would only cost file space,
during development it could be the normal mode of compilation.
This would make recompilation for debugging unnecessary.
$SKIP 0   $PARAGRAPH -3
2.\Debug mode code would execute at the same speed as
non-debug code.
$SKIP 0   $PARAGRAPH -3
3.\If a separate process debugger was also used, then
use of the debugger would not change the memory layout
of user programs.
On the DEC10 compiling in debug mode and linking the debugger in
often completely changes the symptoms of a bug.
$SKIP 0   $PARAGRAPH -3
4.\Since all debugging information is in disk files, a user
program cannot become too large for physical memory when the
debug option is used;
this frequently occurs on the DEC10.
$SKIP 0   $PARAGRAPH -3
5.\If overlays are used, a single area size is appropriate for
both debug and non-debug code.
Again, on the DEC10, overlay area sizes are generally defined
as one size in a development environment and as a second,
smaller size for the production version of the program.
$SKIP 0   $PARAGRAPH -3
6.\If a separate process debugger is used, then the functionality
of the debugger need not be overly restricted by concern with the
size of the debugger.
$INDENT -3
$SKIP 1
$LEVEL +1
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	User Visible Debugger Changes	\'
^#\User Visible Debugger Changes
$SKIP 2
$PARAGRAPH 0
This section describes proposed functional changes which would
be visible to users of the debugger.
The major change would be a restriction on the debugger's single
stepping capability.
Single stepping would only be permitted in code which was
compiled with the debug option.
An attempt to single step while in a non-debug module, or an
attempt to single step into a non-debug subroutine from debug
code, will result in a debugger error message.
$SKIP 1
$NEED 2  $PARAGRAPH 0
Currently, a single step command in non-debug code will cause
execution to resume and continue until the first statement of
a subroutine compiled in debug mode.
The primary use of this feature is in overlaid DEC10 programs,
where it is difficult to set breakpoints in overlays.
Using the scheme proposed here, breakpoints could be set anywhere
in debug mode code, with one restriction.
Any code in a "link management" module would have to be associated
before breakpoints could be set in it.
This restriction seems like a minor one,
with the slight inconvenience of this restriction outweighed by 
the advantages of this approach.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The second user visible change is that the DEBUG and QBLOCK options
would be totally independent.
The debugger would be somewhat restricted in the information
which it could supply when debugging quick routines.
A more detailed discussion of the interaction of debug mode and
quick blocking is given in a later section.
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	Data Structures	\'
^#\Data Structures
$SKIP 2
$PARAGRAPH 0
This section describes the data structures which must be
generated by the compiler to support the debugging tools.
The first subsection discusses data structures generated
in the relocatable object file when either the TRACE or
DEBUG options are used.
The second section describes the contents of the debug file
which is generated when the DEBUG option is used.
$LEVEL +1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Object File Data Structures	\'
^#\Object File Data Structures
$SKIP 1 
$PARAGRAPH 0
Two data structures are generated in the object file.
Both of these data structures are generated in their
entirety if the TRACE option is used (the DEBUG option
must imply the TRACE option).
If the NOTRACE option is used, then neither of
these data structures is generated.
$LEVEL +1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	      The Program Block	\'
^#\The Program Block
$SKIP 1 
$PARAGRAPH 0
One program block is generated for each compilation unit.
The block is generated as the first item in the code area.
The program block layout is shown below.
$SKIP 1 $NEED 10  $IND +5
$VERBATIM 
      31           16 15            0
     +-------+-------+-------+-------+
     |     compilation day/time      |
     +-------+-------+-------+-------+
     |  base address of static data  |
     +-------+-------+-------+-------+
     |  object file name  (6 chars)  |
     |               +---------------+
     |               |
     +-------+-------+
$JUS
$IND -5
$SKIP 1
The compilation day/time is the low order 32 bits of the
DEC10 internal day/time.
The debugger simply considers it an arbitrary bit pattern which
must be matched by a corresponding value in the debug file.
In a debug compilation
the base address is the address of the start of this module's
contribution to the static data area.
In a non-debug compilation this field must be set to zero.
The six character object file name is generated as the final
field.
File names shorter than six characters are padded with null bytes.
The full object file pathname is not stored since the MC68000
compiler will be a cross-compiler.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	      Procedure Blocks	\'
^#\Procedure Blocks
$SKIP 1 
$PARAGRAPH 0
A procedure block is generated before the code of each subroutine.
The routine entry blocks following the JSR at the entry point of each subroutine
contain the address of the procedure block for the routine.
The layout of a procedure block is shown below.
$SKIP 1 $NEED 11  $IND +5
$VERBATIM 
      31           16 15            0
     +-------+-------+-------+-------+
     |     program block address     |
     +-------+-------+-------+-------+
                     | routine table |
                     +-------+-------+
                     |  name length  |
     +-------+-------+-------+-------+
     |       procedure name          |
     |          text ...             |
     +-------+-------+-------+-------+
$JUS
$IND -5
$SKIP 1
The routine table field contains the byte offset from the
start of the routine table (in the debug file) to the routine
table entry corresponding to the subroutine.
Routine tables are discussed in the section describing
the debug file's contents.
This field is zero if the NODEBUG option is used.
$SKI
[? Possible change - move the procedure name to the start
of the block.
This would place the procedure block at a fixed location relative
to the entry point of the routine and thus permit elimination
of the procedure block address in routine entry blocks. ?]
$SKI
$LEVEL -1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Debugger File Data Structures	\'
^#\Debugger File Data Structures
$SKIP 1 
$PARAGRAPH 0
This section describes those data structures which are generated
in the debug file whenever the DEBUG option is used.
The debug file is named using the file name of the object file
and the extension ".PD" (^UP|Uascal ^UD|Uebugger).
Extensions under VERSAdos are limited to two characters;
the extension ".DB" is used for the VERSAdos linker generated
debug file.
$LEVEL +1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	      Overall Layout Of The Debug File	\'
^#\Overall Layout Of The Debug File
$SKIP 1 
$PARAGRAPH 0
The layout of the various tables in the debug file is
shown in the figure below.
This layout is based on two factors.
First, pointers from one data structure within the debug file
to another are stored as byte offsets from the start of the
debug file.
Given the layout shown below, it is assumed that offsets
to the statement lists, the cross reference tables, the
page tables, the file table and the start of the symbol
table may be stored in two bytes.
Second, an attempt has been made to layout the tables
in an order which makes generating the debug file 
as convenient as possible.
$SKIP 1 $NEED 20  $IND +5
$VERBATIM 
     +-----------------------+
     |    header block       |
     +-----------------------+
     |   statement lists     |
     |                       |
     +-----------------------+
     |     page/statement    |
     |    cross reference    |
     |         tables        |
     +-----------------------+
     |      page tables      |
     |                       |
     +-----------------------+
     |      file table       |
     +-----------------------+
     |      symbol table     |
     |                       |
     +-----------------------+
     |    routine table      |
     +-----------------------+
$JUS
$IND -5
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	      The Header Block	\'
^#\The Header Block
$SKIP 1 
$PARAGRAPH 0
The header block contains the file offset of certain tables or
table entries.
In particular, offsets are given for the start of the symbol
table, the file table, the routine table and the symbol table
type nodes for the standard types integer, real, boolean and
character.
As noted above, some of these offsets are assumed to fit in
two bytes;
four bytes are allocated for others.
All offsets are zero-based, byte offsets.
The layout of the header block is shown in the figure below.
$SKIP 1 $NEED 16  $IND +5
$VERBATIM 
                      15            0
                     +---------------+
                     | symtab offset |
                     +---------------+
      31             |file tab offset|
     +---------------+---------------+
     |     routine table offset      |
     +-------------------------------+
     |   integer type node offset    |
     +-------------------------------+
     |     real type node offset     |
     +-------------------------------+
     |     char type node offset     |
     +-------------------------------+
     |  boolean type node offset     |
     +-------------------------------+
$JUS
$IND -5
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	      The File Table	\'
^#\The File Table
$SKIP 1 
$PARAGRAPH 0
One file table is generated for the compilation unit.
The file table has one entry for each source file
for which executable code has been generated.
The last file table entry is followed by a zero word.
The format of an entry is shown below:
$SKIP 1 $NEED 12  $IND +5
$VERBATIM 
      15                    0
     +-----------------------+
     |   page table offset   |
     +-----------------------+
                 | file num  |
     +-----------+-----------+
     |   file name length    |
     +-----------------------+
     |       file name       |
     |        text ...       |
     +-----------------------+
$JUS
$IND -5
$SKIP 1
The page table offset is the offset within the debug file of
the page table corresponding to this file table entry.
The file number is the compiler assigned number of the
source file.
The file name length and text, in Pascal string format,
is the final entry.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	      Page Tables	\'
^#\Page Tables
$SKIP 1 
$PARAGRAPH 0
One page table exists for each file table entry.
Each page table has one entry for each page, within the corresponding
file, for which executable code has been generated.
Each page table is terminated by a zero word.
The format of a page table entry is shown below.
$SKIP 1 $NEED 13  $IND +5
$VERBATIM 
      15                    0
     +-----------------------+
     |    xref table offset  |
     +-----------------------+
     |      page number      |
     +-----------------------+
     |file table entry offset|
     +-----------------------+
     | page ID string length |
     +-----------------------+
     |     page ID string    |
     |         text...       |
     +-----------------------+
$JUS
$IND -5
$SKIP 1
The "xref table offset" field is the offset within the
debug file of the page/statement cross reference table
for the page.
The page number is the compiler assigned page number of
the corresponding source file page.
The file table entry offset is the debug file offset of
the file table entry corresponding to the current page.
The length and text of the page title are the final table entries.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	      Page/Statement Cross Reference Tables	\'
^#\Page/Statement Cross Reference Tables
$SKIP 1 
$PARAGRAPH 0
A page/statement cross reference table is generated for each
page table entry.
Each cross reference table has one entry for each procedure
which has executable code generated from source code on
the corresponding page.
Each cross reference table is terminated with a zero word.
The format of a cross reference table entry is shown below.
$SKIP 1 $NEED 7  $IND +5
$VERBATIM 
      15                    0
     +-----------------------+
     | stmt list entry offset|
     +-----------------------+
     | offset w/in module of |
     |   first stmts code    |
     +-----------------------+
$JUS
$IND -5
$SKIP 1
The first field is the (16 bit) offset within the debug file
of the statement list entry for the first source statement
in the given statement list which is also on the given page.
The second field is the (32 bit) offset within the compilation unit's
code of the first byte of code generated for the statement
designated by the first field.
The cross reference table entries are sorted into ascending order
based on the contents of this second field
(i.e., the statement list entry pointers appear in the
same order in which the corresponding statements appear in
the source code).
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	      Statement Lists	\'
^#\Statement Lists
$SKIP 1 
$PARAGRAPH 0
A statement list is generated for each routine in the compilation unit.
Statement list entries correspond to individual Pascal statements
and are generated in the same circumstances in which a
statement block is generated in the DEC10 implementation.
The entries appear in the same order in which the corresponding
source statements appear in the source files
(i.e., statement list entries are sorted by line number
within page).
Each statement list is terminated with a word in which all
bits are set to one.
A statement list entry is pictured below.
Note that the size and line number fields may be either
one or two bytes and that the line number and page offset
fields are not always present.
$SKIP 1 $NEED 21  $IND +5
$VERBATIM 
     +-+-+-----------+ - - - - - - - +
     |W|L|         size              |
     +-+-+-----------+ - - - - - - - +
     |    kind       |
     +-+-+-----------+ - - - - - - - +
     ||A|P|        line               |
     +-+-+---------------------------+
     |    page table entry offset    |
     +-------------------------------+

     W = 0  - size field is 6 bits
       = 1  - size field is 14 bits

     L = 0  - line and page fields are not present
       = 1  - the line field is present

     A = 0  - line field is a 6 bit line number increment
       = 1  - line field is a 14 bit absolute line number

     P = 0  - the page entry is not present
       = 1  - the page entry is present
$JUS
$IND -5
$SKIP 1
$SKI
[? To be changed - "W" and "L" bits will be moved to the
byte containing the kind code and that byte will be made
the first byte of the entry. ?]
$SKI
The size field is the size in ^Uwords|U of the code generated
for the source statement.
In the case of a compound statement, the size only includes the code 
generated at the beginning of the compound statement.
The size associated with an END keyword is the size of any code
terminating the compound statement.
In essence, the size of a statement is the number of bytes of code
which would be generated between two adjacent statement blocks
in the DEC10 approach.
Note that in some circumstances a size field of zero will
be generated, e.g., for a LOOP or REPEAT statement.
The zero length entries will serve the purpose of
allowing breakpoints to be set on the lines containing
the loop keywords.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The size field may be either 6 or 14 bits depending on the
setting of the "W" bit.
The kind field indicates the type of the source statement;
this information is necessary to implement the ".KIND" command.
The line and page fields may or may not be present depending on the
setting of the "L" bit.
If the line field is not present, then the line
number corresponding to the statement is assumed
to be one greater than the last line number,
and, the page containing the statement is assumed
to be unchanged since the previous entry.
$SKIP 1
$NEED 2  $PARAGRAPH 0
If the "A" bit is set, then the line field is 14 bits
and represents an absolute line number;
otherwise, the line number field is 6 bits and represents
the change in line number from the previous statement.
The line field is always unsigned.
An absolute line number is always used in the first
entry in a statement list and in any entry in which
the page field is present.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The page field is present only if the "P" bit is set.
The page field contains the offset from the start of
the debug file to the page table entry corresponding
to the statement.
If the page field is not present, then the page is assumed to be
unchanged since the previous entry.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	      The Routine Table	\'
^#\The Routine Table
$SKIP 1 
$PARAGRAPH 0
There is exactly one routine table in each debug file.
The routine table contains one entry for each subroutine
defined in the compilation unit.
The routine table is terminated by a zero word.
The format of a routine table entry is shown below.
$SKIP 1 $NEED 10  $IND +5
$VERBATIM 
      15                    0
     +-----------------------+
     |    stmt list offset   |
     +-----------------------+
     |  offset of code for   |
     |     first statement   |
     +-----------------------+
     |   offset of block     |
     | node in symbol table  |
     +-----------------------+
$JUS
$IND -5
$SKIP 1
The first field is the (16 bit) offset of the start of the
statement list for the routine.
The second field is the (32 bit) offset within the compilation unit's
code of the first statement of the routine.
The third field is the (32 bit) offset within the debug file
of the block node for the routine.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	      The Symbol Table	\'
^#\The Symbol Table
$SKIP 1 
$PARAGRAPH 0
The symbol table is simply the compiler's symbol table.
It is generated just as it currently is on the DEC10.
The start of the symbol table section of the DEBUG file
must be on a (Motorola) disk block boundary
(e.g., a 256 byte boundary).
$LEVEL -1
$LEVEL -1
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	Critical Algorithms	\'
^#\Critical Algorithms
$SKIP 2
$PARAGRAPH 0
This section describes the critical debugger algorithms
which have a substantially different implementation
given the debugger changes outlined at the beginning of this section.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The discussions which follow assume the existance of some means
of translating a Pascal module name to the base address of the code
for that module.
On the DEC10 this is done using the global symbol table produced
by the linker.
It is not yet known how this can be accomplished under VERSAdos.
A symbolic debugger has just been added to the VERSAdos system
and a symbol table file is now produced by the linker.
However, the format of this file is not yet known.
Note that this capability is required no matter which approach
to supplying line number information is used.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The term "source reference" is used throughout the following
subsections to refer to a Pascal source statement designation
in the debugger's "module@file-page/line" format.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The approach to line number identification described here does
require making certain assumptions about the format of
a stack frame.
The compiler must save the current frame pointer before calls
to routines declared with the Fortran calling sequence
option.
The instruction to do this save must be the last instruction
generated before the JSR to the routine.
A longword labelled with the symbol M.FP_SAVE is used for
this purpose.
Immediately after the return from the routine, an instruction
must be generated to clear the longword at that location.
$SKIP 1
$NEED 2  $PARAGRAPH 0
If the user is concerned with the proper function of the debugger
after an attention or exceptional event in non-Pascal code which
is not called as external Fortran routines, then the following
conventions must be observed.
Either the frame pointer (address register A6) must be left
unmodified by the routine or the routine must establish
a Pascal compatible stack frame.
To be "Pascal compatible" the stack frame fields for the
old frame pointer, the return address and the entry block address
must exist in the same locations and have the same semantics as
Pascal frames.
The safest approach is to simply use the Pascal runtime entry
and exit routines to establish a stack frame.
The RDLIB routines for the Motorola should probably be written to
both use the standard Pascal entry and exit runtime routines and
set up standard procedure blocks.
The standard procedure blocks can both indicate that the
code is non-debug mode code and supply the subroutine name
for stack tracebacks.
Non-Pascal, non-Fortran code which does establish a compatible
frame can simply set the entry block address field to zero
and not use the runtime entry and exit routines and not
actually have a routine entry block.
The runtime and debugger will interpret an entry block
address of zero as an indication of NOTRACE code.
(Note, though, that NOTRACE Pascal code will have a
valid entry block address but the debug address field of
the entry block will be set to zero.)
$SKIP 1
$NEED 2  $PARAGRAPH 0
On entry to each runtime routine, except the procedure entry
and exit routines, the return address to the Pascal caller
will be saved in a longword labelled M.RET_ADDR.
Immediately before returning each runtime routine will clear
this location.
This will permit the debugger to print the current
location in the user's Pascal code after an attention
occurs while a runtime routine is executing.
$LEVEL +1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Stack Traceback	\'
^#\Stack Traceback
$SKIP 1 
$PARAGRAPH 0
Both the runtime error handling routines and the Pascal
debugger are capable of printing stack tracebacks.
The runtime's trace is simpler than the debugger's;
only routine names are printed.
The algorithm used by the runtime is straightforward.
If the saved frame pointer cell, M.FP_SAVE, is non-zero
then the address in the cell is used as the topmost
frame; otherwise the contents of A6 are used as the
topmost frame address.
Starting at the topmost frame, the entry block address
in each frame is used to access the routine's procedure
block.
The procedure block contains the text of the routine's
name.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The traceback printed by the debugger prints source references
for the point of each call and the first statement in each
routine (if the corresponding code was compiled with the DEBUG option).
The location of the first line of code in each routine
is determined as follows.
The procedure block address is obtained as described above.
If the routine table offset field is non-zero, then the routine
was compiled with the DEBUG option.
The procedure block contains the address of the program block;
the program block contains the name of the object file,
from which the name of the debug file is derived.
The routine table in the debug file gives the offset of the
code for the first statement of the routine.
The base address of the module's code is added to this offset
to yield the address of the start of the routine.
The algorithm for mapping an address to a source reference
(described in a later section) is then applied to yield
the desired source reference.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The location of each call is obtained by applying the
address to source reference mapping algorithm to the
return address field of each frame.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Mapping An Address To A Source Reference	\'
^#\Mapping An Address To A Source Reference
$SKIP 1 
$PARAGRAPH 0
The debugger must map an address to a source reference as part
of the display location and display stack commands.
In addition to an address in the code area, the debugger
also has available an associated stack frame pointer.
In most circumstances the address and the stack frame
are known to correspond, i.e., the code address is known
to be in the routine for which the stack frame was established.
When the address and stack frame are known to correspond,
the translation of the address to a source reference
proceeds as follows.
The entry block address in the stack frame is used to access
the procedure block for the routine.
The procedure block supplies the name of the debug file
and the offset within the routine table of the entry for the routine
containing the address.
The routine table contains the starting offset of
the statement list for the routine.
The statement list is searched sequentially until a
statement containing the desired address is found.
At this point the line number of the source reference is known.
The statement list entry also establishes the page table
entry for the source reference. 
The page table entry contains the offset of the corresponding
file table entry.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The situation is more complex when the address and stack
frame may not correspond.
The one circumstance in which this may occur is in the
display location command.
For example, if the debugger is entered after an unhandled
attention, the address at which the attention occurred
need not correspond to the top stack frame.
The address may be in the runtime,
 in a quick blocked Pascal routine, in Fortran code, in an
assembly language routine or in some other non-Pascal code.
Thus for the display location command, the following
case analysis must be done:
$INDENT LEFT +3
$SKIP 1
$SKIP 0   $PARAGRAPH -3
1.\If location M.FP_SAVE is non-zero then the address is
in Fortran code. 
In this case the current location is known only as an address;
no symbolic information is available.
If the stack is displayed, the display begins with the frame
whose address was saved in M.FP_SAVE.
The location within that routine, i.e., the point of the
call to the Fortran routine, is unknown.
$SKIP 0   $PARAGRAPH -3
2.\If the address is within either a procedure entry or exit
runtime routine, then the location is either the point of
call or the first line of the callee.
The exact location within the entry and exit routines determines
which location is used and which stack frame is used.
$SKIP 0   $PARAGRAPH -3
3.\If the location M.RET_ADDR is non-zero then the address
is within the runtime.
The address in M.RET_ADDR is used as the current location
address and the topmost stack frame is the associated stack frame.
$SKIP 0   $PARAGRAPH -3
4.\If the instruction at the given address is a JSR to a procedure
entry runtime routine, then the procedure block address
is obtained from the routine entry block following the JSR,
rather that from the top stack frame.
$SKIP 0   $PARAGRAPH -3
5.\In all other cases the topmost stack frame's entry
block address is used to find the procedure block for
the frame.
If the routine corresponding to that procedure block is
not in DEBUG mode (i.e., if the routine table offset in
the procedure block is zero), the the current location
is simply displayed as an address.
If the routine is in debug mode then the current address is
looked up in the statement list for the routine.
If the address is within the routine, then a full source
reference can be displayed.
If the address is not within the routine, then the current
location must be either in a quick routine or in non-Pascal,
non-Fortran code.
The routine table is searched for the largest starting code
address which is smaller than the search address.
The statement list corresponding to that routine is searched
to determine if the address lies within that routine.
If it does, then a full source reference can be displayed.
Otherwise, the address is assumed to be in a non-Pascal, non-Fortran
routine and the location can only be displayed as an address;
the location of the call to the "foreign" routine from
within the Pascal routine is unknown.
$INDENT -3
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Mapping A Source Reference To An Address	\'
^#\Mapping A Source Reference To An Address
$SKIP 1 
$PARAGRAPH 0
A source reference must be mapped to an address in order to
implement the debugger's BREAKPOINT command.
The mapping proceeds as follows.
The module name is used to obtain the base address of the
module's code.
$SKI
[? This step is currently magic. ?]
$SKI
The program block is at that address and contains the object
file name;
the debug file name is derived from the object file name.
The debug file begins with the header block which contains
the file table offset.
The file table is searched sequentially for a match with the
file name or number specified in the source reference.
The matched file table entry contains the address of
the page table for the file;
the page table is searched sequentially for a match with the
page name or number specified.
The page table entry contains the offset of the page/statement 
cross reference table.
Each statement list pointed at by a cross reference table entry
is seached sequentially until one of the following conditions is
met:
(1.) the statement list ends,
(2.) the page changes,
(3.) a line number match is found,
(4.) a line number greater than that desired is found.
As the statement lists are scanned the starting address
of each statement is kept track of.
If all the statement lists are traversed without finding
the desired line or a greater numbered line, then the
last entry found (i.e., the largest numbered line on the
page)  is used.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Single Stepping	\'
^#\Single Stepping
$SKIP 1 
$PARAGRAPH 0
Since single stepping will only be permitted from debug mode code,
whenever single stepping is initiated the starting address and
code size for the statement being stepped are known.
The single stepping will be implemented by using the trace bit
trapping capability of the MC68000;
when the trace bit in the status register is set the processor
traps after every instruction executed.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The algorithm for single stepping in the "step over called
subroutines" mode is straightforward.
After each trap the value of the program counter (PC) is
examined.
If the next instruction to be executed lies outside the range
of the instruction being stepped then the debugger is invoked.
Otherwise, if the instruction to be executed next is a JSR
instruction, then a breakpoint is set following the JSR instruction
and trace bit trapping is turned off.
If the next instruction is not a JSR then one more instruction is
single stepped, i.e., the trace bit trap handler returns with
trapping still enabled.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The following procedure is used when the "step into called
routines" command is used.
After a trap the PC is examined to see if it lies outside
the range of the current instruction.
If so, the debugger is entered.
If it does not, then the next instruction to be executed
is examined.
If it is not a JSR instruction then the trap routine returns
with trapping enabled and one more instruction is executed.
If the instruction is a JSR then the destination address
must be decoded.
If the address is within the current module then the
debugger is invoked with the destination address.
Note that this will handle all calls to quick routines.
If the address lies outside the current module then
the instruction at the destination address is examined.
If it is a "MOVE.L\\\(SP),M.RET_ADDR" then the call
is a runtime routine call.
A breakpoint is set following the JSR and the trap routine
returns with trace trapping disabled.
If the entry point instruction is a JSR to one of the
subroutine entry runtime routines, then the routine
entry block gives the procedure block address.
If the called routine is in debug mode then the debugger is
invoked with the entry point address.
If the called routine is not in debug mode then
the debugger is also invoked but with some indication
that an error has occurred and with the current location
set to the point of the call.
If the called routine does not begin with a JSR to
a subroutine entry runtime routine, then the user
is attempting to step into non-Pascal code.
As above the debugger is invoked with an error indication
and the current location is set to the point of the call.
$SKI
[? Non-local GOTOs must be dealt with also. ?]
$SKI
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Interaction With Quick Blocking	\'
^#\Interaction With Quick Blocking
$SKIP 1 
$PARAGRAPH 0
The algorithms presented for mapping a source reference to
an address and for single stepping will work without
restriction on quick routines.
Thus a user may either set a breakpoint or single step into
a quick routine which was compiled in debug mode.
Moreover, whenever the current location is in a debug mode
quick routine, the debugger has available all the information
necessary to establish scope, display scope and display
all in-scope variables.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The major restrictions in dealing with quick routines are
as follows.
The display stack command will only show full frames,
i.e., only non-quick routines will show up.
The only way to initially open the scope of a quick routine
will be to enter the debugger while the quick routine is
executing, i.e., single step into it or set a breakpoint
in it.
The parameterless version of the ".OPEN" command can
always be used to reestablish scope.
$LEVEL -1
$LEVEL -1
$PARAGRAPH 0
$FOOTNOTES   LEFT  'Exceptional Condition Handling'
$SKIP 4
$NEED 5
$SECTION
$ENTRY ''
$ENTRY '^#	EXCEPTIONAL CONDITION HANDLING	\'
$ENTRY ''
^#\\&Exceptional Condition Handling&
$SKIP 2
$PARAGRAPH 0
^CThis section describes the implementation of the MDSI Pascal
exceptional condition handling facility.
The implementation is similar to the previous DEC10 and
VAX implementations.
The presentation consists of four major sections.
The first section presents the terminology used throughout
the discussion and defines the data structures used.
The second section gives pseudo-code descriptions of
each of the runtime routines.
The third section describes the data structures and
runtime routine calling sequences generated by the compiler.
Finally, several miscellaneous issues are discussed.
$SKI
[? This section is a revision of the corresponding section in the
"ANC MicroEclipse Runtime Design Notes".
The references related to user code overlaying have been left in
pending design of an overlay system. ?]
$SKI
$LEVEL +1
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	Data Structures	\'
^#\Data Structures
$SKIP 2
$PARAGRAPH 0
Descriptions of each of the major data structures used by the
exception handling system are given in this section.
$LEVEL +1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Exception Blocks	\'
^#\Exception Blocks
$SKIP 1 
$PARAGRAPH 0
Exception blocks contain read-only information which is
specific to a subcondition.
For user conditions, subcondition codes and messages are not
meaningful;
the exception block for a given user condition includes all information
relevant to that condition.
In contrast, a standard condition may have many corresponding
exception blocks.
An additional data structure, the condition cell,
contains information about standard conditions which is
invariant for all the corresponding subconditions.
The format of an exception block is shown below;
note that only the first word is present for user
conditions.
$TRA '\' '\'
$SKIP 1 $NEED 16  $IND +0
$VERBATIM 
 15		       0
+-----------+-----------+
|  condition address	|
+-----------+-----------+
|  sub cond ||C| msg len | \
+-----------+-----------+  |
|       text of         |  |
|    error message      |  |-- standard
|           .           |  |   conds only
|           .           |  |
|           .           | /
+-----------+-----------+

C = 0  ==>  may not continue after exception
  = 1  ==>  may continue after exception
$JUS
$IND -0
$SKIP 1
$TRA '\' ' '
The first word of an exception block contains an address
known as the ^Ucondition address|U.
For user conditions, the condition address is the 
offset within the static data area
the exception block for the condition.
Thus user exception blocks consist of a single word
which contains its own offset.
For standard conditions, the condition address is the
offset within the static area of the condition cell.
Condition cells are discussed in the next section.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The information in an exception block for a user condition serves 
only to distinguish it from standard conditions;
the primary purpose of the existance of an exception block
for a user condition is to provide, via the exception block
address, a unique name for the condition.
$SKIP 1
$NEED 2  $PARAGRAPH 0
Exception blocks for user conditions are allocated in the
same section in which user static data is allocated.
Exception blocks for standard conditions are allocated in the
same section in which the runtime's static data is allocated.
Although exception blocks contain only read only information,
they are allocated in read/write sections in order to
guarantee that their addresses are unique.
Code addresses may not be unique if the code is overlaid.
$SKI
[? Reevaluate this decision after an overlay system is specified. ?]
$SKI
Note that user and standard exception blocks may be
distinguished by determining if the first word contains its
own offset.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Condition Cells	\'
^#\Condition Cells
$SKIP 1 
$PARAGRAPH 0
Condition cells exist for standard conditions only;
they contain information specific to a given condition.
The first longword of the condition cell is always present.
The second longword is present only for maskable conditions.
The format of a condition cell is shown below.
$TRA '\' '\'
$SKIP 1 $NEED 13  $IND +5
$VERBATIM 
      31		    0
     +-----------+-----------+
     |M|P|  masking count    |
     +-----------+-----------+
     | exception block addr  | -- present for maskable
     +-----------+-----------+    conditions only

     M = 0  ==>  condition is not maskable
       = 1  ==>  condition is maskable

     P = 0  ==>  exception not pending for condition
       = 1  ==>  exception is pending for condition
$JUS
$IND -5
$SKIP 1
$TRA '\' ' '
The condition cell address serves as a unique identifier for
standard conditions, much as the exception block address
does for user conditions.
The exception block address is the address of the exception
block for the last signaled exception for the condition;
this address is set when an exception occurs and the
corresponding condition is masked.
$SKIP 1
$NEED 2  $PARAGRAPH 0
Condition cells are allocated in the runtime's static
storage section.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Handler Branch Tables	\'
^#\Handler Branch Tables
$SKIP 1 
$PARAGRAPH 0
A handler branch table (HBT) is generated by the compiler
for each handler clause in the compilation unit.
They are read-only and are generated in the code area.
The format of a handler branch table is shown below.
$SKIP 1 $NEED 21  $IND +5
$VERBATIM 
      31       16 15        0
     +-----------+-----------+
     |handler entry code addr|
     +-----------+-----------+
     |  next outer hbt addr  |
     +-----------+-----------+
		 | hsb offset|
     +-----------+-----------+
		 | cond addr |
     +-----------+-----------+
     |    handler address    |
     +-----------+-----------+
     |           .           |
     |           .           |
     |           .           |
     +-----------+-----------+
		 | -1 or -2  |
     +-----------+-----------+
     | handler address or 0  |
     +-----------+-----------+
$JUS
$IND -5
$SKIP 1
The first entry in the table is the address of the common
entry code for the handler clause.
The second entry is the address of the HBT for  the next outer handler
clause within the procedure or zero if no outer handler
exists.
The third entry is the offset within the corresponding
stack frame of the handler state block (described in the
next section) for the handler.
Starting with the fourth entry is a list of address pairs.
The first address is the condition address,
as defined in the section on exception blocks,
for the condition.
The second part of the pair is the address of the handler
corresponding to that condition.
The list is terminated by a final pair of fields.
The first field contains a -1 if the handler clause contains
an others handler, a -2 if an allconditions handler is present
and a -1 if neither is present.
The second field contains either the address of the others or
allconditions handler or a 0 if neither was present.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The address of the current handler branch table (or zero if
no handler is current) is stored at offset four from the
frame pointer in the current stack frame.
The compiler emits runtime calls to update this location.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Handler State Blocks	\'
^#\Handler State Blocks
$SKIP 1 
$PARAGRAPH 0
Handler state blocks (HSB) are used to contain read/write state information
associated with a given handler clause.
One HSB exists for each handler clause;
the compiler insures that they will be allocated on the stack
as statically-sized temporaries.
The format of a handler state block is shown below.
$SKIP 1 $NEED 7  $IND +5
$VERBATIM 
      31       16 15        0
     +-----------+-----------+
     |   exception address   |
     +-----------+-----------+
		 ||ovl mod num|
     +-----------+-----------+
     |  exception block addr |
     +-----------+-----------+
$JUS
$IND -5
$SKIP 1
The first field of the block contains the address at which the last
exception occurred if the corresponding handler clause is active.
This cell is used by the runtime as a "handler active" flag;
it will be zero if the correspondng handler clause is not active.
The next two fields are meaningful if the first word of
the block is non-zero, i.e., if the corresponding handler
clause is active.
The second field contains the overlay module number of the overlay
in which the exception occured, or, zero if the exception occured
while the runtime was executing.
The final field contains the address of the exception
block corresponding to the condition whose signaling activated
the handler clause.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   The Manager Active Flag	\'
^#\The Manager Active Flag
$SKIP 1 
$PARAGRAPH 0
The manager active flag is a one longword flag maintained by the
runtime to indicate when the exception manager is active.
If the exception manager is active it will contain the 
address of the exception block for the exceptional condition
which was signaled;
otherwise, it will be zero.
The exception block address, rather than a simple boolean, is
used so that the runtime can determine what condition the manager
is handling when an asynchronous interrupt occurs.
$LEVEL -1
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	Exception Handling Runtime Routines	\'
^#\Exception Handling Runtime Routines
$SKIP 2
$PARAGRAPH 0
$SKIP 0
This section describes the exceptional condition handling
runtime routines.
The routines are presented in an informal pseudo-code.
While these descriptions are not necessarily detailed,
they are intended to be complete and accurate at the
given level of presentation.
Thus any details lacking should be clearly a part of an
unelaborated routine used in the pseudo-code descriptions.
$LEVEL +1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   MASK	\'
^#\MASK
$SKIP 1 
$PARAGRAPH 0
MASK is called with a single parameter - the address of a condition
cell for a standard condition.
$SKIP 1 $NEED 12  $IND +3
$VERBATIM 
procedure mask ( std_cond );

begin
  assert ( std_cond^.maskable );
  if std_cond^.masking_count = #H3FFFFFFF then begin
    m$fatal ( <ret addr>, 'Masking count overflow' );
  end
  else begin
    std_cond^.masking_count := std_cond^.masking_count + 1;
  end;
end;
$JUS
$IND -3
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   UNMASK	\'
^#\UNMASK
$SKIP 1 
$PARAGRAPH 0
The one argument to UNMASK is the address of a condition cell
for a standard condition.
$SKIP 1 $NEED 16  $IND +3
$VERBATIM 
procedure unmask ( std_cond )

begin
  assert ( std_cond^.maskable );
  if std_cond^.masking_count = 0 then begin
    m$fatal ( <ret addr>, 'Improperly nested call to UNMASK' );
  end
  else begin
    std_cond^.masking_count := std_cond^.masking_count - 1;
    if (std_cond^.masking_count = 0) and
       (std_cond^.pending) then begin
      std_cond^.pending := false;
      except_mgr ( std_cond^.exc_block, <unmask ret addr> );
    end;
  end;
end;
$JUS
$IND -3
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   MASKED	\'
^#\MASKED
$SKIP 1 
$PARAGRAPH 0
The one parameter to MASKED is the address of a condition cell for
a standard condition.
$SKIP 1 $NEED 6  $IND +3
$VERBATIM 
function masked ( std_cond ): boolean;

begin
  assert ( std_cond^.maskable );
  masked := (std_cond^.masking_count > 0);
end;
$JUS
$IND -3
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   PENDING	\'
^#\PENDING
$SKIP 1 
$PARAGRAPH 0
The one parameter to PENDING is the address of the condition
cell for a standard condition.
$SKIP 1 $NEED 8  $IND +3
$VERBATIM 
function pending ( std_cond ): boolean;

begin
  assert ( std_cond^.maskable );
  assert ( not ( (std_cond^.pending ) and 
		 (std_cond^.masking_count = 0) ) );
  pending := std_cond^.pending;
  std_cond^.pending := false;
end;
$JUS
$IND -3
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   EXCEPTION_MESSAGE	\'
^#\EXCEPTION_MESSAGE
$SKIP 1 
$PARAGRAPH 0
The pseudo-code description of EXCEPTION_MESSAGE is at
a somewhat higher level than the descriptions given earlier.
In particular, the first action described is a search of the
stack for the topmost active handler.
This search procedure must be executed from several places in
the runtime and will be a separate routine.
The outline of the search is straightforward;
the handler branch table pointer in each
stack frame is used to find the current innermost handler branch
table.
The handler branch table contains the offset of the corresponding
handler state block.
A handler is active if the exception address field of the handler
state block is non-zero.
The outer HBT address field of the handler branch table is
followed when the current handler is not active.
If the outer HBT address is zero, then the dynamic link
is followed and the procedure is repeated for the next stack 
frame.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The presence of overlays will complicate this process 
since handler branch tables are generated in the code area.
The runtime must load overlays as it follows the dynamic
chain down the stack and must restore the caller's overlay
before returning.
The algorithm for determining the overlay module number
corresponding to a stack frame is discussed in the
section on debugging aids and will not be described 
here.
$SKIP 1 $NEED 15  $IND +3
$VERBATIM 
procedure exception_message;

begin
  top_ovl_mod_num := current_overlay_mod_num;
  hsb := find_top_active_handler;
  if hsb = 0 then begin
    writeln( tty, 'Exc msg called with no handler active' );
  end 
  else begin
    if hsb^.exc_block^.cond_cell = hsb^.exc_block
      then writeln ( tty, 'User signaled condition' )
      else writeln ( tty, hsb^.exc_block^.message );
    write ( tty, 'Overlay:', hsb^.ovl_mod_num );
    writeln ( tty, '   PC:', hsb^.exc_addr:8:H );
  end;
  load_overlay ( top_ovl_mod_num );
end;
$JUS
$IND -3
$SKIP 1
$SKI
[? Should the error message be a warning or fatal? ?]
$SKI
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   The Status Routines	\'
^#\The Status Routines
$SKIP 1 
$PARAGRAPH 0
The status routines are all parameterless functions which return
a subcondition code for a standard condition.
The pseudo-code description of the MATH_STATUS routine is
given below.
The other status routines are almost identical (in fact they
may be implemented as multiple entry points to a common 
routine).
$SKIP 1 $NEED 16  $IND +3
$VERBATIM 
function mathstatus: math_status;

begin
  mathstatus := 0;
  top_ovl_mod_num := current_overlay_mod_num;
  hsb := find_top_active_handler;
  if hsb = 0 then begin
    writeln ( tty, 'Error - no handler active' );
  end
  else begin
    if hsb^.exc_block^.cond_cell = math_error_cond_cell
      then mathstatus := hsb^.exc_block^.sub_cond
      else writeln ( tty, 'Top handler not for math error' );
  end;
  load_overlay ( top_ovl_mod_num );
end;
$JUS
$IND -3
$SKIP 1
$SKI
[? Again, should the error messages be warnings only? ?]
$SKI
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   SIGNAL	\'
^#\SIGNAL
$SKIP 1 
$PARAGRAPH 0
This section describes the routine for signaling a user
condition.
The one parameter to the routine is the address of the
exception block for the user condition.
The exception manager runtime routine, EXCEPT_MGR, is 
described in a later section.
$SKIP 1 $NEED 5  $IND +3
$VERBATIM 
procedure signal ( user_cond );

begin
  except_mgr ( user_cond, <signal return address> )
end;
$JUS
$IND -3
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Resignal	\'
^#\Resignal
$SKIP 1 
$PARAGRAPH 0
This section describes the parameterless version of SIGNAL,
i.e., the routine for resignaling the last signaled condition.
$SKIP 1 $NEED 14  $IND +3
$VERBATIM 
procedure signal();

begin
  top_ovl_mod_num := current_overlay_mod_num;
  hsb := find_top_active_handler;
  if hsb = 0 then begin
    m$fatal ( <ret addr>, 'Resignal with no active handler' );
  end
  else begin
    with hsb^.exc_block^ do begin
      masked := (cond_cell <> hsb^.exc_block) andif
                (cond_cell^.maskable) andif
                (cond_cell^.masking_count <> 0);
      if masked then begin
        cond_cell^.pending := true;
        cond_cell^.exc_block := hsb^.exc_block;
      end
      else except_mgr ( hsb^.exc_block, hsb^.exc_addr );
    end  (* with *) ;
  end;
  load_overlay ( top_ovl_mod_num );
end;
$JUS
$IND -3
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Establish A Handler	\'
^#\Establish A Handler
$SKIP 1 
$PARAGRAPH 0
This section describes the runtime routine for establishing
a new handler.
The compiler emits calls to this routine whenever the
scope of a handler is first entered.
The one parameter to the routine is an handler branch table
address.
$SKIP 1 $NEED 7  $IND +3
$VERBATIM 
procedure set_handler ( hbt_addr );

begin
  frame_pointer^.hbt_addr := hbt_addr;
  hsb := frame_pointer + hbt_addr^.hsb_offset;
  hsb^.exc_addr := 0;         (* flag handler inactive *)
end;
$JUS
$IND -3
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Restore A Handler	\'
^#\Restore A Handler
$SKIP 1 
$PARAGRAPH 0
This section describes the runtime routine for reestablishing
a handler when the scope of the handler is reentered.
The compiler emits calls to this routine whenever
necessary.
"Reestablishing" a handler may include calling this
routine with a parameter of zero when leaving the scope of a handler
and entering a block of code which is not in the scope of a handler.
The one parameter to the routine is an handler branch table
address.
$SKIP 1 $NEED 5  $IND +3
$VERBATIM 
procedure reestablish_handler ( hbt_addr );

begin
  frame_pointer^.hbt_addr := hbt_addr;
end;
$JUS
$IND -3
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Nonmaskable Exception Intercept Routines	\'
^#\Nonmaskable Exception Intercept Routines
$SKIP 1 
$PARAGRAPH 0
This section describes the runtime routines which intercept
nonmaskable standard conditions, e.g., floating overflow.
The pseudo-code below is based on several assumptions.
First, the address of the instruction causing the exception,
or of the instruction following the exception, is assumed
to be passed to the intercept routine (generally by the
operating system).
The assertion that the exception manager is not active is
based on the assumption that nonmaskable exceptions
occuring when the exception manager is active may be
considered to be bugs in the runtime and that generation
of a fatal error is appropriate.
Finally, the intercept routines are specific to a subcondition
of a given standard condition and thus the appropriate exception
block address is available to the intercept routine.
$SKIP 1 $NEED 7  $IND +3
$VERBATIM 
procedure nonmaskable_intercept ( exc_addr );

begin
  assert ( mgr_active = 0 );
  mgr_active := exc_block_addr;
  except_mgr ( exc_block_addr, exc_addr );
end;
$JUS
$IND -3
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Maskable Exception Intercept Routines	\'
^#\Maskable Exception Intercept Routines
$SKIP 1 
$PARAGRAPH 0
The only maskable condition will be attention;
thus this section describes the intercept routine
for attention.
Currently, the specifics of the attention handling facilities
provided by OZMOS are unknown.
For now, we assume that attentions may be intercepted and
that further attentions are ignored or delayed until attention
interception is reenabled.
$SKI
[? Update for VERSAdos ?]
$SKI
The stack search procedure referenced in the pseudo-code below
is different from previous active handler search routines in
that it does not necessarily stop at the first active handler.
The routine will search until either a handler is found which
is active for an attention or until the entire stack has
been searched.
Note that the "ATTN_INTERCEPT_ACTIVE" variable referred to is
a static variable.
$SKIP 1
$NEED 2  $PARAGRAPH 0 
$SKIP 1 $NEED 10  $IND +3
$VERBATIM 
procedure attention_intercept ( exc_addr );
 
begin
  if attn_intercept_active then begin
    reenable attentions;
    return;
  end;
  attn_intercept_active := true;
  reenable attentions;

  mgr_active_for_attn := mgr_active = attn_exc_block;
  if not mgr_active_for_attn
    then found := search_for_handler_active_for_attn;

  if mgr_active_for_attn orif found then begin  (* ignore *)
    attn_intercept_active := false;
    return;
  end
  else if (mgr_active <> 0) or		(* pend *)
          (attn_cond_cell.masking_count > 0) then begin
    attn_cond_cell.pending := true;
    attn_cond_cell.exc_block := attn_exc_block;
    attn_intercept_active := false;
    return;
  end
  else begin                          (* signal *)
    mgr_active := attn_exc_block;
    attn_intercept_active := false;
    except_mgr ( attn_exc_block, exc_addr );
  end;
end;
$JUS
$IND -3
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   The Exception Manager	\'
^#\The Exception Manager
$SKIP 1 
$PARAGRAPH 0
The exception manager is the central runtime routine
called by all the intercept routines.
It has two parameters,
the exception block address for the condition being signaled
and the address associated with the exception.
$SKIP 1
$NEED 2  $PARAGRAPH 0
Note that the common entry code for a handler clause is branched
 to with the specific handler address on top of the stack.
$SKIP 1 $NEED 7  $IND +3
$VERBATIM 
procedure except_mgr ( exc_block, exc_addr );

begin
  find the topmost inactive handler for either the
    signaled condition or allconditions.
    set FOUND equal to true if such a handler is
    found and to false otherwise.
    As the search proceeds, set variable HBT to
    the handler branch table for the first hbt
    found for the signaled condition or others
    or allconditions.
  if found then begin
    unwind any frames above one corresponding to hbt;
    frame_pointer^.hbt_addr := hbt;
    hsb := handler state block corresponding to HBT;
    if exc_addr is in the runtime
      then hsb^.ovl_mod_num := nil_ovl_mod_num
    else if not called by resignal
      then hsb^.ovl_mod_num := current_overlay_mod_num;
    hsb^.exc_addr := exc_addr;
    hsb^.exc_block := exc_block;
    if (attn_cond_cell^.pending) and
       (attn_cond_cell^.masking_count = 0) then begin
      exc_block := attn_exc_block;
      exc_addr := <label 100>;
      attn_cond_cell^.pending := false;
      goto except_mgr;
    end;
100:
    mgr_active := 0;
    push handler address onto stack;
    goto handler common entry code;
  end
  else begin
    if exc_block^.cond_cell = exc_block
      then writeln ( tty, 'Unhandled user condition' )
      else writeln ( tty, exc_block^.message );
    exit;
  end;
end;
$JUS
$IND -3
$SKIP 1
$LEVEL -1
$SKIP 0
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	Compiler Interface	\'
^#\Compiler Interface
$SKIP 2
$PARAGRAPH 0
The data structures and runtime calls which the compiler
must generate are described in this section.
$LEVEL +1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Data Structures Generated	\'
^#\Data Structures Generated
$SKIP 1 
$PARAGRAPH 0
The compiler must generate and completely initialize the
handler branch table corresponding to each handler clause in
the compilation unit.
For standard conditions, the condition cell address field
is initialized to the value of an external symbol.
The names of these symbols are given in the final section on
miscellaneous topics.
The HBT is generated in the code area.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The compiler must allocate stack space for, but need not
initialize, the handler state block corresponding to each
handler clause.
$SKIP 1
$NEED 2  $PARAGRAPH 0
For each user condition, the compiler must emit an exception
block in the static area.
The exception blocks must be initialized with their own 
offset within the static area.
Public user conditions must also have a global definition emitted
which defines the value of the symbol to be the 
static area offset of
the exception block.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Runtime Routine Calls Generated	\'
^#\Runtime Routine Calls Generated
$SKIP 1 
$PARAGRAPH 0
This section describes the interface to the exception handling
runtime routines which are called from compiler generated code.
The input arguments listed are pushed onto the stack before the
call.
The output arguments have the address of the location to
receive the value pushed onto the stack.
Input arguments are pushed first.







$INDENT LEFT +12
$SKIP 0
$SKIP 3   $PARAGRAPH -12
\1.\MASK\\\\

$PAR -7  $VER
CALL:\\JSR\\\\e.mask
$JUS
$ski   $par -7  $need 2
INPUTS:
$par -5
1.:\Condition cell address
$SKIP 3   $PARAGRAPH -12
\2.\UNMASK\\

$PAR -7  $VER
CALL:\\JSR\\\\e.unmask
$JUS
$ski   $par -7  $need 2
INPUTS:
$par -5
1.:\Condition cell address
$SKIP 3   $PARAGRAPH -12
\3.\MASKED\\

$PAR -7  $VER
CALL:\\JSR\\\\e.mskd
$JUS
$ski   $par -7  $need 2
INPUTS:
$par -5
1.:\Condition cell address
$ski  $par -7  $need 2
OUTPUTS:
$PAR -5
1.:\boolean return value
$SKIP 3   $PARAGRAPH -12
\4.\PENDING\

$PAR -7  $VER
CALL:\\JSR\\\\e.pend
$JUS
$ski   $par -7  $need 2
INPUTS:
$par -5
1.:\Condition cell address
$ski  $par -7  $need 2
OUTPUTS:
$PAR -5
1.:\boolean return value
$SKIP 3   $PARAGRAPH -12
\5.\EXCEPTION_MESSAGE\

$PAR -7  $VER
CALL:\\JSR\\\\e.msg
$JUS
$SKIP 3   $PARAGRAPH -12
\6.\MATHSTATUS\

$PAR -7  $VER
CALL:\\JSR\\\\e.mathst
$JUS
$ski  $par -7  $need 2
OUTPUTS:
$PAR -5
1.:\Value of enumerated type MATH_STATUS.
$SKIP 3   $PARAGRAPH -12
\7.\EXIOSTATUS\

$PAR -7  $VER
CALL:\\JSR\\\\e.iost
$JUS
$ski  $par -7  $need 2
OUTPUTS:
$PAR -5
1.:\Value of enumeraed type IO_STATUS.
$SKIP 3   $PARAGRAPH -12
\8.\PROGRAMSTATUS\

$PAR -7  $VER
CALL:\\JSR\\\\e.progst
$JUS
$ski  $par -7  $need 2
OUTPUTS:
$PAR -5
1.:\Value of enumerated type PROGRAM_STATUS.
$SKIP 3   $PARAGRAPH -12
\9.\SPECIALSTATUS\

$PAR -7  $VER
CALL:\\JSR\\\\e.spcst
$JUS
$ski  $par -7  $need 2
OUTPUTS:
$PAR -5
1.:\Value of enumerated type SPECIAL_STATUS.
$SKIP 3   $PARAGRAPH -12
10.\SIGNAL(<USER CONDITION>)\

$PAR -7  $VER
CALL:\\JSR\\\\e.signal
$JUS
$ski   $par -7  $need 2
INPUTS:
$par -5
1.:\User exception block address.
$SKIP 3   $PARAGRAPH -12
11.\SIGNAL()\

$PAR -7  $VER
CALL:\\JSR\\\\e.resig
$JUS
$SKIP 3   $PARAGRAPH -12
12.\ESTABLISH A HANDLER\

$PAR -7  $VER
CALL:\\JSR\\\\e.hset
$JUS
$ski   $par -7  $need 2
INPUTS:
$par -5
1.:\Handler branch table address
$SKIP 3   $PARAGRAPH -12
13.\RESTORE A HANDLER\

$PAR -7  $VER
CALL:\\JSR\\\\e.hrest
$JUS
$ski   $par -7  $need 2
INPUTS:
$par -5
1.:\Handler branch table address or zero
$SKIP 3   $PARAGRAPH -12
14.\SIGNALING PROGRAM ERRORS\

$SKI
$ind -7
The specific entry point names for signalling program errors
(i.e., CHECK option errors) are given in the next section.
$ind +7
$SKI
$PAR -7  $VER
CALL:\\JSR\\\\<error specific entry point>
$JUS
$INDENT -12
$SKIP 1
$LEVEL -1
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	Miscellaneous	\'
^#\Miscellaneous
$SKIP 2
$PARAGRAPH 0
This section discusses several miscellaneous issues concerning
exceptional condition handling.
$LEVEL +1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Link Management Interaction	\'
^#\Link Management Interaction
$SKIP 1 
$PARAGRAPH 0
$SKI
[? This section must be rethought after a link management scheme
is designed. ?]
$SKI
The information required by the exception handling system
is either passed to the runtime directly or is found
via pointers in the stack;
thus the link management system has virtually no impact on
the exception handling system.
The standard restrictions on PUBLIC declarations do apply, however.
PUBLIC conditions may only be defined in MAIN, i.e., outside
of LINKs.
Like public variables, public conditions referenced from a LINK
must be declared in the transfer vector and the compiler must
access them with an extra level of indirection.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Compiler Options	\'
^#\Compiler Options
$SKIP 1 
$PARAGRAPH 0
The compiler options to control underflow handling and attention
masking will be implemented.
$SKI
[? Some global symbol names are needed for the compiler
to pass the request on to the runtime. ?]
$SKI
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Status Enumerated Types	\'
^#\Status Enumerated Types
$SKIP 1 
$PARAGRAPH 0
Initially, the enumerated status types will be identical to those
of the VAX implementation.
Additional values will be added at the end of the enumeration
lists if necessary.
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Standard Condition Cell Names	\'
^#\Standard Condition Cell Names
$SKIP 1 
$PARAGRAPH 0
The external symbol names by which the compiler may refer to
standard condition cells are given below.
The compiler uses these symbols in initializing handler
branch tables and in calls to MASK, UNMASK, MASKED and PENDING.
$SKIP 1 $NEED 7  $IND +5
$VERBATIM 
MATH_ERROR		E.CMATH
IO_ERROR		E.CIO
PROGRAM_ERROR		E.CPROG
ATTENTION		E.CATTN
STORAGE_OVERFLOW	E.CHEAP
STACK_OVERFLOW		E.CSTACK
SPECIAL_ERROR		E.CSPEC
$JUS
$IND -5
$SKIP 1
$PARAGRAPH 0


$SKIP 2
$NEED 4
$SECTION
$ENTRY '^#	   Program Error Entry Points	\'
^#\Program Error Entry Points
$SKIP 1 
$PARAGRAPH 0
The following are the entry point names for each of the possible
subconditions of the standard condition PROGRAM_ERROR.
$SKIP 1 $NEED 8  $IND +5
$VERBATIM 
PROGRAM_ASSERTION	E.ASSERT
PROGRAM_CASE		E.CASE
PROGRAM_COMPATIBILITY	E.COMPAT
PROGRAM_FILE		E.FILE
PROGRAM_POINTER		E.PTR
PROGRAM_SUBSTRING	E.SUBSTR
PROGRAM_SUBSCRIPT	E.INDEX
PROGRAM_VALUE		E.VALUE|C
$JUS
$IND -5
$SKIP 1
$LEVEL -1
$LEVEL -1
$PARAGRAPH 0
$FOOTNOTES   LEFT  'Program Initialization And Termination'
$SKIP 4
$NEED 5
$SECTION
$ENTRY ''
$ENTRY '^#	PROGRAM INITIALIZATION AND TERMINATION	\'
$ENTRY ''
^#\\&Program Initialization And Termination&
$SKIP 2
$PARAGRAPH 0
This section describes the initial format of certain runtime data
structures, e.g., the initial stack, and also describes the functions
performed by the runtime initialization and termination routines.
$LEVEL +1
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	The Initial Stack	\'
^#\The Initial Stack
$SKIP 2
$PARAGRAPH 0
The format of the stack frame for the main routine, as it appears
immediately after the execution of the runtime initialization
routine, is shown below.
$SKIP 1 $NEED 16  $IND +5
$VERBATIM 
	|	    -		|
	+-----------------------+
	|			|<-- SP
	|			|
	|     main's temps	| -8(A6)
	+-----------------------+
	|	    0		| -4(A6)
	+-----------------------+
	|	    0		|<-- A6
	+-----------------------+
	|	    0		|  4(A6)
	+-----------------------+
	|    entry block addr	|  8(A6)
	+-----------------------+
	|	    0		| 12(A6)
	+-----------------------+
$JUS
$IND -5
$SKIP 1
The copy of the argument pointer, the old frame pointer,
and the return address fields are zero and should remain
zero at all times.
The handler branch table address is initially zero but may
be set to an HBT address if the main routine contains a handler clause.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The following code should appear at the entry point for
the main routine:
$SKIP 1 $NEED 4  $IND +5
$VERBATIM 
M.START:
	JMP	M.INIT
	<main's frame size>
	<debug addr>
$JUS
$IND -5
$SKIP 1
The routine "M.INIT" is the runtime initialization routine.
The symbol "M.START" must be emitted as a global definition
by the compiler.
The frame size specifies the number of bytes above the
longword reserved for the saved copy of the argument block 
pointer which should be allocated for main's frame.
$SKI
[? Exactly what the debug address is must be resolved. ?]
$SKI
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	The Initial Heap	\'
^#\The Initial Heap
$SKIP 2
$PARAGRAPH 0
$SKIP 1
$NEED 2  $PARAGRAPH 0
Static heap variables (described below)  are initialized as follows:
$SKIP 0
$NEED 2  $PARAGRAPH  5
0(segment_table) <-- M.HEAPBASE
$SKIP 0
$NEED 2  $PARAGRAPH  5
4(segment_table) <-- segment_size  (defaults to 32768)
$SKIP 0
$NEED 2  $PARAGRAPH  5
8(segment_table)...508(segment_table) <-- 0
$SKIP 1
$NEED 2  $PARAGRAPH  5
rover <-- M.HEAPBASE + 8
$SKIP 1
$NEED 2  $PARAGRAPH  5
segment_number <-- 0
$SKIP 1
$NEED 2  $PARAGRAPH 0
The heap (starting at M.HEAPBASE) is initialized as follows:
$SKIP 0
$NEED 2  $PARAGRAPH  5
0(M.HEAPBASE) <-- 0              ; previous segment
$SKIP 0
$NEED 2  $PARAGRAPH  5
2(M.HEAPBASE) <-- 0              ; next segment
$SKIP 0
$NEED 2  $PARAGRAPH  5
4(M.HEAPBASE) <-- M.HEAPBASE + 8   ; the first free block
$SKIP 0
$NEED 2  $PARAGRAPH  5
8(M.HEAPBASE) <-- segment size - 8     ; low order bit  = 0
$SKIP 0
$NEED 2  $PARAGRAPH  5
12(M.HEAPBASE) <-- M.HEAPBASE + 8  ; FLINK
$SKIP 0
$NEED 2  $PARAGRAPH  5
16(M.HEAPBASE) <-- M.HEAPBASE + 8  ; BLINK
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	The Initialization Routine	\'
^#\The Initialization Routine
$SKIP 2
$PARAGRAPH 0
The program initialization runtime routine must perform the following
actions:
$INDENT LEFT +3
$SKIP 1
$SKIP 0   $PARAGRAPH -3
1.\^COpen the program's image file and determine the size
of the static storage area.
$SKIP 0   $PARAGRAPH -3
2.\Create the initial data segment.
$SKIP 0   $PARAGRAPH -3
3.\Set A5 to point to the base of the initial data
segment plus 32768.
$SKIP 0   $PARAGRAPH -3
4.\Initialize SP, the static cell M.STKEND, and the main
routine's stack frame.
$SKIP 0   $PARAGRAPH -3
5.\Load the initial static storage contents from the image file.
$SKIP 0   $PARAGRAPH -3
6.\Initialize the state information for the initial heap.
$SKIP 0   $PARAGRAPH -3
7.\Initiate interception of the standard conditions.
$SKIP 0   $PARAGRAPH -3
8.\Begin execution of the user program.
$INDENT -3
$SKIP 1

$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	The Termination Routine	\'
^#\The Termination Routine
$SKIP 2
$PARAGRAPH 0
The termination routine should be called once at the end of
the main routine.
It requires no parameters; 
its name is "M.STOP".
A call to this routine is also generated for the Pascal
STOP
statement.
$LEVEL -1
$PARAGRAPH 0
$FOOTNOTES   LEFT  'Math Routines'
$SKIP 4
$NEED 5
$SECTION
$ENTRY ''
$ENTRY '^#	MATH ROUTINES	\'
$ENTRY ''
^#\\&Math Routines&
$SKIP 2
$PARAGRAPH 0
$PARAGRAPH 0
$FOOTNOTES   LEFT  'Heap Management '
$SKIP 4
$NEED 5
$SECTION
$ENTRY ''
$ENTRY '^#	HEAP MANAGEMENT 	\'
$ENTRY ''
^#\\&Heap Management &
$SKIP 2
$PARAGRAPH 0
Dynamic memory allocation is controlled via routines NEW and DISPOSE
(described below) and the static heap blocks ( i.e. segment table and
pointers, also described below).  The basic idea is as follows:
$SKIP 1
$NEED 2  $PARAGRAPH 0
Initially, one segment is allocated as free space for the heap.  
There is a free chain, connecting the blocks of available
memory within that segment.  If more heap storage is 
requested than can be supplied within that segment, an 
additional segment is allocated, and a free chain is
also maintained in that segment.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The first word of every segment contains segment numbers to 
the succeeding and preceding segments in the free chain.  The free 
chain does not skip around in different segments, except 
through this header.  Within a given segment, free entries are 
circularly linked.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The second word in each segment is a pointer to an arbitrary node
on the free chain in the segment.  This is useful
in connection with routine DISPOSE, described below.
$SKIP 1
$NEED 2  $PARAGRAPH 0
All memory blocks, whether free or used have the following 
two fields:
$INDENT LEFT +2
$SKIP 1
$SKIP 0   $PARAGRAPH -2
1.\Length (in bytes) of the block.  Since all blocks are to 
be word aligned, it follows that the length of each block should
be an even number, allowing the second field,
$SKIP 0   $PARAGRAPH -2
2.\Free/used flag, in the low order bit of the length field.
0 = free; 1 = allocated.
$INDENT -2
$SKIP 1
$SKIP 1
$NEED 2  $PARAGRAPH 0
Free blocks also have another two words of control
information:
$INDENT LEFT +2
$SKIP 1
$SKIP 0   $PARAGRAPH -2
1.\FLINK -- pointer to the next free block in this segment.
$SKIP 0   $PARAGRAPH -2
2.\BLINK -- pointer to the previous free block in this segment.
$INDENT -2
$SKIP 1
$SKIP 1
$NEED 2  $PARAGRAPH 0
FLINK and BLINK are actual addresses -- not offsets from the 
start of the segment.
$SKIP 1
$NEED 2  $PARAGRAPH 0
The static storage requirements are as follows:
$SKIP 1 $NEED 15  $IND +5
$VERBATIM 
          1)  Segment table   (512 bytes)

            Seg#       4 bytes       4 bytes
                    +------------+------------+
               0    | seg addr   | seg size   |
                    +------------+------------+
               1    |   . . .    |   . . .    |
                    +------------+------------+
                    .            .            .
                    .            .            .
                    +------------+------------+
              62    |   . . .    |   . . .    |
                    +------------+------------+
              63    |   . . .    |   . . .    |
                    +------------+------------+
$JUS
$IND -5
$SKIP 1
$SKIP 1
$NEED 2  $PARAGRAPH 0
There are a total of 64 segments available for heap space, but 
only one is initially allocated.  As subsequent segments
are needed, they are obtained from the operating system,
and likewise returned to the operating system when
completely disposed.
$SKIP 1 $NEED 7  $IND +5
$VERBATIM 
          2)  Rover   (4 bytes)
              A pointer that is actually an address to an 
              arbitrary entry on the free chain.

          3)  Segment Number   (1 byte)
              Gives the segment number that the rover is 
              pointing into.
$JUS
$IND -5
$SKIP 1
$LEVEL +1
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	NEW -- routine to allocate a storage block	\'
^#\NEW -- routine to allocate a storage block
$SKIP 2
$PARAGRAPH 0
Input -- block size requested
$SKIP 0
$NEED 2  $PARAGRAPH 0
Output -- address of sufficiently large block
$SKIP 1
$NEED 2  $PARAGRAPH 0
Algorithm -- start at current position of ROVER (which is 
in segment SEGMENT_NUMBER).  Walk through the free chain in this
segment via FLINKs, until either a large enough block has been found, 
or we reach out starting point (ROVER) which indicates that 
we'll have to look in another segment; if all segments are searched
without satisfaction, allocate another segment.
$SKIP 1
$NEED 2  $PARAGRAPH 0
At every node on the free chain, try to collapse contiguous
memory, by examining the free/used_flag@[addr(free_node)+size(free_node)]
to determine if the next block of contiguous physical memory
(has nothing to do with BLINKs and FLINKs) is also on the free
chain.  If so, collapse into a single free chain entry.  
Do this recursively, so that if there are several contiguous
free blocks they will all be coalesced at once.  Fix FLINKs 
and BLINKs appropriately, one at a time.
$SKIP 1
$NEED 2  $PARAGRAPH 0
Possible error conditions:
$SKIP 0
$NEED 2  $PARAGRAPH  5
1)  Requested size > available size
$SKIP 0
$NEED 2  $PARAGRAPH  5
2)  No more free segments.
$PARAGRAPH 0


$SKIP 3
$NEED 5
$SECTION
$ENTRY '^#	DISPOSE -- routine to liberate a previously allocated block	\'
^#\DISPOSE -- routine to liberate a previously allocated block
$SKIP 2
$PARAGRAPH 0
Input -- address of block to be liberated
$SKIP 0
$NEED 2  $PARAGRAPH 0
Output -- None
$SKIP 1
$NEED 2  $PARAGRAPH 0
Algorithm -- Walk through the segment table (i.e. the links in
the first word of each segment) to determine which
segment the block to be freed is in.  If the address
supplied is not of an allocated block, signal an error and
return.  Otherwise, set ROVER <-- block\to\be\freed;
segment_number <-- whatever\segment\that\block\is\in.
$SKIP 1
$NEED 2  $PARAGRAPH 0
Now we're at the block to be disposed.  Play the same
recursive arithmetic game as on NEW, to determine 
if contiguous blocks are to be coalesced.
$SKIP 1 $NEED 8  $IND +5
$VERBATIM 
     e.g.  X := SIZE@ROVER + ROVER
           IF FREE@X THEN
             FLINK@BLINK@X := ROVER
             BLINK@FLINK@X := ROVER
             BLINK@ROVER := BLINK@X
             FLINK@ROVER := FLINK@X
             SIZE@ROVER  := SIZE@ROVER + SIZE@X
           ENDIF  (* this puts the liberated block in the free chain *)
$JUS
$IND -5
$SKIP 1
$SKIP 1
$NEED 2  $PARAGRAPH 0
If, on the other hand, the next physical block is not free, then
link this block into the free chain at a place indicated by the 
second word in the segment header.  (That is the only purpose 
this word serves.)

$SKIP 1
$NEED 2  $PARAGRAPH 0
Having done all that, start at the first physical block in the
segment (begins at the third word) and, if it is free, 
play the same collapsing game with contiguous
blocks.  If it turns out that the entire segment
is free, (and it is not segment zero) delete it from the segment
list, and return the segment to the operating system.
Make appropriate updates to the segment table
in this case.
$SKIP 1
$NEED 2  $PARAGRAPH 0
Possible error condition:
$SKIP 0
$NEED 2  $PARAGRAPH  5
Given address points to block not currently allocated.
$LEVEL -1
$PARAGRAPH 0
$FOOTNOTES   LEFT  'Environmental Routines'
$SKIP 4
$NEED 5
$SECTION
$ENTRY ''
$ENTRY '^#	ENVIRONMENTAL ROUTINES	\'
$ENTRY ''
^#\\&Environmental Routines&
$SKIP 2
$PARAGRAPH 0
$PARAGRAPH 0
$FOOTNOTES   LEFT  'Miscellaneous Routines'
$SKIP 4
$NEED 5
$SECTION
$ENTRY ''
$ENTRY '^#	MISCELLANEOUS ROUTINES	\'
$ENTRY ''
^#\\&Miscellaneous Routines&
$SKIP 2
$PARAGRAPH 0
$PARAGRAPH 0
$FOOTNOTES   LEFT  'String Routines'
$SKIP 4
$NEED 5
$SECTION
$ENTRY ''
$ENTRY '^#	STRING ROUTINES	\'
$ENTRY ''
^#\\&String Routines&
$SKIP 2
$PARAGRAPH 0
$PARAGRAPH 0
$FOOTNOTES   LEFT  'Set Routines'
$SKIP 4
$NEED 5
$SECTION
$ENTRY ''
$ENTRY '^#	SET ROUTINES	\'
$ENTRY ''
^#\\&Set Routines&
$SKIP 2
$PARAGRAPH 0

$MARGIN 10
$PAGE
$FOOTNOTES OFF
$TITLE LEFT 'MDSI Pascal M68000 Runtime Specification' LEFT 'December 4, 1981'
$SKI 3
$CEN
^UTable of Contents|U
$SKI 2
$VER
$TABS 10,60
SECTION		PAGE
$TABS 10,62
$TOC

$ski 3
(pasdev4)m68run.pmf
 {@ G