* +--------------------------------------------------------------------+
* |                                                                    |
* |        RTIASCIT - TEXT FILE INPUT ASSOCIATION ROUTINES.            |
* |                                                                    |
* +--------------------------------------------------------------------+
*
*  PURPOSE:
*    ASSOCIATE FILE VARIABLES WITH TEXT FILE BLOCKS.
*
*  PASCAL ENTRY POINTS:
*
*    T.OPEN
*      ASSOCIATE TEXT FILE FOR INPUT ONLY.
*
*    T.RESET
*      ASSOCIATE TEXT FILE FOR INPUT ONLY, AND READ FIRST CHARACTER.
*
*  NOTES:
*    THESE ROUTINES BOTH CREATE A FILE BLOCK ON THE HEAP,
*    ASSIGN IT, AND RETURN A POINTER TO THE FILE BLOCK.  IF
*    AN ERROR IS DETECTED, THE FILE
*    BLOCK IS DISPOSED, AND A POINTER TO THE INPUT DUMMY FILE BLOCK
*    IS RETURNED.  THE ASSOCIATION ROUTINES MAY NEVER SIGNAL AN ERROR.
*    THERE IS AN INTERNAL ENTRY POINT TO T.OPEN, NAMED TXTOPNIN.
*    THIS ENTRY POINT IS INVISIBLE OUTSIDE THE MODULE.
*
*  CHANGES:
*    3/11/82 WNH:  CHANGED PARAMETER PUSH FOR THE REAL I.RNAME, AND INITIALIZED
*    FILE BLOCK RESOURCE NAME BEFORE CALLING I.RNAME.
*    3/15/82 WNH:  CHANGED ORDER OF THINGS TO MAKE ROUTINE WORK WITHOUT TTY
*    BITS AND TYPE, BUT INSTEAD RECOGNIZE TTY FROM FILE NAME VOLUME 'CN' OR
*    'CN<digit><digit>' MATCHING REGISTER A2 AT PROGRAM STARTUP.
*    8/4/82 WNH:  CHANGED TTY ASSOCIATION TO OVERRIDE ASSOCIATION OPTIONS
*    WITH OPTIONS PASSED IN ON THIS CALL.
*
* +-------------------------------------------------------------------------+
 NOLIST
 INCLUDE 1000..RTDEFS.SA
 INCLUDE 1000..RTIODEFS.SA
 INCLUDE 1000..RTIXREFS.SA
 INCLUDE 1000..RTECODES.SA
 LIST
 M$MODULE RTIASCIT,<TEXT FILE INPUT ASSOCIATION ROUTINES>,1,0
 
 XREF H.INEW
 XREF I.GETUN
 XREF I.DISPUN
 XREF H.IDISPOSE
 XREF I.RNAME
 XREF T.IGET
 XREF M.INIREG
 PAGE
* TXTOPNIN - OPEN A TEXT FILE FOR INPUT: ROUTINE INVISIBLE OUTSIDE
*            RTIASCIT.
*
* INPUT:
*   BYTES 7 AND 8.  WORD OF THE TYPE ASSOCIATION_FLAGS (SEE 1000..RTIODEFS.SA).
*   BYTES 5 AND 6.  NUMBER OF CHARACTERS IN RESOURCE NAME STRING.
*   BYTES 1 - 4.  ADDRESS OF LEFTMOST CHARACTER OF RESOURCE NAME STRING.
*
* OUTPUT:
*   BYTES 1 - 4.  ADDRESS OF FIRST BYTE IN ASSOCIATED FILE BLOCK.
*
* NOTES:
*   THROUGHOUT TXTOPNIN:
*     A0 = ADDRESS OF ASSOCIATION ROUTINE WORK AREA IN STATIC STORAGE.
*
* AUTHOR:
*   W. N. HOPE
 
*****
*
TXTOPNIN: EQU *
*
*****
 
 SPACE: EQU $20              ASCII SPACE
 
 M$DEF_LOCALS
 M$LOCAL BLOCKADR,LONG
 
 M$DEF_REGS D0,A0,A2,A3
 
 M$DEF_ARGS
 M$ARG OPTIONS,WORD          ASSIGNMENT OPTIONS PARAMETER
 M$ARG NAMELENG,WORD         RESOURCE NAME LENGTH PARAMETER
 M$ARG NAMEPOIN,LONG         RESOURCE NAME POINTER PARAMETER
 
 M$FRAME
 
 MOVE.W #E_IOOK_IO,IO.STAT(A5)
 CLR.W  IO.XSTAT(A5)
 PAGE
 LEA     IO.ASCWK(A5),A0     POINT A0 AT THE STATIC WORK AREA.  BUILD AN FHS
*                            BLOCK AND AN IOS BLOCK IN THE WORK AREA.
 
*                            SET UP FHS BLOCK FOR VERSAdos CALL.
*                            DEVICE/FILE COMMAND.
*                            ASSIGN.
 MOVE.W   #FS.DEV<<8!FS.ASSGN,FS.CODE(A0)
 
 MOVE.W   #FS.SEQ!FS.PR,FS.OPT(A0) SEQUENTIAL FILE, PUBLIC READ.
 
 CLR.L    FS.POIN(A0)        CLEAR POINTER FIELD.
 CLR.W    FS.EXT+2(A0)       CLEAR RESERVED AREA.
 CLR.W    FS.RECL(A0)        CLEAR RECORD LENGTH.
 
 MOVE.L   #$20202020,FS.VOLN(A0) SET UP DEFAULT RESOURCE NAME.
 MOVE.W   #$FFFF,FS.USN(A0)
 MOVE.L   #$20202020,FS.CAT(A0)
 MOVE.L   #$20202020,FS.CAT+4(A0)
 MOVE.L   #$20202020,FS.FNAM(A0)
 MOVE.L   #$20202020,FS.FNAM+4(A0)
 MOVE.W   #'SA',FS.EXT(A0)
 
 CLR.W    FS.WRTC(A0)        CLEAR READ AND WRITE PROTECTION CODES.
*                            PARSE FILE NAME STRING
 MOVE.L   NAMEPOIN(SP),-(SP)
 MOVE.W   NAMELENG+4(SP),-(SP)
 MOVE.L   A0,-(SP)
 JSR I.RNAME
 TST.B (SP)+
 IF <NE> THEN.S
   MOVE.W #IO.RNAME,D0
   BRA FAILED
 ENDI
 PAGE
 MOVE.L FS.VOLN(A0),D0
 CMP.L #'CN  ',D0
 IF <EQ> OR.L M.INIREG+34(A5) <EQ> D0 THEN.S
*                            USER WANTS THE TERMINAL.
   LEA IO.TTY(A5),A0
   MOVE.L A0,BLOCKADR(SP)
   MOVE.W OPTIONS(SP),D0
   OR.W D0,FB.AFLAG(A0)
 ELSE
*                               GET A UNIT NUMBER.
   E$MASK
   JSR      I.GETUN
   MOVE.B   (SP)+,D0
   CMP.B    #$FF,D0
   IF <EQ> THEN.S
     MOVE.W #IO.LUN,D0
     BRA FAILED
   ENDI
 
   MOVE.B   D0,FS.LUN(A0)      PUT THE UNIT NUMBER INTO THE FHS AND
*                                              IOS BLOCKS.
   MOVE.B   D0,FS.BLKS+1+IS.LUN(A0)
 
*                              CALL VERSAdos.
   XDEF OPNINFHS               HANDY FOR DEBUGGING.
   OPNINFHS: EQU *
   I$FHSCAL
 
*        ALL FHS CALLS LEAVE FHS STATUS IN D0.  THE LOW ORDER BYTE IS THE FHS
*        ERROR CODE.
 
   IF <NE> THEN.S              IOS SAYS SOMETHING'S WRONG.
     MOVE.B FS.LUN(A0),-(SP)
     JSR I.DISPUN
 
     BRA FAILED
   ENDI
 
*                              NEW UP A FILE BLOCK.
   MOVE.L   #FB.TSIZE,-(SP)
   JSR      H.INEW
   MOVE.L   (SP)+,A2           POINT A2 TO IT.
 
   MOVE.L   A2,BLOCKADR(SP)    PUT ITS ADDRESS IN THE LOCAL VARIABLE.
   MOVE.W   OPTIONS(SP),FB.AFLAG(A2) PUT ASSOCIATION OPTIONS IN THE
*                                                FILE BLOCK.
   MOVE.W  #E_IOOK_IO,FB.STAT(A2)
 
*                              ADD THIS TO THE LIST OF FILE BLOCKS.
   MOVE.L  IO.IDUMY+FB.FLINK(A5),D0  D0 HAS ADDRESS OF NEXT BLOCK, AND,
*                                    IF IT IS NILF, THE CONDITION CODE
*                                    Z BIT IS SET.
   MOVE.L  D0,A3                 A3 HAS THE ADDRESS OF THE NEXT BLOCK, AND
*                                    THE CONDITION CODES HAVE NOT CHANGED.
   IF <NE> THEN.S
     MOVE.L  A2,FB.BLINK(A3)     NEXT BLOCK BLINK HAS OUR ADDRESS.
   ENDI
   MOVE.L  A3,FB.FLINK(A2)     OUR FLINK HAS ADDRESS OF NEXT BLOCK.
 
   LEA     IO.IDUMY(A5),A3     A3 HAS ADDRESS OF INPUT DUMMY BLOCK.
   MOVE.L  A3,FB.BLINK(A2)     OUR BLINK HAS ADDRESS OF INPUT DUMMY BLOC
   MOVE.L  A2,FB.FLINK(A3)     INPUT DUMMY BLOCK FLINK HAS OUR ADDRESS.
 
*                              MOVE THE FHS AND IOS BLOCKS IN THE STATIC
*                              WORK AREA TO THE FILE BLOCK.
   MOVE.L A2,A3
   ADD.L #FB.FHS,A3            A3 POINTS TO FHS BLOCK IN MDSI FILE
*                                                BLOCK.
   MOVE.B #FS.BLKS+1+IS.COMP+4,D0
   REPEAT
     MOVE.L (A0)+,(A3)+
     SUB.B #4,D0
   UNTIL <EQ>
*                              INITIALIZE IOS OPTION WORD.
   MOVE.W #IS.NXT,FB.IOS+IS.OPT(A2)
*                              CLEAR RESERVED WORD AFTER LUN IN IOS BLOCK.
   CLR.W FB.IOS+IS.LUN+1(A2)
*                              POINT CURRENT RECORD NUMBER IN IOS BLOCK
*                                        TO ZERO.
   CLR.L FB.IOS+IS.RECN(A2)
*                              POINT TO START OF BUFFER IN IOS BLOCK.
   LEA    FB.TBUF(A2),A0
   MOVE.L A0,FB.IOS+IS.BUFS(A2)
*                              POINT TO END OF BUFFER.
   ADD.L #255,A0
   MOVE.L A0,FB.IOS+IS.BUFE(A2)
*                              PUT A SPACE BEFORE THE TEXT BUFFER.
   MOVE.B #SPACE,FB.TSPAC(A2)
*                              POINT CUREL TO START OF TEXT BUFFER.
   MOVE.L A2,FB.CUREL(A2)
   ADD.L  #FB.TBUF,FB.CUREL(A2)
*                              INDICATE THAT THE BUFFER IS EMPTY,
   CLR.L FB.IOS+IS.LEN(A2)
*                              INDICATE TO T.IGET THAT THE BUFFER HAS NOT YET
   MOVE.W #1<<IO.EOLN!1<<IO.EOPAGE!1<<IO.EMPBF,FB.IFLAG(A2)  BEEN FILLED.
 
   MOVE.W  #IO.VALID,FB.VALID(A2)
 ENDI END "USER WANTS TERMINAL" IF
 BRA.S ALLDONE
 
*****
*
 FAILED: EQU *
*
*****
*                            RETURN POINTER TO INPUT DUMMY BLOCK.
 LEA     IO.IDUMY(A5),A0
 MOVE.L  A0,BLOCKADR(SP)
*                            MARK FHS RESULT IN STATIC STORAGE.
 MOVE.W  D0,IO.XSTAT(A5)
*                            MARK MDSI IO_STATUS IN GLOBAL STORAGE.
 MOVE.W  #E_OPNF_IO,IO.STAT(A5)
 
*****
*
 ALLDONE: EQU *
*
*****
 
 E$UNMASK
 
 M$UNFRAME BLOCKADR(SP),LONG
 
 RTS
 PAGE
* T.OPEN - ASSOCIATE A TEXT FILE FOR INPUT
*
* INPUT:
*   BYTES 1 AND 2.  WORD OF THE TYPE ASSOCIATION_FLAGS (SEE RTDEFS.SA).
*   BYTES 3 - 6.  ADDRESS OF LEFTMOST CHARACTER OF RESOURCE NAME STRING.
*   BYTES 7 AND 8.  NUMBER OF CHARACTERS IN RESOURCE NAME STRING.
*
* OUTPUT:
*   BYTES 1 - 4.  ADDRESS OF FIRST BYTE IN ASSOCIATED FILE BLOCK.
*
* NOTES:
*   WRAPPER FOR TXTOPNIN.
*
* AUTHOR:
*   W. N. HOPE
 
**********
*
 M$ENTRY T.OPEN,POP
*
**********
 
 JSR TXTOPNIN
 M$EXIT PUSH
 PAGE
****************************************************************************
* T.RESET - ASSOCIATE A TEXT FILE FOR INPUT
*
* INPUT:
*   BYTES 1 AND 2.  WORD OF THE TYPE ASSOCIATION_FLAGS (SEE RTDEFS.SA).
*   BYTES 3 - 6.  ADDRESS OF LEFTMOST CHARACTER OF RESOURCE NAME STRING.
*   BYTES 7 AND 8.  NUMBER OF CHARACTERS IN RESOURCE NAME STRING.
*
* OUTPUT:
*   BYTES 1 - 4.  ADDRESS OF FIRST BYTE IN ASSOCIATED FILE BLOCK.
*
* NOTES:
*
* AUTHOR:
*   W. N. HOPE
 
******
*
 M$ENTRY T.RESET
*
******
 M$DEF_LOCALS
 M$LOCAL BLOCKPNT,LONG
 
 M$DEF_REGS A0,D0
 
 M$DEF_ARGS
 M$ARG OPTS,WORD             ASSIGNMENT OPTIONS PARAMETER.
 M$ARG NAMEPT,LONG           RESOURCE NAME POINTER PARAMETER.
 M$ARG NAMELEN,WORD          RESOURCE NAME LENGTH PARAMETER.
 
 M$FRAME
 MOVE.W NAMELEN(SP),-(SP)    PASS ARGUMENTS TO TXTOPNIN.
 MOVE.L NAMEPT+2(SP),-(SP)
 MOVE.W OPTS+6(SP),-(SP)
 
 JSR TXTOPNIN
 
 MOVE.L (SP)+,D0             IF FILE POINTER DOES NOT POINT TO INPUT
 MOVE.L D0,BLOCKPNT(SP)              DUMMY FILE BLOCK, ASSOCIATION
 LEA IO.IDUMY(A5),A0                 WAS SUCCESSFUL.
 CMP.L A0,D0
 IF <NE> THEN.S
    MOVE.L BLOCKPNT(SP),-(SP)
    JSR T.IGET
 ENDI
 M$UNFRAME BLOCKPNT(SP),LONG
 M$EXIT
 END
 