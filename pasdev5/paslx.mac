	TITLE	CHREAD - MACRO VERSIONS OF PASCAL COMPILER CHARACTER INPUT PROCEDURES

	SEARCH	PASSYM

	ENTRY	NEXTCH
	ENTRY	LITCH
	ENTRY	SEOF
	ENTRY	SEOLN
	ENTRY	SREADLN
	ENTRY	SREAD
	ENTRY	SGETLINENR

	EXTERN	CORTMP,TEOF,TEOLN,TREAD,TREADLN

	EXTERN	CH,ORIGCH,NEXTFILE,EOFN,COMMENTLVL
	EXTERN	ERROR,EOL,ENDOFLINE,GETNEXTLINE
	EXTERN	SOURCE,TTYI,INCLNEST,INCLFILE,INCL2FILE,INPUT,CLOSE.
	EXTERN	FWDFILEREF,FWDPAGEREF,READC.,CHCNT,LINEWIDTH,BUFFER,GETLN.
	EXTERN	LISTSOURCE,FILEDATA,IN%SYSTEM,LINES%READ,INCL%LINES%READ

	$RELOC

;
; PUBLIC PROCEDURE NEXTCH;
; 
; BEGIN
;   LITCH;
;   ORIGCH := CH;
;   CH := UPPERCASE (CH)
; END;
;
NEXTCH:	PUSHJ	TOPP,LITCH
	MOVE	REG,CH
	MOVEM	REG,ORIGCH
	CAIL	REG,"a"
	CAILE	REG,"z"
	POPJ	TOPP,
	SUBI	REG,40
	MOVEM	REG,CH
	POPJ	TOPP,

;
; PUBLIC PROCEDURE LITCH;
; BEGIN
;   IF SEOF THEN NEXTFILE;
;
LITCH:	
	PUSHJ	TOPP,SEOF
	SKIPE	FV+1(TOPP)
	PUSHJ	TOPP,NEXTFILE
;
;   IF SEOF THEN BEGIN
;
	PUSHJ	TOPP,SEOF
	SKIPN	FV+1(TOPP)
	JRST	LITCH3
;
;     IF NOT EOFN THEN BEGIN
;
	SKIPE	EOFN
	JRST	LITCH2
;
;       IF COMMENTLVL > 0 THEN ERROR (216);
;
	SKIPG	COMMENTLVL
	JRST	LITCH1
	MOVEI	REG,^D216
	PUSHJ	TOPP,ERROR
;
;       EOFN := TRUE; EOL := TRUE END;
;	LINES_READ := LINES_READ+FILEDATA[0].LINECNT-1;
;
LITCH1:	MOVEI	REG,FILEDATA
	HRRZ	REG,2(REG)
	SUBI	REG,1
	ADDM	REG,LINES%REA
	MOVEI	REG,1
	MOVEM	REG,EOFN
	MOVEM	REG,EOL
;
;     CH := ' '
;   END
;
LITCH2:	MOVEI	REG," "
	MOVEM	REG,CH
	POPJ	TOPP,
;
;   ELSE BEGIN
;     IF EOL THEN BEGIN
;
LITCH3:	SKIPN	EOL
	JRST	LITCH4
;
;       ENDOFLINE;
;       SREADLN;  IF NOT SEOF THEN GETNEXTLINE
;     END;
	PUSHJ	TOPP,ENDOFLINE
	PUSHJ	TOPP,SREADLN
	PUSHJ	TOPP,SEOF
	SKIPN	FV+1(TOPP)
	PUSHJ	TOPP,GETNEXTLINE
;
;     EOL := SEOLN;
;
LITCH4:
	PUSHJ	TOPP,SEOLN
	MOVE	REG,FV+1(TOPP)
	MOVEM	REG,EOL
;
;     IF EOL THEN CH:= ' '
;            ELSE SREAD   (* CH NO LONGER PASSED AS PARAMETER TO SREAD *)
;   END
; END;
;
	JUMPN	REG,LITCH2
					; FALL INTO SREAD
;
; PUBLIC PROCEDURE SREAD (* VAR CH: CHAR *); NO LONGER TAKES A PARAMETER
;
; BEGIN
;   CASE SOURCE OF
;
SREAD:	MOVE	REG,SOURCE
	JRST	@SREAD1(REG)
SREAD1:	EXP	SRPROMPT
	EXP	SRREAD
	EXP	SRINCL
;
;   PROMPTING:  READ (TTYI,CH);
;
SRPROMPT:
	SKIPG	CORTMP
	JRST	SREAD3
	PUSHJ	TOPP,TREAD
	JRST	SREAD4
SREAD3:
	MOVEI	REG,TTYI
	JRST	SREAD2
;
;   READING:    READ (INPUT,CH);
;
SRREAD:	
	MOVEI	REG,INPUT
	JRST	SREAD2
;
;   INCLUDING:  CASE INCLNEST OF
;                1: READ (INCLFILE,CH);
;                2: READ (INCL2FILE,CH)
;               END
;   END;
;
SRINCL:
	MOVE	REG,INCLNEST
	MOVE	REG,IFILES-1(REG)
SREAD2:
	MOVEI	REG1,CH
	PUSHJ	TOPP,READC.
;
;   CHCNT := CHCNT + 1;
;
SREAD4:
	AOS	REG,CHCNT
;
;   IF CHCNT <= LINEWIDTH THEN BUFFER[CH] := CH
; END;
;
	CAMLE	REG,LINEWIDTH
	POPJ	TOPP,
	IBP	REG,BUFBPOINT
	MOVE	REG1,CH
	DPB	REG1,REG
	POPJ	TOPP,

BUFBPOINT:
	XWD	-337100,BUFFER		; XWD 440700,BUFFER
;


;
; PUBLIC FUNCTION SEOLN;
; BEGIN
;   CASE SOURCE OF
;
SEOLN:	MOVE	REG,SOURCE
	JRST	@SEOLN1(REG)
SEOLN1:	EXP	SPROMPTING
	EXP	SREADING
	EXP	SINCLUDING
;
; PROMPTING:   SEOLN := EOLN (TTYI);
;
SPROMPTING:
	SKIPE	CORTMP
	JRST	TEOLN
	MOVEI	REG,TTYI
	MOVE	REG,FILEOL(REG)
	MOVEM	REG,FV(TOPP)
	POPJ	TOPP,
;
; READING:	SEOLN := EOLN (INPUT);
;
SREADING:
	MOVEI	REG,INPUT
	MOVE	REG,FILEOL(REG)
	MOVEM	REG,FV(TOPP)
	POPJ	TOPP,
;
; INCLUDING: BEGIN
;              CASE INCLNEST OF
;                1: SEOLN := EOLN (INCLFILE);
;                2: SEOLN := EOLN (INCL2FILE)
;              END
;   END
; END;
;
SINCLUDING:
	MOVE	REG,INCLNEST
	MOVE	REG,IFILES-1(REG)
	MOVE	REG,FILEOL(REG)
	MOVEM	REG,FV(TOPP)
	POPJ	TOPP,


;
; PUBLIC FUNCTION SEOF: BOOLEAN;
;
; BEGIN
;   CASE SOURCE OF
;
SEOF:	MOVE	REG,SOURCE
	JRST	@SEOF1(REG)
SEOF1:	EXP	SEOFPROMPT
	EXP	SEOFREAD
	EXP	SEOFINCL
;
;   PROMPTING:  SEOF := EOF (TTYI);
;
SEOFPROMPT:
	SKIPE	CORTMP
	JRST	TEOF
	MOVEI	REG,TTYI
	MOVE	REG,FILEOF(REG)
	MOVEM	REG,FV(TOPP)
	POPJ	TOPP,
;
;   READING:	SEOF := EOF (INPUT);
;
SEOFREAD:
	MOVEI	REG,INPUT
	MOVE	REG1,FILEOF(REG)
SRET:	MOVEM	REG1,FV(TOPP)
	POPJ	TOPP,
;
;   INCLUDING:   BEGIN
;                 CASE INCLNEST OF
;                1: BEGIN
;                     INCLEOF := EOF (INCLFILE);
;                     IF INCLEOF THEN CLOSE (INCLFILE)
;                   END;
;                2: BEGIN
;                     INCLEOF := EOF (INCL2FILE);
;                     IF INCLEOF THEN CLOSE (INCL2FILE)
;                   END
;               END;
SEOFINCL:
	MOVE	REG,INCLNEST
SEOF1INCL:
	MOVE	REG,IFILES-1(REG)
	MOVE	REG1,FILEOF(REG)
	JUMPE	REG1,SRET
	PUSHJ	TOPP,CLOSE.
;                IF INCLEOF THEN BEGIN
;                  FWDPAGEREF;
;                  FWDFILEREF;
;
	PUSHJ	TOPP,FWDPAGEREF
	PUSHJ	TOPP,FWDFILEREF
;
;	WITH FILEDATA[INCLNEST] DO BEGIN
;	  LINES_READ := LINES_READ + LINECNT;
;	  INCL_LINES_READ := INCL_LINES_READ + LINECNT;
;	  IF IN_SYSTEM THEN
;	    IF NOT WAS_IN_SYSTEM THEN BEGIN
;	      INSYSTEM := FALSE;
;	      LISTSOURCE := WAS_LISTING;
;	    END;
;
	MOVE	REG,INCLNEST
	IMULI	REG,5
	ADDI	REG,FILEDATA
	HRRZ	REG1,2(REG)
	SUBI	REG1,1
	ADDM	REG1,LINES%READ
	ADDM	REG1,INCL%LINES%READ
	SKIPN	IN%SYSTEM
	JRST	SEOF2
	HRRZ	REG1,4(REG)
	TRZE	REG1,400000
	JRST	SEOF2
	SETZM	IN%SYSTEM
	TRNN	REG1,200000
	JRST	SEOF2
	MOVEI	REG1,1
	MOVEM	REG1,LISTSOURCE
;
;                INCLNEST := INCLNEST - 1;
;                IF INCLNEST THEN SOURCE := READING;
;                SEOF := SEOF()
;              END
;
SEOF2:	SOSE	REG,INCLNEST
	JRST	SEOF1INCL
	MOVEI	REG,1
	MOVEM	REG,SOURCE
	JRST	SEOFREAD
;
;              ELSE SEOF := FALSE
;            END
;   END
; END;
;

; PUBLIC PROCEDURE SREADLN;
;
; BEGIN
;   CASE SOURCE OF
;
SREADLN:
	MOVE	REG,SOURCE
	JRST	@SL1(REG)
SL1:	XWD	0,SLPROMPT
	XWD	0,SLREAD
	XWD	0,SLINCL
;
;   PROMPTIN:  READLN (TTYI);
;
SLPROMPT:
	SKIPE	CORTMP
	JRST	TREADLN
	MOVEI	REG,TTYI
	JRST	GETLN.
;
;   READING:   READLN (INPUT);
;
SLREAD:
	MOVEI	REG,INPUT
	JRST	GETLN.
;
;   INCLUDING:  CASE INCLNEST OF
;                1: READLN (INCLFILE);
;                2: READLN (INCL2FILE)
;               END
;   END
; END;
;
SLINCL:	
	MOVE	REG,INCLNEST
	MOVE	REG,IFILES-1(REG)
	JRST	GETLN.

;
; PUBLIC PROCEDURE SGETLINENR (VAR LINENR: LINENRTYPE);
; 
; BEGIN
;   CASE SOURCE OF
;
SGETLINENR:
	MOVE	REG1,SOURCE
	JRST	@SGETL1(REG1)
SGETL1:	XWD	0,SGETPROMPTL
	XWD	0,SGETREADLN
	XWD	0,SGETINCLN
;
;   PROMPTING:   LINENR := '-----';
;
SGETPROMPTLN:
	MOVE	REG1,[ASCII /-----/]
	MOVEM	REG1,0(REG)
	POPJ	TOPP,
;
;   READING:    GETLINENR (INPUT, LINENR);
;
SGETREADLN:
	MOVEI	REG1,INPUT
	MOVE	REG1,FILLNR(REG1)
	MOVEM	REG1,0(REG)
	POPJ	TOPP,
;
;   INCLUDING:  CASE INCLNEST OF
;                1: GETLINENR (INCLFILE,LINENR);
;                2: GETLINENR (INCL2FILE, LINENR)
;               END
;   END
; END;
;
SGETINCLN:
	MOVE	REG1,INCLNEST
	MOVE	REG1,IFILES-1(REG1)
	MOVE	REG1,FILLNR(REG1)
	MOVEM	REG1,0(REG)
	POPJ	TOPP,

IFILES:	XWD	0,INCLFILE
	XWD	0,INCL2FILE

	
	$LIT
	PRGEND
	TITLE	MACNEST - MACRO versions of PASCAL nesting procedures

	SEARCH	PASSYM

	EXTERN	FIRSTNESTSETONLINE
	EXTERN	NESTLV
	EXTERN	PNESTLV

	ENTRY	INCNEST
	ENTRY	DECNEST
	ENTRY	SETNEST
	ENTRY	ZERONEST

	$RELOC

;
; PUBLIC PROCEDURE SETNEST;
; BEGIN
;   IF FIRSTNESTSETONLINE THEN BEGIN
;     PNESTLV := NESTLV;
;     FIRSTNESTSETONLINE := FALSE;
;   END
; END;
;
SETNEST:
	SKIPN	FIRSTNESTSETONLINE
	POPJ	TOPP,
	MOVE	REG,NESTLV
	MOVEM	REG,PNESTLV
	SETZM	FIRSTNESTSETONLINE
	POPJ	TOPP,

;
; PUBLIC PROCEDURE ZERONEST;
; BEGIN
;   NESTLV := 0;
;   IF FIRSTNESTSETONLINE THEN BEGIN
;     PNESTLV := 0;
;     FIRSTNESTSETONLINE := FALSE;
;   END
; END;
;
ZERONEST:
	SETZM	NESTLV
	SKIPN	FIRSTNESTSETONLINE
	POPJ	TOPP,
	SETZM	PNESTLV
	SETZM	FIRSTNESTSETONLINE
	POPJ	TOPP,

;
; PUBLIC PROCEDURE INCNEST;
; BEGIN
;   NESTLV := NESTLV + 1
; END;
;
INCNEST:
	AOS	NESTLV
	POPJ	TOPP,

;
; PUBLIC PROCEDURE DECNEST;
; BEGIN
;   NESTLV := NESTLV - 1
; END;
;
DECNEST:
	SOS	NESTLV
	POPJ	TOPP,
	END
  