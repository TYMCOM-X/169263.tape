	TITLE	PASIOU - PASCAL I/O PACKAGE - UUO DEPENDANT CODE
	SUBTTL	INTRODUCTION

	SEARCH	PASSYM		;BRING IN REGISTER DEFINITIONS, ETC.


;
; THIS MODULE CONTAINS ALL MONITOR DEPENDENT CODE (I
; HOPE).   THE GOAL IS TO ISOLATE ALL MONITOR-RELATED
; CODE (EG - UUOS) TO HERE, MAKING IT POSSIBLE TO TRANSPORT
; THE RUN-TIME SYSTEM ACROSS OPERATING SYSTEMS MORE
; EASILY.  THIS GOAL IS NOT FULLY REALIZED; MANY PASCAL RUN-TIME
; MODULES CONTAIN TRMOP. UUOS.  BUT THIS IS A START.
;

;
; ENTRY POINTS DEFINED BY THIS MODULE
;
	ENTRY	PUTCH.
	ENTRY	FLIST.
	ENTRY	GETLN.
	ENTRY	GET.
	ENTRY	PUTLN.
	ENTRY	PUT.
	ENTRY	RESET.
	ENTRY	OPEN.
	ENTRY	REWRT.
	ENTRY	FIXSP.
	ENTRY	BREAK.
	ENTRY	TTYOP.
	ENTRY	PUTPG.
	ENTRY	GETCH.
	ENTRY	GETCN.
	ENTRY	FRECN.
	ENTRY	CLOSE.
	ENTRY	TWAIT.
	ENTRY	CONER.
	ENTRY	PASSCC
	ENTRY	FLTRCC
	ENTRY	PASSCR
	ENTRY	FLTRCR



;
; ENTRY POINTS USED BY THIS MODULE
;
	EXTERN	END.
	EXTERN	DIE.
	EXTERN	WRTPC.
	EXTERN	PRFID.
	EXTERN	CORER.
	EXTERN	BFPAD.


;
; CONSTANTS
;
	MAXEOF=2
	DV.DSK==200000		;DEVCHR - DEVICE IS A DISK


	$RELOC			;THIS IS A TWO SEGMENT MODULE
	$HIGH			;START WITH THE CODE

	SUBTTL	'GET' AND 'READ' SUPPORT

;
; 'GETLIN'
;
GETLN.:	SKIPA	BFPNT,FILBUF(REG) ;GETS NEXT LINE
	PUSHJ	TOPP,GETCH.+1	;ALREADY HAVE BUFFER POINTER
	SKIPN	FILEOL(REG)	;END OF LINE?
	JRST	.-2

;	AT END OF LINE, FALL INTO GETCH TO GET FIRST CHARACTER
				;WILL BE OVERREAD



;
; 'GET' FOR TEXT FILE
;
GETCH.:	MOVE	BFPNT,FILBUF(REG) ;GET BUFFER POINTER
	SKIPE	FILEOF(REG)	;EOF ?,(GETCH GETS ONE CHARACTER,TEXTFILES ONLY)
	JRST	GETEOF		;YES - TEST WETHER TOO MANY
				;ATTEMPTS TO OVERREAD EOF
GETCNT: MOVE  AC1,FILCNT(REG)	;GET TRANSFER WORD FOR FILECOMPONENT
	JUMPGE AC1,GTCTEST	;REMAINING BLANKS FREE?
	AOBJP AC1,.+1		;YES - INCREMENT CHARACTERCNT
				;(WILL NEVER JUMP)
	TLNN AC1,7		;CHARACTERCNT IS ZERO MODE 7
	TLZ  AC1,400000 	;YES - CLEAR TAB INDICATOR
	JRST	GETRET
GTCTEST:SOSGE	BUFBTC(BFPNT)	;ANY BYTE LEFT IN BUFFER ?
	JRST		GTCBUF	;NO - GO FOR NEXT BUFFER
	ILDB AC0,BUFBTP(BFPNT)	;GET NEXT BYTE
	MOVEM AC0,(AC1) 	;DEPOSIT IT IN FILE COMPONENT
	AOBJN AC1,GTCTEST	;NEVER JUMPS
	SETZM	FILEOL(REG)	;RESETS FILEOL IN ASCII-FILE
	CAIL	 AC0, " "	;BELOW BLANK ?
	JRST	GETLNR		;NO - TEST FOR LINENUMBER OR PAGEMARK
	CAIN	AC0,33		; ESCAPE - LEAVE ESC IN FILCMP
	JRST	GTCEOL
	CAIN	AC0,7		; BELL -LEAVE IT IN FILCMP
	JRST	GTCEOL
	JRST	@GTCHCC		; GOTO GENERAL CONTROL CHARACTER HANDLER
GTCFCC:	CAIN	AC0,11		; FILTER CNTRL CHARS - EXPAND TABS
	JRST	GETTAB
	CAIN	AC0,12		;LINE FEED IN FLTRCC MODE
	JRST	GTCBLK		;IS TREATED NORMALLY
	JRST	GETCNT
GTCPCC:	CAIN	AC0,0		; PASS CNTRL CHARS - EXCEPT CR, NUL
	JRST	GETCNT
	CAIN	AC0,15
	JRST	@GTCHCR		;GENERAL CR PROCESSOR
				;EITHER GETCNT(SKIP) OR GETRET(RETURN IT)
	CAIN	AC0,12		;LINE FEED?
	JRST	@GTCHLF		;LF PROCESSING IN PASSCC MODE DEPENDS ON CR MODE
	JRST	GETRET		; PASS IT ON
GTCBLK:	MOVEI	AC0," "		; SET BLANK AT EOL
	MOVEM	AC0,FILCMP(REG)
GTCEOL:	MOVEI	AC1,1		;NEVER LET EOLN BE > 1
	MOVEM	AC1,FILEOL(REG)	;SET EOLN
	SETZ AC1,		;CLEARS CHARACTERCOUNT
	JRST	GETRET
GETTAB: TLNE AC1,7		;IS THIS TAB ON
				;CHARACTERCOUNT  MODULO 8 = 0
	TLO  AC1,400000 	;NO -SETS TAB INDICATOR
	JRST GETBLK		;GET BLANK IN FILECOMPONENT
GETLNR: MOVEI AC0,1		;TEST FOR LINENR OR PAGEMARK
	TDNN  AC0,@BUFBTP(BFPNT) ;LAST BIT EQUAL ZERO?
	JRST	GETRET		;YES - RETURN
	MOVE  AC1,@BUFBTP(BFPNT) ;NO - GET LINENUMBER OR PAGEMARK
	TRZ   AC1,1		;BIT 35 TO ZERO
	MOVEM AC1,FILLNR(REG)	;STORE IT TO FILLNR
	MOVE  AC0,BUFBTC(BFPNT)
	SUBI  AC0,5		;TO OVERREAD LAST FOUR DIGITS AND TAB
	JUMPGE AC0,GETNCP	;ALL THIS FIVE CHARACTERS IN THIS BUFFER?
	XCT	FILIN(REG)	;NO - GET NEXT BUFFER
	PORTAL	.+2		;NORMAL RETURN
	PORTAL	SETEOF		;EOF OR ERROR RETURN
	IBP	BUFBTP(BFPNT)	;TO OVERREAD TAB OR FIRST CARRIGE RETURN
	SOS	BUFBTC(BFPNT)
	JRST	.+3
GETNCP: MOVEM AC0,BUFBTC(BFPNT)	;RESTORE BYTECOUNT
	AOS	BUFBTP(BFPNT)	;INCREMENTS BYTEPOINTER BY 5
				; 4 DIGITS AND TAB
	CAME   AC1,[ASCII/     /] ;PAGE MARK ?
	JRST	GET..1		;NO - GET NEXT CHARACTER
	MOVEI	AC1,1		;TRUE IS 1
	MOVEM   AC1,FILEOL(REG)	;YES - SET END OF LINE
	SETZ   AC1,		;CHARACTERCNT TO ZERO
	JRST	GETBLK
GET..1:	HRRZS	FILCNT(REG)	;SETS CHARACTERCOUNT TO ZERO
	JRST	GETCH.		;GETS NEXT CHARACTER IN FILCMP
GETBLK: MOVEI AC0," "
	MOVEM AC0,FILCMP(REG)
GETRET: HLLM AC1,FILCNT(REG)	;SAVES NEW CHARACTERCNT AND TAB INDICATOR
	POPJ TOPP,
GTCBUF: XCT	     FILIN(REG) ;GET NEXT BUFFER
	PORTAL	     GTCTEST	;OK
	PORTAL	     SETEOF	;EOF OR ERROR
GETEOF: AOSGE	     FILEOF(REG) ;TOO MANY ATTEMPTS ?
	POPJ   TOPP,		;NO - RETURN
	PUSHJ	TOPP,	TWAIT.	;EMPTY TERMINAL BUFFER
	OUTSTR [ASCIZ /
?Attempt to read beyond EOF on /]
	PUSHJ	TOPP,WRTFNM	;WRITE FILE NAME
	JRST	DIE.		;GET TO DDT, OR EXIT



;
; 'GET' FOR NON-TEXT FILE
;
GET.:	HRRZ	BFPNT,FILBUF(REG) ;GET BUFFER POINTER
	SKIPE	FILEOF(REG)	;EOF?
	JRST	GETEOF		;YES-TEST WETHER TOO MANY ATTEMPTS TO OVERREAD EOF
	MOVE	AC1, FILCNT(REG) ;GET TRANSFER WORD  FOR FILECOMPONENT
GETEST: SOSGE	BUFBTC(BFPNT)	;ANY BYTE LEFT IN BUFFER?
	JRST	GETBUF		;NO	-GO FOR NEXT BUFFER
	ILDB	AC0, BUFBTP(BFPNT) ;GET NEXT BYTE
	MOVEM	AC0, (AC1)	;DEPOSIT IT IN FILECOMPONENT
	AOBJN	AC1, GETEST	;MORE BYTES IN THIS COMPONENT?
	POPJ	 TOPP,		;NO ,RETURN
GETBUF: XCT	FILIN(REG)	;GET NEXT BUFFER
	PORTAL	GETEST		;OK
	PORTAL	SETEOF		;EOF OR ERROR


	SUBTTL	'PUT' AND 'WRITE' SUPPORT

;
; 'PUT' FOR TEXT FILE
;
PUTCH.:	MOVE	BFPNT,FILBUF(REG) ;GET BUFFER HEADER
 SKIPG	FILEOF(REG)		;EOF?,(PUTCH. OUTPUTS ONE CHARACTER,TEXTFILES ONLY,
				;CHARACTER MUST BE IN AC0
	JRST	PUTNEOF 	;NO
PTCTEST:SOSGE	BUFBTC(BFPNT)	;SPACE LEFT IN BUFFER?
	JRST	PTCBUF		;NO-GO FOR NEXT BUFFER
	IDPB  AC0, BUFBTP(BFPNT) ;DEPOSIT CHARACTER IN OUTPUT BUFFER
	POPJ	 TOPP,		;RETURN
PTCBUF: XCT	FILOUT(REG)	;OUTPUT BUFFER
	PORTAL	PTCTEST 	;OK
	PORTAL	PUTERR		;OUTPUT ERROR



;
; 'PUT' FOR NON-TEXT FILE
;
PUT.:	MOVE	BFPNT,FILBUF(REG) ;BUFFER HEADER
	SKIPG	     FILEOF(REG) ;EOF ?
	JRST	     PUTNEOF	;NO
	MOVE  AC1,FILCNT(REG)	;GET TRANSFER COUNT
				;FOR FILE COMPONENT
PUTEST: SOSGE	     BUFBTC(BFPNT) ;SPACE LEFT IN BUFFER ?
	JRST	     PUTBUF	;NO - GO FOR NEXT BUFFER
	MOVE  AC0,(AC1) 	;GET NEXT WORD OF COMPONENT
	IDPB  AC0,BUFBTP(BFPNT)	;DEPOSIT IN OUTPUT BUFFER
	AOBJN AC1,PUTEST	;MORE WORDS IN COMPONENT ?
	POPJ	TOPP,		;NO
PUTBUF: XCT	     FILOUT(REG) ;OUTPUT BUFFER
	PORTAL	     PUTEST	;OK
	PORTAL	PUTERR
PUTERR:	PUSHJ	TOPP,	TWAIT.
	OUTSTR [ASCIZ /
?Output error: Disk space exhausted for file /]
	PUSHJ	TOPP,WRTFNM	;WRITE FILE NAME
	JRST	DIE.		;TRANSFER TO DDT, OR EXIT
PUTNEOF:MOVE	AC0,[SIXBIT/SINK  /] ; IF THIS IS SPECIAL SINK DEVICE
	CAMN	AC0,FILDEV(REG)	; THEN IGNORE PUT
	POPJ	TOPP,
	PUSHJ	TOPP,	TWAIT.
	OUTSTR [ASCIZ /
?Rewrite(/]
	PUSHJ	TOPP,WRTFNM
	OUTSTR [ASCIZ /) required./]
	JRST	DIE.		;TRANSFER TO DDT, OR DIE



;
; PUT NEW LINE
;
PUTLN.:	MOVEI  AC0,15		;CR
	PUSHJ TOPP,PUTCH.
	MOVEI  AC0,12		;LF
	PUSHJ TOPP,PUTCH.
	POPJ  TOPP,



;
; PUT NEW PAGE
;
PUTPG.:	MOVEI AC0 ,15		;<CR>
	PUSHJ TOPP,PUTCH.	;
	MOVEI AC0 ,14		;<FF>
	PUSHJ TOPP,PUTCH.
	POPJ  TOPP,


	SUBTTL	WRITE FILE NAME

WRTFNM: HRRI   REG1,FILNAM(REG) ;ADDRESS OF FILENAME
	HRLI  REG1,440600	;SET UP BYTE POINTER
	MOVEI REG2,  6		;CHARACTER COUNT
	ILDB  REG3,REG1 	;GET NEXT CHARACTER
	ADDI  REG3, 40		;CONVERT TO ASCII
	OUTCHR	     REG3
	SOJG  REG2, .-3 	;MORE CHARACTERS ?
	MOVEI REG3,  56 	;INSERT PERIOD
	OUTCHR	     REG3
	MOVEI REG2, 3		;TYPE EXTENSION
	ILDB  REG3,REG1
	ADDI  REG3, 40
	OUTCHR	     REG3
	SOJG  REG2, .-3 	;ALL THREE BYTES TRANSFERRED ?
	POPJ	TOPP,		;RETURN

	SUBTTL	'RESET' AND 'OPEN' ROUTINES

;
; RESET (OPEN AND FIRST READ) OF FILE.
; AT ENTRY,
;	(REG) = ADDR OF FILE BLOCK
;	(REG1) = BYTE POINTER TO STRING FILE NAME
;	(REG2) = LENGTH OF FILE NAME STRING
;
RESET.:	PUSHJ	TOPP,	OPNDO	; OPEN THE FILE FOR READ
	MOVEI	AC0,17		;TEXT FILE?
	TDNN	AC0,FILSTA(REG)	;TEST MODE
	JRST	GETCH.		;YES, GET FIRST ELEMENT
	JRST	GET.		;NO, GET FIRST GROUP



;
; OPEN A FILE.
; PARMS ARE SAME AS TO RESET 
;
OPEN.:	PUSHJ	TOPP,	OPNDO	; OPEN THE FILE FOR READ
	MOVEI	AC0,17		;TEXT FILE?
	TDNE	AC0,FILSTA(REG)	;TEST MODE
	POPJ	TOPP,0		; NO NOTHING TO DO
	MOVEI	AC0,1		; TEXT, SET EOL ON
	MOVEM	AC0,FILEOL(REG)
	MOVEI	AC0," "		; AND PUT A BLANK IN THE FILE COMPONENT
	MOVEM	AC0,FILCMP(REG)
	POPJ	TOPP,0

OPNDO:	SETZ	AC0		;FLAG AS READ
	PUSHJ	TOPP,REOPEN	;AND DO THE WORK
	SKIPE	FILEOF(REG)	;ERROR?
	JRST	SETEOF		;YES, JUST SET EOF TRUE
	MOVE	AC0,FILLKP(REG)	;NO, SET UP FOR EXTENDED LOOKUP
	HRRI	AC0,2(TOPP)
	MOVEI	AC1,4		;LENGTH OF LOOKUP BLOCK
	DMOVEM	AC0,1(TOPP)
	MOVE	AC0,FILPPN(REG)
	MOVEM	AC0,3(TOPP)
	DMOVE	AC0,FILNAM(REG)
	DMOVEM	AC0,4(TOPP)
	XCT	1(TOPP)		;PERFORM THE LOOKUP
	PORTAL	SETEOF
	PORTAL	.+1
	MOVE	AC0,3(TOPP)	;GET THE ACTUAL PPN
	MOVEM	AC0,FILPPN(REG)
	POPJ	TOPP,

	SUBTTL	'REWRITE' ROUTINE

;
; OPEN A FILE FOR OUTPUT.
;
; PARMS ARE SAME AS TO 'OPEN', EXCEPT:
;	(REG3) = APPEND FLAG
;
REWRT.:	SETO	AC0,		;SET FLAG TO WRITE
	MOVEM	REG3,OPNMOD	;SAVE MODE
	PUSHJ	TOPP,REOPEN	;DO THE WORK
	AOSG	FILEOF(REG)	;ERROR?
	JRST	CLREOF		;YES, GIVE ERROR RETURN
	SOSE	OPNMOD		;CHECK MODE
	JRST	NOTAPP		;NOT APPEND
	PUSH	TOPP,FILPPN(REG) ;SAVE PPN
	XCT	FILLKP(REG)	;LOOK FOR FILE
	 PORTAL	[POP TOPP,FILPPN(REG) ;TREAT AS NOT APPEND IF NOT THERE
			JRST NOTAPP]
	PORTAL	.+1
	SETZM	FILPRO(REG)	;DON'T CHANGE PROTECTIONS
	HLLZS	FILEXT(REG)	;AND FIX UP BLOCK
	POP	TOPP,FILPPN(REG)
	XCT	FILENT(REG)	;ENTER FILE
	  PORTAL,CLREOF		;ERROR RETURN
	PORTAL	.+1
	HLLO	AC0,FILENT(REG)	;CONSTRUCT A USETI , -1
	TLC	AC0,003000
	XCT	FILOUT(REG)	;DO DUMMY OUTPUT
	 PORTAL	.+2		;GOOD
	 PORTAL	CLREOF		;BAD
	XCT	AC0		;POSITION
	POPJ	TOPP,0		;AND EXIT
 
NOTAPP:	HLLZS	FILEXT(REG)	;CLEAR DATE FIELDS
	HLLZ	AC1,FILPRO(REG)	;TO BE CERTAIN
	TLZ	AC1,37		;THE CREATION DATE
	MOVEM	AC1,FILPRO(REG)	;IS SET BY THE MONITOR
	XCT	FILENT(REG)	;DO ENTER
	 PORTAL	CLREOF		;FAILURE, DO ERROR RETURN
	PORTAL	.+1
	XCT	FILOUT(REG)	;DO DUMMY OUTPUT
	PORTAL	CPOPJ		;OK, EXIT
	 PORTAL	CLREOF		;ERROR
 
CLREOF:	SETZM	FILEOF(REG)	;SET EOF FALSE
CPOPJ:	POPJ	TOPP,0		;AND RETURN

	SUBTTL	CENTRAL ROUTINE FOR 'RESET', 'OPEN', AND 'REWRITE'

;
; PREPARE A FILE FOR USE.
;
; PARMS ARE AS TO OPEN AND REWRITE.
; ALSO, (AC0) = READ/WRITE FLAG
;
REOPEN:	SETZM	FILEOF(REG)	;ASSUME IT WILL WORK
	SKIPE	FILLNK(REG)	;IS FILE ALREADY IN LIST?
	JRST	INLIST		;YES, CONTINUE
	MOVE	AC1,FILLST	;MUST CHECK IF IN LIST ANYWAY
	JUMPE	AC1,ADDTO	;MUST ADD IF LIST EMPTY
REOPN1:	CAIN	AC1,(REG)	;FOUND FILE BLOCK IN LIST?
	JRST	INLIST		;YES
	MOVE	AC1,FILLNK(AC1)	;NO, KEEP LOOKING
	JUMPN	AC1,REOPN1	;CHECK IF NOT LAST FILE
ADDTO:	MOVE	AC1,FILLST	; PUT IT ON
	MOVEM	REG,FILLST
	MOVEM	AC1,FILLNK(REG)
INLIST:	MOVEM	AC0,FILRWF(REG)	;SAVE RESET/REWRITE FLAG
	SETZM	FILEOL(REG)	; FOR CONSISTENCY
	MOVE	AC0,[ASCII /-----/]
	MOVEM	AC0,FILLNR(REG)
	PUSH	TOPP,FILDEV(REG) ;SAVE OLD DEVICE
	JUMPE	REG2,NONAME	;NAME SPECIFIED - LENGTH <> 0 ??
	PUSHJ	TOPP,PRFID.	; PARSE FILE ID
	JRST	[POP	TOPP,	; ERROR RETURN, UNWIND STACK
		 JRST	SETEOF]
NONAME:	POP	TOPP,REG2	;RESTORE DEVICE
	MOVE	REG1,FILSTA(REG) ;MODE
	MOVEI	AC0,REG1	;SET UP FOR DEVSIZ
	SKIPN	BFPNT,FILBUF(REG) ;GOT BUFFERS YET?
	JRST	NEWBUF		;NO, MUST GET SOME
	HRRZ	AC1,BUFUCT(BFPNT) ;GET USE COUNT
	SOJG	AC1,NEWBUF	;MUST GET NEW ONES IF OTHER USERS
	DEVSIZ	AC0,		;GET BUFFER SIZE
	 JFCL			;IF IT FAILS IT FAILS
	MOVEI	AC1,	FILSTA(REG) ;GET NEW ONE
	DEVSIZ	AC1,		;ITS SIZE
	 JFCL
	CAMN	AC0,AC1		;USE SAME SIZE BUFFERS?
	JRST	[XCT FILCLS(REG) ;YES, DO A CLOSE
			JRST SETBUF] ;AND SET UP NEW BUFFERS
NEWBUF:	PUSHJ	TOPP,CLOSE.	;RELEASE OLD BUFFERS AND CHANNEL
	SETZM	FILBUF(REG)	;AND CLEAR OUT POINTER
	MOVE	AC0,FILDEV(REG)	;CHECK DEVICE
	MOVE	AC1,AC0
	DEVCHR	AC1,		;CHARACTERISTICS
	JUMPE	AC1,SETEOF	;IT DOESN'T EXIST!!
	TLNE	AC1,DV.DSK	;IS IT A DISK?
	JRST	NEWBF1		;YES, CAN'T SHARE BUFFERS
	MOVEI	REG1,FILLST-FILLNK ;SET UP FOR SEARCH
FILSLP:	HRRZ	REG1,FILLNK(REG1) ;GET NEXT FILE TABLE
	JUMPE	REG1,NEWBF1	;SEARCH ENDS IN FAILURE
	SKIPN	FILBUF(REG1)	;GOT BUFFERS?
	JRST	FILSLP		;NO
	MOVE	AC0,FILDEV(REG)	;GET DEVICE
	CAME	AC0,FILDEV(REG1) ;DEVICES MATCH?
	JRST	FILSLP		;NO
	MOVE	AC0,FILRWF(REG)	;IS THIS ONE READING
	XOR	AC0,FILRWF(REG1) ;IS THIS ONE WRITING?
	JUMPN	AC0,FILSLP	;JUMP OUT IF NOT THE SAME
	HRRZ	BFPNT,FILBUF(REG1) ;MATCH, GET BUFFER POINTER
	HLRZ	AC0,FILCHN(REG1) ;AND CHANNEL
	JRST	NEWBF2		;AND WE'RE OFF
NEWBF1:	MOVEI	REG1,FILSTA(REG) ;GET DEVICE
	DEVSIZ	REG1,		;FIND AMOUNT OF SPACE NEEDED
	 JRST	SETEOF		;NO SUCH DEVICE?
	JUMPLE	REG1,SETEOF	;DITTO
	HLRZ	AC1,REG1	;NUMBER OF BUFFERS
	IMULI	AC1,(REG1)	;TIMES SIZE
	PUSH	TOPP,REG	;SAVE
	MOVEI	REG,BUFBFR(AC1)	;SPACE FOR RING HEADER
	PUSHJ	TOPP,BUFGET	;GET SPACE
	MOVE	BFPNT,REG	;TO BFPNT
	POP	TOPP,REG	;RESTORE FILE TABLE POINTER
	SETZM	BUFUCT(BFPNT)	;ZERO USE COUNT, INC IN A MOMENT
	PUSHJ	TOPP,GETCN.	;GET A CHANNEL
NEWBF2:	AOS	BUFUCT(BFPNT)	;BUMP USE COUNBT
	HRLZM	AC0,FILCHN(REG)	;PUT CHANNEL IN TABLE
	DPB	AC0,[POINT 4,FILIN(REG),12] ;AND IN UUO'S
	DPB	AC0,[POINT 4,FILOUT(REG),12]
	DPB	AC0,[POINT 4,FILOPN(REG),12]
	DPB	AC0,[POINT 4,FILENT(REG),12]
	DPB	AC0,[POINT 4,FILLKP(REG),12]
	DPB	AC0,[POINT 4,FILCLS(REG),12]
	HRRM	BFPNT,FILBUF(REG) ;STORE BUFFER POINTER
SETBUF:	MOVEI	AC0,17		;TEXT FILE?
	TDNN	AC0,FILSTA(REG)	;TEST MODE
	HRRZS	FILCNT(REG)	;YES, CLEAR COUNT
	MOVEI	AC0,1(BFPNT)	; PREVENT RELOCATION?????
;	MOVEI	AC0,BUFBFH(BFPNT)	;GET HEADER ADDRESS
	SKIPE	FILRWF(REG)	;SKIP IF INPUT
	HRLZS	AC0,AC0		;POSITION FOR WRITE
	MOVEM	AC0,FILBFH(REG)	;STORE
	XCT	FILOPN(REG)	;OPEN
	 PORTAL	SETEOF		;FAILURE
	PORTAL	.+1
	MOVEI	AC0,FILSTA(REG)	;GET DEVICE
	DEVSIZ	AC0,		;DEVSIZ
	 MOVSI	AC0,2		;DEFAULT TO 2
	HLRZS	AC0		;NUMBER OF BUFFERS
	HLL	AC0,FILOPN(REG)	;GET OPEN
	TLZ	AC0,777000	;CLEAR OPCODE
	SKIPE	FILRWF(REG)	;READ OR WRITE?
	TLOA	AC0,(OUTBUF)	;WRITE
	TLO	AC0,(INBUF)	;READ
	PUSH	TOPP,.JBFF##	;SAVE JOBFF
	MOVEI	AC1,BUFBFR(BFPNT) ;PLACE FOR ACTUAL BUFFERS
	MOVEM	AC1,.JBFF##
	XCT	AC0		;SET UP BUFFERS
	POP	TOPP,.JBFF##	;RESTORE JOBFF
	SETZB	REG1,REG2	;CLEAN UP FOR INITIALIZATION
	SETZB	REG3,REG4
	SETZ	REG5,
	POPJ	TOPP,		;AND RETURN

	SUBTTL	'CLOSE' ROUTINE

;
; PERFORM A LOGICAL CLOSE OF A FILE.
;
CLOSE.:	SKIPN	BFPNT,FILBUF(REG) ;ALREADY CLOSED
	POPJ	TOPP,0		;YES, NOTHING TO DO
	SETZM	FILBUF(REG)	;DONE NOW
	SOSLE	AC0,BUFUCT(BFPNT) ;DECREMENT USE COUNT
	POPJ	TOPP,0		;STILL POSITIVE, SOMEBODY ELSE IS USING
	XCT	FILCLS(REG)	;MAKE SURE FILE IS CLOSED
	HLRZ	AC0,BFPNT	;GET CHANNEL
	PUSHJ	TOPP,FRECN.	;RELEASE IT
	PUSH	TOPP,REG	;SAVE REG
	HRRZ	REG,BFPNT	;GET SPACE POINTER
	PUSHJ	TOPP,BUFREE	;AND RELEASE IT
	POP	TOPP,REG
	POPJ	TOPP,0


	SUBTTL	I/O CHANNEL ALLOCATION/DEALLOCATION

GETCN.:	MOVE	AC0,CHNTAB	;GET ALLOCATION BIT TABLE
	JFFO	AC0,GTCHN1	;FIND FIRST CHANNEL IF ANY
 
CHNERR:	PUSHJ	TOPP,	TWAIT.
	OUTSTR	[ASCIZ .
?Too many I/O channels in use.]
	PUSHJ	TOPP,WRTPC.
	JRST	DIE.		;TRANSFER TO DDT, OR EXIT
 
GTCHN1:	CAILE	AC1,17		;MAKE SURE IT'S IN RANGE
	JRST	CHNERR		;IT WASN'T
	MOVNS	AC1		;NEGATE
	MOVSI	AC0,(1B0)	;MARK CHANNEL IN USE
	LSH	AC0,(AC1)
	ANDCAM	AC0,CHNTAB
	MOVN	AC0,AC1		;RESULT IN AC0
	POPJ	TOPP,0
 
FRECN.:	MOVN	AC1,AC0		;CHANNEL TO RELEASE
	MOVSI	AC0,(1B0)
	LSH	AC0,(AC1)
	IORM	AC0,CHNTAB	;FREE CHANNEL
	POPJ	TOPP,0		;AND RETURN

	SUBTTL	BUFFER ALLOCATION

;
;     BUFFER ALLOCATION ROUTINES;  BUFFERS ARE PLACED AT THE END OF THE
;     STACK AREA, GROWING DOWNWARD TOWARD THE STACK.  WHEN A BUFFER IS
;     ALLOCATED, THE BUFFER AREA IS SEARCHED FOR A FREE BUFFER OF 
;     THE CORRECT SIZE.  IF NOT FOUND, THE AREA IS EXTENDED FOR A NEW
;     BUFFER.   WHEN A BUFFER IS FREED, A COLLASPSE IS DONE ON THE
;     BUFFER AREA, THAT IS, ALL FREE BUFFERS CONTIGUOUS WITH THE END OF
;     THE AREA ARE FREED.  THE USECOUNT (BUFUCT) IS USED AS A FREE
;     FLAG, AND A HIDDEN SIZE WORD PLACED IN FRONT OF THE BUFFER IS KEPT.
;
BUFGET:	SKIPN	BFPAD.		; BUFFER POINTER SET UP YET?
	JRST	[HLRZ AC0,.JBSA##;NO GET INITIAL JOBFF
		MOVEM AC0,BFPAD.; AND STORE
		JRST .+1]
	HRRZ	AC1,BFPAD.	; GET BASE OF FILE AREA (1ST BUFFER)
	HLRZ	AC0,.JBSA##	; GET UPPER LIMIT OF AREA (START OF HEAP)
	ADDI	REG,1		; ONE EXTRA WORD FOR SIZE
BTRY:	CAML	AC1,AC0		; CONTINUE SEARCH WHILE IN AREA
	JRST	BNEW
	SKIPE	BUFUCT+1(AC1)	; CHECK IF USE COUNT = 0
	JRST	BNEXT
	CAMN	REG,0(AC1)	; SEE IF TI HAS CORRECT SIZE
	JRST	BFND
BNEXT:	ADD	AC1,0(AC1)	; ADVANCE TO NEXT BUFF BY ADDING HIDDEN SIZE
	JRST	BTRY
 BNEW:	HRRZ	AC1,BFPAD.	; ALLOCATE NEW BUFFER BY EXTENDING AREA
	SUB	AC1,REG		; ... DOWNWARD
	MOVEM	REG,0(AC1)	; SAVE SIZE WORD
	HRRM	AC1,BFPAD.	; PUSH BUFFER MARKER DOWNWARD
	CAIG	AC1,40(TOPP)	; CHECK FOR STACK OVERFLOW
	JRST	CORER.
	MOVE	AC0,REG		; SET UP STACK CORRECTION
	PUSHJ	TOPP,FIXSP.	; AND DO IT
BFND:	MOVEI	REG,1(AC1)	; RET PTR TO BUFFER NOT SIZE WORD
	POPJ	TOPP,

BUFREE:	MOVEI	REG,-1(REG)	; POINT AT SIZE WORD
BFRLP:	HRRZ	AC1,BFPAD.	; PTR TO BASE OF FILE AREA
	CAME	REG,AC1		; IF EQUAL BUFFER IS CONTIQUOUS WITH END
	POPJ	TOPP,
	MOVN	AC0,0(REG)	; GET SIZE OF BUFFER
	PUSHJ	TOPP,FIXSP.	; AND CORRECT STACK POINTERS
	HLRZ	AC0,.JBSA##	; GET PTR TO END OF FILE AREA
	ADD	REG,0(REG)	; DELETE BUFFER
	HRRM	REG,BFPAD.	; UPDATE BASE PTR
	CAML	REG,AC0		; HAVE WE REACHED LAST BUFFER
	POPJ	TOPP,
	SKIPE	BUFUCT+1(REG)	; REG NOW POINTS TO NEXT BUFFER
	POPJ	TOPP,
	JRST	BFRLP		; IF IT IS FREE, CHECK IF IT CAN BE DELETED
FIXSP.:	PUSH	TOPP,REG	; FREE A WORKING REG
	PUSH	TOPP,REG1	; AND ANOTHER
	HLRE	REG,TOPP	; GET COUNTER FROM TOPP
	ADD	REG,AC0		; CORRECT IT
	HRLI	TOPP,(REG)	; AND RESTORE
	MOVE	REG1,BASIS
FIXSP1:	TLNN	REG1,777777	; ANY STORED STACK POINTERS TO CORRECT?
	JRST	FIXSP2		; NO
	HLRE	REG,2(REG1)	; GET STORED "TOPP"
	ADD	REG,AC0		; ADD CHANGE IN STACK SIZE
	HRLM	REG,2(REG1)	; AND CORRECT IT
	MOVE	REG1,1(REG1)	; GET STORED "BASIS"
	HLR	REG1,REG1	; FOLLOW DYNAMIC CHAIN, NOT STATIC !!
	JRST	FIXSP1		; CHASE UP LINK CHAIN
FIXSP2:	POP	TOPP,REG1	; YA
	POP	TOPP,REG
	POPJ	TOPP,		; DONE

	SUBTTL	SETEOF - SET FILE TO LOGICAL EOF STATE

SETEOF: MOVNI  AC0,MAXEOF	;INITIALIZE COUNT FOR
				;MAXIMUM NUMBER OF ATTEMPTS
	MOVEM  AC0,FILEO)	;TO READ BEYOND EOF
	MOVEI	AC0,1
	MOVEM	AC0,FILEOL(REG)	;SET EOLN = TRUE (1)
	SKIPE	FILSTA(REG)	;ASCII FILE?
	POPJ	TOPP,		;NO, DON'T PLACE BLANK IN FILE COMPONENT
	MOVEI  AC0, " "
	MOVEM  AC0,FILCMP(REG)	;INSERT BLANK
	HRRZS	   FILCNT(REG)	;CLEARS CHARACTERCNT
	POPJ	 TOPP,

	SUBTTL	TTY SUPPORT ROUTINES

TWAIT.:	MOVE	AC1,	FILLST	;TTY WAIT - SEE IF TTYOUTPUT REWRITTEN
	PUSH	TOPP,	AC0	;SAVE IT!
	SKIPA			;START SEARCH OF FILES
TWAIT1:	MOVE	AC1,	FILLNK(AC1) ;NEXT FILE BLOCK
	JUMPE	AC1,	TWAIT3	;TTYOUTPUT NOT IN LIST
TWAIT2:	MOVE	AC0,	FILDEV(AC1) ;GET DEVICE NAME
	CAME	AC0,	[SIXBIT/TTY   /] ;TTY?
	JRST		TWAIT1	;NO, KEEP LOOKING
	SKIPN	FILRWF(AC1)	;HAS IT BEEN REWRITTEN?
	JRST	TWAIT1		;NO, MUST BE TTYINPUT. KEEP LOOKING
	SKIPN	FILBUF(AC1)	;GOTTEN A BUFFER YET?
	JRST	TWAIT3		;NO, NOTHING TO DO
	PUSH	TOPP,	REG	;FOUND IT. SAVE OLD REG
	MOVE	REG,	AC1	;SETUP FOR BREAK (TTYOUTPUT)
	PUSHJ	TOPP,	BREAK.	;DO IT
	POP	TOPP,	REG	;RESTORE REG
TWAIT3:	POP	TOPP,	AC0	;RESTORE ADDRESS FOR CORER., PTRER., ETC.
	POPJ	TOPP,		;AND RETURN



;
; 'BREAK' - FORCE BUFFERED OUTPUT TO TERMINAL
; (USEFUL TO SYNCRONIZE INPUT AND OUTPUT TO TTY).
;
BREAK.:	XCT	      FILOUT(REG) ;FORCE OUTPUT
	POPJ	 TOPP,
	HALT			;ERROR DURING OUTPUT



;
; TTY OPEN ROUTINE
;
TTYOP.:	PUSHJ	 TOPP,PUTLN.
	MOVEI	  AC0,"*"	;TYPE ASTERISK
	PUSHJ	 TOPP,PUTCH.
	PUSHJ	 TOPP,BREAK.
	POPJ	 TOPP,

	SUBTTL	CONVERSION ERROR ROUTINE

;
; CONVERSION ERROR INTERCEPTOR
;
CONER.:
	PUSHJ	TOPP,TWAIT.
	OUTSTR	[ASCIZ /
?Input data error in file /]
	PUSHJ	TOPP,WRTFNM
	JRST	DIE.

	SUBTTL	CONTROL CHARACTER PROCESSING CONTROL

PASSCC:	MOVEI	AC0,GTCPCC	; SET TO PASS CONTROL CHARACTERS
PFCC:	MOVEM	AC0,GTCHCC

FLTRCR:	MOVEI	AC0,GTCFCR	;EITHER CC CALL IMPLIES FLTRCR
	MOVEM	AC0,GTCHCR

	MOVEI	AC0,GTCBLK	;DOCTOR UP LF HANDLER
PFCR:	MOVEM	AC0,GTCHLF
	POPJ	TOPP,

FLTRCC:	MOVEI	AC0,GTCFCC	; SET TO FILTER CONTROL CHARACTERS
	JRST	PFCC

PASSCR:	MOVEI	AC0,GTCPCR	;TO MAKE IT RETURN CR'S LITERALLY
	MOVEM	AC0,GTCHCR
	MOVEI	AC0,GTCEOL	;AND RETURN LF KINDA LIKE ESCAPE
	JRST	PFCR

	SUBTTL	VARIABLE STORAGE

;
; WORKING STORAGE FOR THIS MODULE
;

	$LOW			;THIS ALL GOES IN THE LOW SEGMENT

	SYN	GETRET,GTCPCR	;TO PASS A CR, GOTO RETURN
	SYN	GETCNT,GTCFCR	;AND TO FILTER, GOTO BEGINNING


OPNMOD:	BLOCK	1		;SAVE MODE OF FILE
FLIST.:	BLOCK	0
FILLST:	BLOCK	1		;HEAD OF FILEBLOCK LIST
CHNTAB:	XWD	377774,0	;BIT TABLE FOR CHANNEL ALLOCATOR
GTCHCC:	EXP	GTCFCC		; CNTRL CHAR PROCESSOR

GTCHCR:	EXP	GETCNT		; CR PROCESSOR (INIT. PASS)
GTCHLF:	EXP	GTCBLK		; LF PROCESSOR (INIT. FILL IN BLANK)



;
; LITERALS
;
	$LIT



	PRGEND
	title	unchain

	search	passym

	$reloc

	entry	unchn.
	extern	flist.		; head of list of file blocks
	extern	close.

;
; UNCHN. is called to remove a dynamically created file block
; (through NEW) from the linked list of file blocks in the runtime.
; On entry:	(REG) = address of file block to be freed
;
unchn.:	hrrz	reg1,flist.	; get head of list
	caie	reg1,0(reg)	; at head ?
	jrst	loop		; no, go search
	hrrz	reg2,fillnk(reg); yes, replace head by next file block
	movem	reg2,flist.
	jrst	close		; and be sure file is closed

loop:	jumpe	reg1,return	; nothing to do if never opened
	hrrz	reg2,fillnk(reg1); next in chain
	cain	reg2,0(reg)
	jrst	found
	move	reg1,reg2	; continue search
	jrst	loop

found:
	hrrz	reg2,fillnk(reg2); get its next ptr
	hrrm	reg2,fillnk(reg1); unchain file block

close:	push	topp,reg	; preserve address
	pushj	topp,close.	; close the file
	pop	topp,reg
return:	popj	topp,		; all done
	prgend
	title	initfileblock

	search	passym

	entry	inifb.

	$reloc
;
; INIFB. is called from NEW to initialize a pointer-file block.
; On entry:
;    (REG) = address of new'ed file block
;    (REG1)= negative component size if left halfword
;	     right halfword = 0 if text file
;		"      "    = 14b if not-text file
;
inifb.:
	movei	ac1,fileol(reg) ; prepare blt to zero file block
	hrli	ac1,fileof(reg)
	setzm 	fileof(reg)	; propagate zero
	blt	ac1,fillnr(reg)
	hrrzm	reg1,filsta(reg); set status of file
	movei	ac1,filopn(reg)	; prepare blt to initialize xct's
	hrli	ac1,basicblock
	blt	ac1,filcls(reg)
	movei	ac1,filsta(reg)
	hrrm	ac1,filopn(reg)	; init open
	movei	ac1,filnam(reg)
	hrrm	ac1,fillkp(reg)	; init lookup
	hrrm	ac1,filent(reg)	; init enter
	hrri	reg1,filcmp(reg);
	movem	reg1,filcnt(reg); init count
	hrrzm	reg1,0(reg)	; init file ptr
	popj	topp,
basicblock:
	open	0
	lookup	0
	enter	0
	in	0
	out	0
	release	0
	prgend
	TITLE	IOFNAME - GIVES FILENAME OF PASCAL FILE
	SEARCH	PASSYM
	ENTRY	FNAME.
	$RELOC

	OPDEF	ADJSP	[105B8]


;
;    PATHNAME - is a PASCAL callable function returning the actual name
;	of a file (or device) whereever it is.  The name returned reflects
;       any directory searching enabled by the user.  The calling sequence
;	is:
;
;		EXTERNAL FUNCTION PATHNAME (VAR F: TEXT): STRING[32]
;


FNAME.:
PATHNA:	MOVE	REG1,AC0		; GET PTR TO RETURN VAL IN USEABLE REG
	MOVEI	REG2,1(REG1)
	HRLI	REG2,440700		; GET BYTE PTR TO STRING TO RETURN
	SETZM	0(REG1)			; INIT RETURN VALUE TO ''

	SKIPN	FILBUF(REG)		; FILE IS CLOSED
	POPJ	TOPP,			; RETURN ''



;
;    Have needed information in file block; so convert
;	to ASCII and put in return string.
;
        SKIPN   REG3,FILDEV(REG)
        JRST    NODEVICE
	PUSHJ	TOPP,WRNAME
	MOVEI	REG4,":"		; FOLLOWED BY COLON
	PUSHJ	TOPP,WRCHR
NODEVICE:
	MOVE	REG3,FILNAM(REG)	; WRITE FILENAME
	PUSHJ	TOPP,WRNAME
	HLLZ	REG3,FILEXT(REG)	; WRITE EXTENSION IF NONNULL
	JUMPE	REG3,WRDIR
	MOVEI	REG4,"."		; DOT BEFORE EXTENSION NAME
	PUSHJ	TOPP,WRCHR
	PUSHJ	TOPP,WRNAME
WRDIR:	MOVEI	REG4,"["		; WRITE [DIRECTORY]
	PUSHJ	TOPP,WRCHR
        HLRZ    REG3,FILPPN(REG)
	PUSHJ	TOPP,WRNUM
	MOVEI	REG4,","
	PUSHJ	TOPP,WRCHR
        HRRZ    REG3,FILPPN(REG)
	PUSHJ	TOPP,WRNUM
	MOVEI	REG4,"]"
			; return through WRCHR routine

;
;    Write routines move text into return string
;

WRCHR:	AOS	0(REG1)			; INCREMENT LENGTH
	IDPB	REG4,REG2
	POPJ	TOPP,

WRNUM:	MOVE	REG4,REG3		; ISOLATE LOW ORDER DIGIT
	ANDI	REG4,7
	ADDI	REG4,"0"		; MAKE IT ASCII
	PUSH	TOPP,REG4		; SAVE IT
	LSH	REG3,-3			; WRITE NEXT ORDER CHAR FIRST, IF NOT 0
	SKIPE	REG3
	PUSHJ	TOPP,WRNUM		; RECURSION WRITES LEFTMOST DIGIT 1ST
	POP	TOPP,REG4		; WRITE RIGHT HAND DIGIT
	JRST	WRCHR

WRNAME:	MOVE	REG5,[POINT 6,REG3]	; NAME IS IN REG3
WRNLP:	ILDB	REG4,REG5		; GET NEXT SIXBIT CHAR
	JUMPE	REG4,WRRET		; DONE IF SIXBIT BLANK
	ADDI	REG4," "		; CONVERT SIXBIT TO ASCII
	PUSHJ	TOPP,WRCHR
	TRNE	REG5,1			; WHEN 6 HAVE BEEN WRITTEN, ADDRESSES REG4 (EVEN)
	JRST	WRNLP
PATHRT:
WRRET:
	POPJ	TOPP,

;
;    Error return on failure of extended lookup: just return
;    null string.
;

PATHERROR:
	SETZM	0(REG1)
	POPJ	TOPP,

	LIT
	PRGEND
	search	passym
	$reloc
	title	rntim
	entry	rn.tim

;
; RN.TIM executes a RUNTIM uuo and returns the value.
;

rn.tim:
	pjob	1,		; get job number
	runtim	1,		; and runtime
	movem	1,fv(topp)	; set up as pascal return value
	popj	topp,
	prgend
	search	passym
	title	datim
	$reloc
	entry	da.tim

;
; DA.TIM executes a MSTIME uuo and returns the time of day.
;

da.tim:
	mstime	1,
	movem	1,fv(topp)
	popj	topp,
	prgend
	search	passym
	title	put8b
	$reloc
	entry	put.8b

;
; PUT.8B puts 8 bits to tty with a TTCALL.
;

put.8b:
	ioneou	reg
	popj	topp,
	end
 kb1J