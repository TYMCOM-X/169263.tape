	TITLE	STATISTICS - CALL/RETURN STATISTICS COLLECTION FACILITY
	SEARCH	PASSYM
;
;     ENTRY POINTS
;
	ENTRY	PNTRY.,PRTRN.,UNWND.,S%TIME,S%WRITE,S%FILE
	ENTRY	CREATE,CALL,DETACH,RESUME
	EXTERN	PCALL.

	EXTERN	S%INIT		; TO OPEN THE STAT FILE
	EXTERN	S%PUT		; TO PUT A RECORD

; GATHER STATISTICS ON PROCEDURE INVOCATION AND STORAGE ALLOCATION
; IN "S%FILE", OR "PASCAL.TMP".
;
; VAR S%FILE: FILE OF PACKED RECORD
;	NAME: ALFA;	(* NAME OF PROCEDURE CALLED/RETURNING/NEWING, ETC. *)
;	LOCATION: HALFWORD;	(* ADDR OF PROCEDURE *)
;	CASE WHAT: 0..7 OF	(* CALLING=0, RETURNING=1 *)
;	CALLING, RETURNING: (TIMER: INTEGER);
;	END;
;
; PACKED TAGFIELD VALUES:
;
CALLS=000000
RETURNS=100000
;

	$RELOC
	OPDEF	ADJSP	[XWD 105000,0]
	$LOW
LOCK:	Z		;LOCK OUT SENSITIVE CODE
OPENED:	Z			; DATA FILE OPENED IF NOT ZERO
COMPONENT: BLOCK 4		; TEMP PARAMETER TO S%PUT
RSAVE:	BLOCK	16		; REGISTER SAVE AREA
; DATA FILE BLOCK
S%FILE: XWD	0,CMP	;FILPTR
	Z		;FILEOL
	Z		;FILEOF
	OPEN	STA	;FILOPN
	LOOKUP	NAM	;FILLKP
	ENTER	NAM	;FILENT
	IN	0	;FILIN
	OUT	0	;FILOUT
	RELEASE	0	;FILCLS
STA:	EXP	14	;NOT ASCII MODE
	SIXBIT	/      /;FILDEV
	Z		;FILBFH
NAM:	SIXBIT	/PASCAL/;FILNAM
	SIXBIT	/TMP/	;FILEXT
	Z		;FILPRO
	Z		;FILPPN
	Z		;FILCHN/FILBUF
	Z		;FILLNK
	Z		;FILRWF
	Z		;FILLNR
	XWD	-4,CMP	;FILCNT
CMP:	Z		;FILCMP
	Z
	Z
	Z

	;  Environment record - contains state information for an environment.
	;  Note that care is taken to make the record look like a stack frame
	;  header, which is in turn made to be the 'caller' of the initial
	;  subroutine run in the environment.  This permits proper action on
	;  and unwnd. call.

	CRET=		0	; call return address
	CONTEXT=	1	; basis and topp on exit of environment
	CENTRY=		3	; entry word as in stack frame header
	CALLENV=	4	; pointer to calling environment
	ENVSZ=		5	; total size of record

CURENV:	XWD	0,MAIN		; pointer to current environment
MAIN:	EXP	0		; environment for procedure mainline
	EXP	0
	EXP	0
	EXP	CTB
	EXP	0


	$HIGH
;
; SUPPORT ROUTINES FOR DATA COLLECTION
TIMER:				;READ E-BOX AND M-BOX TIMERS
	MOVEI	5,1(TOPP)	;TEMP FOR TWO WORD RETURN
	HRLI	5,4
	CALLI	5,-57		;READS TIMERS
	HALT
	DMOVE	5,1(TOPP)	;GET E-BOX
	ASHC	5,^D23		;NORMALIZED
	JRST	0(AC1)		;RETURN
;
S%TIME:				;READ THE CURRENT VALUE OF THE TIMER
	JSP	AC1,TIMER	;ACTUAL READ
	MOVEM	5,FV(TOPP)	;STORED AS A PASCAL FUNCTION RETURN
	POPJ	TOPP,		; AND DONE

;
; PUBLIC PROCEDURE S%WRITE (STATRECORD);
;
; 	WRITES AN ARBITRARY RECORD TO THE OUT FILE
;
S%WRITE:
	SKIPE	LOCK		;COLLECTION ALREADY IN PROGRESS?
	POPJ	TOPP,		;YES, IGNORE CALL
	SETOM	LOCK		;LOCK OUT FURTHER DATA COLLECTION
	JSP	1,TIMER		; LEAVES TIMER IN 5
	MOVE	4,2(2)		; GETS TAGFIELD+ADDRESS
	DMOVEM	4,COMPONENT+2
	DMOVE	2,0(2)		; GET ALFA WORDS
	DMOVEM	2,COMPONENT
	MOVEI	2,COMPONENT
	PUSHJ	S%PUT
	SETZM	LOCK		;ENABLE FURTHER DATA COLLECTION
	POPJ	TOPP,


CHECKFILE: 			;SAVE REGISTERS AND OPEN FILE IF NECESSARY
	SETOM	LOCK		;NO FURTHER DATA COLLECTION TILL
				;THIS RECORD WRITTEN
	MOVEM	AC0,RSAVE
	HRLZI	AC0,1
	HRRI	AC0,RSAVE+1
	BLT	AC0,RSAVE+15	;SAVE REGS 0-15B
	SKIPE	OPENED
	POPJ	TOPP,		;FILE ALREADY OPEN
	SETOM	OPENED		;ELSE MARK AS OPENED
	MOVEI	2,S%FILE
	JRST	S%INIT		;RETURN THROUGH REWRITE AND ASSUME IT WORKS!

GETDATA:			;GET PROCEDURE NAME IN REG'S 2 AND 3 AND
				;RETURN ADDRESS IN LEFT(4)
	TLNE	BASIS,777777	;MAIN?
	JRST	PROC		;NO
	MOVE	4,0(BASIS)	;YES, GET PTR TO "PROC_BLOCK"
	JRST	GETNAME
PROC:	MOVE	4,3(BASIS)	;GET LINK WORD
GETNAME: HRRZ	2,0(4)		;PTR TO PROC BLOCK
	HRLZ	4,-1(TOPP)	;GET RETURN ADDRESS
	JUMPE	2,.+2		;IF ZERO
	CAIN	2,377777	;OR NIL
	MOVEI	2,UNKNOWN	;THEN USE "UNKNOWN"
	DMOVE	2,0(2)		;PICK UP PROCEDURE NAME
	POPJ	TOPP,

PUTR:	JSP	AC1,TIMER	;LEAVES TIMER IN 5
PUTRECORD:			;PUT FOUR-WORD RECORD NOW IN REG'S 2-5 IN FILE
				;AND RESTORE REGISTERS
	DMOVEM	2,COMPONENT
	DMOVEM	4,COMPONENT+2
	MOVEI	2,COMPONENT
	PUSHJ	TOPP,S%PUT
	HRLZI	AC0,RSAVE+1
	HRRI	AC0,1
	BLT	AC0,15
	MOVE	AC0,RSAVE	;RESTORES LAST REGISTER
	SETZM	LOCK		;ALLOW FURTHER DATA COLLECTION
	POPJ	TOPP,

;
; PROCEDURE UNWIND - FOR NON-LOCAL GOTO'S
;
UNWND.:	POP	TOPP,REG1	;SAVE RETURN LOC
UWLOOP:
	SKIPE	LOCK		;UNFINISHED DATA COLLECTION?
	JRST	UW		;YES
	PUSHJ	TOPP,CHECKFILE
	PUSHJ	TOPP,GETDATA
	HRLZ	4,0(BASIS)
	HRRI	4,RETURNING
	PUSHJ	TOPP,PUTR
UW:	DMOVE	BASIS,1(BASIS)
	TLNE	BASIS,777777
	HLR	BASIS,BASIS
	CAIE	AC1,0(BASIS)
	JRST	UWLOOP
	POP	TOPP,0
	JRST	0(REG1)
;
; PROCEDURE ENTRY ROUTINE - MONITORS CALLS
;
PNTRY.:
	SKIPE	LOCK		;COLLECTION IN PROGRESS?
	JRST	ENTER.		;YES
	PUSHJ	TOPP,CHECKFILE
	MOVE	2,RSAVE+1	;GET RETURN ADDRESS
	HRLI	4,-1(2)	;ADDRESS OF ENTRY PT
	HRRZ	2,0(2)		;PTR TO PROC BLOCK OR 0
	JUMPE	2,.+2		;IF ZERO
	CAIN	2,377777	;OR NIL
	MOVEI	2,UNKNOWN	;THEN USE "UNKNOWN"
	DMOVE	2,0(2)		;GET NAME
	HRRI	4,CALLS		;TAGFIELD
	PUSHJ	TOPP,PUTR	;WRITE INFO AND RESTORE REGS
ENTER.:	DMOVEM	BASIS,1(TOPP)
	MOVEM	1,3(TOPP)	;LINK WORD
	MOVEI	BASIS,0(TOPP)
	HRLI	BASIS,0(BASIS)
	JRST	1(1)		;CONTINUE

;
; PROCEDURE EXIT SEQUENCE
;
PRTRN.:
	SKIPE	LOCK
	JRST	RETRN.
	PUSHJ	TOPP,CHECKFILE
	PUSHJ	TOPP,GETDATA	;USE COMMON CODE FOR NAME AND ADDRESS
	HRLZ	4,0(BASIS)	;GET RETURN ADDRESS
	HRRI	4,RETURNS		;TAGFIELD
	PUSHJ	TOPP,PUTR	;WRITE INFO
RETRN.:	DMOVE	BASIS,1(BASIS)	;RESTORE OLD STACK POINTERS
	TLNE	BASIS,777777	;RETURNING TO MAIN?
	HLR	BASIS,BASIS	;NO- SET BOTH HALVES TO CALLERS FRAME
	POPJ	TOPP,		;AND RETURN

UNKNOWN: ASCII	/UNKNOWN   /


CTB:	EXP	CTBLK		; fake entry word and trace control block
CTBLK:	ASCII	'CREAT'
	ASCII	'E    '
	EXP	0
	EXP	0

;
;   CREATE ( proc, stacksize ): environment
;	2 -> proc var
;	3 -> stacksize
;
CREATE:	MOVEI	1,0(17)		; 1 -> base of new environment
	ADJSP	17,43(3)	; extend frame to alloc enviroment
				; allow for env header, and runtime storage
	MOVE	0,0(1)		; copy return address in callers space
	MOVEM	0,0(17)		; ... to end of extended frame
	MOVEM	1,4(17)		; return pointer to created environment

	MOVEI	0,CTB		; fill in entry word
	MOVEM	0,CENTRY(1)
	MOVE	4,CURENV	; make invoking env, caller of new
	MOVEM	4,CALLENV(1)
	DMOVEM	16,CONTEXT(4)	; same context of caller
	MOVEM	1,CURENV	; make new env the current one

	MOVEI	16,0(4)		; treat caller's environment record as calling frame
	HRLI	16,0(16)
	MOVEI	17,ENVSZ(1)	; create new TOPP for new env
	MOVN	3,3		; make PDL overflow count
	HRL	17,3

	MOVE	1,2		; call the entry var
	MOVEI	0,DETACH	; do a detach if proc returns
	PUSH	17,0		; ... by leaving addr as return address
	JRST	PCALL.

;
;  DETACH
;	return to calling environment
;
DETACH:
	SKIPE	LOCK
	JRST	CRETRN
	PUSHJ	TOPP,CHECKFILE
	PUSHJ	TOPP,GETDATA
	HRLZ	4,0(BASIS)
	HRRI	4,RETURNS
	PUSHJ	TOPP,PUTR
CRETRN:
	MOVE	1,CURENV	; save context of current environment
	DMOVEM	16,CONTEXT(1)
	MOVE	2,CALLENV(1)	; get caller of current
	DMOVE	16,CONTEXT(2)	; restore context of caller
	MOVEM	2,CURENV	; make caller current
	POPJ	17,		; continue

;
;  RESUME (env)
;	2 -> environment to be resumed
;
RESUME:
	SKIPE	LOCK
	JRST	RESUM.
	PUSHJ	TOPP,CHECKFILE
	PUSHJ	TOPP,GETDATA
	HRLZ	4,0(BASIS)
	HRRI	4,RETURNS
	PUSHJ	TOPP,PUTR
RESUM.:
	MOVE	1,CURENV	; save context of current environment
	DMOVEM	16,CONTEXT(1)
	DMOVE	16,CONTEXT(2)	; restore context of resumed env
	MOVE	1,CALLENV(1)	; copy caller
	MOVEM	1,CALLENV(2)
	MOVEM	2,CURENV	; set env as current
	SKIPE	LOCK
	POPJ	17,		; return to exit loc in env
	PUSHJ	TOPP,CHECKFILE
	HRRZ	4,3(BASIS)
	MOVE	2,0(4)
	JUMPE	2,.+2
	CAIN	2,377777
	MOVEI	2,UNKNOWN
	DMOVE	2,0(2)
	HRLZI	4,-1(4)
	HRRI	4,CALLS
	JRST	PUTR


;
;  CALL (env)
;	2 -> environment to call
;
CALL:	MOVE	1,CURENV	; make current the caller
	MOVEM	1,CALLENV(2)
	DMOVEM	16,CONTEXT(1)	; save the callers context
	DMOVE	16,CONTEXT(2)	; setup called env's environment
	MOVEM	2,CURENV	; make it the current
	SKIPE	LOCK
	POPJ	TOPP,
	PUSHJ	TOPP,CHECKFILE
	HRRZ	4,3(BASIS)
	MOVE	2,0(4)
	JUMPE	2,.+2
	CAIN	2,377777
	MOVEI	2,UNKNOWN
	DMOVE	2,0(2)
	HRLI	4,-1(4)
	HRRI	4,CALLS
	JRST	PUTR

	PRGEND
	TITLE	STATS1 - DEFAULT INTERFACES TO "REWRITE" AND "PUT"

	SEARCH	PASSYM

	ENTRY	S%INIT		; REWRITE A FILE
	ENTRY	S%PUT		; PUT A COMPONENT

	EXTERN	REWRT.
	EXTERN	PUT.
	EXTERN	S%FILE		; DATA COLLECTION FILE BLOCK

	$RELOC

S%INIT:	
	MOVEI	REG1,FILENAME
	HRLI	REG1,440700
	MOVEI	REG2,^D10
	MOVEI	REG3,0		; NOT APPEND MODE
	JRST	REWRT.

S%PUT:	MOVEI	AC1,S%FILE
	DMOVE	REG1,0(REG)	; GET FIRST TWO WORDS OF STATRECORD
	DMOVEM	REG1,FILCMP(AC1); MOVE TO FILE COMPONENT
	DMOVE	REG1,2(REG)	; REST OF RECORD
	DMOVEM	REG1,FILCMP+2(AC1)
	MOVE	REG,AC1		; PARAMETER IS FILE BLOCK
	JRST	PUT.		; WRITE IT

FILENAME:ASCII	/PASCAL.TMP/
	END
    