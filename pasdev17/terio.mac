;    +----------------------------------------------------------------+
;    I                                                                I
;    I                          T E R I O                             I
;    I                          - - - - -                             I
;    I                                                                I
;    +----------------------------------------------------------------+
;
;    MDSI, COMPANY CONFIDENTIAL
;
;    STARTED: 18-May-77
;
;    PURPOSE: This package of UUO's attempts to present to the user  an
;       XDS  940  style  terminal  interface superimposed on the PDP-10
;       operating system.
;
;    USAGE:
;	SETDEV -- set device to something besides controlling TTY.
;       SETTER -- set terminal status.
;       RDTER  -- read current terminal status.
;       TCI    -- read a character from the terminal.
;       TCO    -- write a character to the terminal.
;       LNI    -- read a line (ASCII mode only).
;       LNO    -- write an ASCII line or buffer of image characters.
;       POPIN  -- clear (pop) the terminal input buffer.
;       POPOUT -- clear (pop) the terminal output buffer.
;       STPTER -- allow unrestricted terminal I/O to be done by program
;                 while preserving terminal status maintained by this package,
;                 or return package to ground zero.
;
;    REQUIREMENTS: Programs accessing this  package  should  externally
;       reference  symbol IOBRK.  to insure it is loaded from a library
;       file.  IOBRK.  is a flag word which may also be set  (non-zero)
;       by  the  program,  indicating  that  the next attempt to read a
;       character should abort.  It is primarily intended  for  use  by
;       programs  fielding  control-C.  Clearing  as  well  as  setting
;       IOBRK.  is  entirely  the  responsibility  of   the   accessing
;       program.
;
;    NOTES: The use of TTCALL's and/or TRMOP.'s by user programs should
;       not  cause  any  problems.  However,  device TTY: should not be
;       OPENed or INITed by the program when using this package.
;
;    RESPONSIBLE: A. Kortesoja, QQSV
;
;    CHANGES: Complete rewrite to use buffered I/O, September 1977.
;	Rewrite output to use SVC TRMOP. (so input and output can be
;	in different modes simultaneously), 3/21/78.
;	Add JNKFIR interface in order to ditch old TENIO UUO dispatcher,
;	9/12/78.
;	Leave ECHO off and NLF on if that way on entry (for TELENET users),
;	12/11/78.
;	Prevent a null word at the end of an input line from shifting into
;	oblivion, 2/28/79.
;	Force TERSNS (RDTER) to initialize if it isn't already, 8/16/79.
;	Use ADP style echo for character and line deletes, 9/20/79.
;	Cut to one buffer and count in and out breaks, 2/13/80.
;
;    ------------------------------------------------------------------
	TITLE	TERIO - Terminal Interface Package for 940 Simulator and Others
	TWOSEG
	SEARCH	DEFUUO(RND:DEFUUO); Al sux, Al
	SEARCH	OPDEFS		; DEC sux, Al
	EXTERN	JNKFIR		; Last vestige of old AL
;	REGISTER EQUATES

	W0==0	;W-accumulators used by supporting routines called by UUO's
	W1==1	;no preservation of them should be assumed across calls
	WX0==2
	EOFC==3	;except for this one, used by RD8 routine
	HDRADR==4	;address of buffer header block of interest
	BF1ADR==5	;address of first buffer in ring when init'ing header
	GETCH==6	;parameter register to GET routine
	PUTCH==6	;parameter register to PUT routine
	AC0==7	;A-accumulators used by UUO's
	AC1==10
	AC2==11
	STK==17	;standard stack pointer register

;	OPERATING SYSTEM FLAG FOR CONDITIONAL COMPILATIONS

	ADPFLG==1	; FOR ADP, =1; FOR TOPS-10, =0
	SUBTTL	VARIABLE STORAGE DECLARATIONS
	RELOC	0

	BF7SIZ==23	;RING BUFFER SIZES (THIS ONE FOR ASCII)
BF8SIZ==	23
	BUFNUM==1	;NUMBER OF BUFFERS IN RING

;	BUFFER HEADERS

I8BFHD:			;IMAGE INPUT (HEADERS/BUFFERS SHARED BY IMAGE/ASCII)
I7BFHD:	BLOCK	3	;ASCII INPUT
O8BFHD:			;IMAGE OUTPUT
O7BFHD:	BLOCK	3	;ASCII OUTPUT

;	RING BUFFERS

I8BUF1:
I7BUF1:
IFG BF8SIZ-BF7SIZ,<
	BLOCK	BUFNUM*BF8SIZ>
IFLE BF8SIZ-BF7SIZ,<
	BLOCK	BUFNUM*BF7SIZ>
;
O7BUF:	BLOCK	23		; For TRMOP.s, that's enough
;
;	STATUS INFORMATION

	ENTRY	IOBRK.,TINCNT,TOCNT; For others to snatch

TINCNT:	EXP	0		; Count of input line breaks
TOCNT:	EXP	0		; Count of outputs (including editing)
IOBRK.:	BLOCK	1	;FLAGS ATTENTION INTERRUPT TO ASCII INPUT

PRVMSK:	BLOCK	1	;PREVIOUS MASK PASSED TO SETTER
ECHOFG:	BLOCK	1	;IF SET, NO ECHO, ELSE ECHO
BRKFG:	BLOCK	1	;IF SET, BREAK ON ALL INPUT CHARACTERS (NOT REALLY)
IN8FG:	BLOCK	1	;IF SET, IMAGE INPUT
OUT8FG:	BLOCK	1	;IF SET, IMAGE OUTPUT
OBUFFG:	BLOCK	1	;IF SET, PACKAGE WILL BUFFER OUTPUT, I.E.,
			;OUTPUT BUFFERS WILL NOT BE FLUSHED AFTER EVERY
			;OUTPUT UUO CALL.

;	TRMOP. BLOCK USED TO READ/WRITE TERMINAL STATUSES

TRMBLK:	BLOCK	1
UDX:	BLOCK	1	;UNIVERSAL DEVICE INDEX, READ BY SAVSTS
TRMARG:	BLOCK	1	;ARGUMENT WORD FOR SETS
IFN ADPFLG,<
	BLOCK	1	;EXTRA WORDS FOR ADP GETPAR,SETPAR UUO'S
ERUDX:	BLOCK	1	;UDX MOVED HERE WHEN ECHO TURNED BACK ON
ERLST:	BLOCK	1	;LSTAT WORD MOVED HERE WHEN ECHO TURNED BACK ON
HTVTFF:	BLOCK	6	;PARAMETERS FOR HT,VT, AND FF
			;THESE WORDS ARE ONLY READ AND RESTORED, AND NOT
			;CHANGED DURING EXECUTION, HENCE THEY ARE NOT MOVED
			;TO SEPARATE SAVE AREA AFTER BEING READ
	XWD	1,16	;CLEARS $$NLF WHEN ECHO TURNED ON
ESUDX:	BLOCK	1	;UDX FOR SETPAR WHEN ECHO TURNED OFF
ESLST:	OCT	401410000000,5,6,7,10,11,12	;LSTAT,ZERO HT,VT,FF PARMS
	XWD	400001,16	;SETS $$NLF WHEN ECHO TURNED OFF
>

;	STORAGE TO SAVE STATUS INFORMATION IN

SAVRTC:	BLOCK	1	;R/T COMPATIBILITY SETTING
SAVTAP:	BLOCK	1	;TAPE MODE SETTING
SAVECH:	BLOCK	1	;ECHO MODE SETTING
IFN ADPFLG,<
SAVLST:	BLOCK	1	;ADP LSTAT WORD
SAVCRT:	BLOCK	1	;ADP CRTSTS WORD
SAVMET:	BLOCK	1	;ADP META CHARACTER
SAVINT:	BLOCK	1	;ADP INT CHARACTER
>

;	BLOCK USED FOR OPEN UUO'S

OPNBLK:	BLOCK	1	;FILE STATUS WORD
OPNDEV:	SIXBIT/TTY/	;DEVICE...MAY BE CHANGED VIA SETDEV
OPNBUF:	BLOCK	1	;BUFFER ADDRESS

;
;	Echo buffer for character delete verification
;
BAKUP:	ASCIZ	'\x\
'				; Filled in with deleted character
;
;	WORD FLAGGING SETUP STATE

SETFLG:	BLOCK	1	;-1=PREVIOUS SETUP ERROR,1=SETUP,0=NOT SETUP BEFORE

;	END OF STORAGE AREA
	RELOC	400000
	SUBTTL	ROUTINES TO SAVE AND RESTORE TERMINAL STATUSES

;	TRMOP. FUNCTION CODES

	TRMSET==2000	;BIT INDICATING FUNCTION TO BE SET TO ARGUMENT
	TRMRD==1000	;BIT INDICATING FUNCTION SETTING TO BE READ
	.TOTAP==20	;FUNCTION CONTROLLING TAPE MODE
	.TOLCP==7	;FUNCTION CONTROLLING ECHO (LOCAL COPY)
	.TORTC=36	;FUNCTION CONTROLLING HANDLING OF CONTROL R AND T

;	RELEVENT OPDEFS

	OPDEF	TRMNO.[CALLI 115]
	OPDEF	TRMOP.[CALLI 116]
IFN ADPFLG,<
	OPDEF	SETPAR[CALLI -42]
	OPDEF	GETPAR[CALLI -53]
>
	OPDEF	IONDX.[CALLI 127]
	OPDEF	SLEEP[CALLI 31]
;
;	ROUTINE TO READ AND SAVE CURRENT TERMINAL STATUSES
;	SKIPS ON SUCCESS, NO SKIP ON ERROR OF ANY KIND
;
SAVSTS:	MOVE	W0,OPNDEV	;READ UDX OF DEVICE WHICH WE ARE USING
	IONDX.	W0,0
	JRST	0,SAVERR
	HRRZM	W0,UDX		;SAVE UDX
IFN ADPFLG,<
	HRRZM	W0,ESUDX	;USED FOR SETPAR ON ECHO OFF
>

;	MAKE SURE TERMINAL OUTPUT BUFFER IS EMPTY BEFORE READING
;	STATUSES, AS NEW STATUS SETTINGS MAY BE WINGING THEIR
;	WAY OUTWARD IN THE NETWORK AT THIS VERY MOMENT.

OUTCHK:	MOVEI	W0,2		;.TOSOP -- SKIP IF BUFFER NOT EMPTY
	PUSHJ	STK,DOTRM2
	JRST	0,OUTEMP	;ITS EMPTY
	MOVEI	W0,1		;ITS NOT -- SLEEP FOR 1 SECOND AND
	SLEEP	W0,0		;THEN REPEAT THE QUESTION
	JRST	0,OUTCHK
OUTEMP:	MOVEI	W0,TRMRD+.TOTAP	;READ SETTING OF PAPER TAPE MODE
	PUSHJ	STK,DOTRM2
	JRST	0,SAVERR
	MOVEM	W0,SAVTAP	;SAVE SETTING
	MOVEI	W0,TRMRD+.TOLCP	;READ SETTING OF LOCAL COPY SWITCH
	PUSHJ	STK,DOTRM2
	JRST	0,SAVERR
	MOVEM	W0,SAVECH	;SAVE IT
	MOVEI	TRMRD+.TORTC	;READ SETTING OF R/T COMPATIBILITY
	PUSHJ	STK,DOTRM2
	JRST	0,SAVERR
	MOVEM	W0,SAVRTC
IFN ADPFLG,<
	SETZM	0,TRMARG	;READ LSTAT AND CRTSTS WORDS
	MOVEI	W0,16
	MOVEM	W0,TRMARG+1
	MOVEI	W0,777777	;READ META
	MOVEI	W1,20		;READ INT
	DMOVEM	W0,TRMARG+2
	MOVEI	W1,5		;SET UP WORDS TO READ VT/HT/FF PARMS
	MOVEI	W0,12		;CODES IN RIGHT HW ARE 5-12
TPARLP:	MOVEM	W0,HTVTFF(W1)
	SOJ	W0,0
	SOJGE	W1,TPARLP
	MOVE	W0,[XWD -13,UDX]
	GETPAR	W0,0
	JRST	0,SAVERR
	DMOVE	W0,TRMARG	;AND SAVE THEM
	DMOVEM	W0,SAVLST
	DMOVE	W0,TRMARG+2
	DMOVEM	W0,SAVMET
>
	POP	STK,WX0		;GO HOME INDICATING EVERYTHING OK
	JRST	0,1(WX0)
SAVERR:	SETZM	0,UDX	;MAKE SURE THAT UNSSTS DOESN'T THINK WE FINISHED
	POPJ	STK,0
;
;	ROUTINE TO RESTORE STATUS READ BY SAVSTS
;	DOESN'T BOTHER SKIPPING, AS WE CAN'T DO MUCH ABOUT ERRORS
;
UNSSTS:	SKIPN	0,UDX		;NOP IF SAVSTS HAS NOT BEEN CALLED BEFORE
	POPJ	STK,0
	MOVE	W0,SAVTAP	;RESTORE TAPE MODE SETTING
	MOVEM	W0,TRMARG
	MOVEI	W0,TRMSET+.TOTAP
	PUSHJ	STK,DOTRM3
	JRST	0,.+1		;IGNORE ERRORS
	MOVE	W0,SAVECH	;RESTORE LOCAL COPY SETTING
	MOVEM	W0,TRMARG
	MOVEI	W0,TRMSET+.TOLCP
	PUSHJ	STK,DOTRM3
	JRST	0,.+1
	MOVE	W0,SAVRTC	;RESTORE R/T COMPATIBILITY
	MOVEM	W0,TRMARG
	MOVEI	W0,TRMSET+.TORTC
	PUSHJ	STK,DOTRM3
	JRST	0,.+1
IFN ADPFLG,<
	DMOVE	W0,SAVLST	;RESTORE LSTAT AND CRTSTS
	OR	W0,[XWD 400000,0]	;FIRST, SET THOSE THINGS WHICH
	OR	W1,[XWD 400000,0]	;WERE SET BEFORE
	DMOVEM	W0,TRMARG
	MOVE	W0,[XWD -3,UDX]
	SETPAR	W0,0
	JRST	0,.+1
	DMOVE	W0,SAVLST	;THEN CLEAR THOSE THINGS WHICH WERE NOT SET
	XOR	W0,[XWD 377777,0]
	XOR	W1,[XWD 377777,0]
	DMOVEM	W0,TRMARG
	DMOVE	W0,SAVMET	;RESTORE META/INT
	DMOVEM	W0,TRMARG+2
	MOVE	W0,[XWD -13,UDX];AS WELL AS HT,VT,FF PARAMETERS
	SETPAR	W0,0
	JRST	0,.+1
>
	SETZM	0,UDX		;FLAG STATUS RESTORED
	POPJ	STK,0
	SUBTTL	ROUTINES TO CHANGE TERMINAL STATUSES

;
;	A BIT OF SPAGHETTI CODE WITH THE FOLLOWING ENTRY POINTS:
;	ONECH -- TURNS ON ECHO
;	OFFECH -- TURNS OFF ECHO
;	ONTAP -- TURNS ON PAPER TAPE MODE
;	OFFTAP -- TURNS OFF PAPER TAPE MODE
;	ALL ENTRIES SKIP ON SUCCESS, NO SKIP ON ERROR.
;

ONECH:
IFN ADPFLG,<
	MOVE	W0,UDX		;RESTORE HT,VT,FF SWITCHES, PARMS TO ORIGINAL
	MOVEM	W0,ERUDX	;PICK UP UDX FOR SETPAR'S
	MOVE	W0,SAVLST	;TURN ON HT,VT,FF IF ON PREVIOUSLY
	AND	W0,[XWD 1410,0]	;SELECTS THOSE ON PREVIOUSLY
	TLO	W0,400000	;TURN SIGNBIT ON
	MOVEM	W0,ERLST
	MOVE	W0,[XWD -11,ERUDX]
	DMOVE	1,SAVLST	; Grab LSTAT and CRTSTS status words
	TLNZ	2,1		; Was NLF on on entry?
	HRLI	0,-10		; Yes. Leave it on
	SETPAR	W0,0
	POPJ	STK,0
	MOVE	W0,SAVLST	;TURN OFF HT,VT,FF IF OFF PREVIOUSLY
	AND	W0,[XWD 1410,0]	;SELECTS THOSE ON PREVIOUSLY
	TLC	W0,1410		;SELECTS THOSE OFF PREVIOUSLY
	MOVEM	W0,ERLST
	MOVE	W0,[XWD -2,ERUDX]
	SETPAR	W0,0
	POPJ	STK,0
	TLNN	1,4		; Was ECHO on on entry?
	JMP	OPNRET		; No. Leave it off (must have been a reason)
>
	MOVEI	W0,TRMSET+.TOLCP
	SETZM	0,TRMARG	;LOCAL COPY OFF ==> ECHO ON
	JRST	0,DOTRM3

OFFECH:
IFN ADPFLG,<
	MOVE	W0,[XWD -11,ESUDX]
	SETPAR	W0,0		;TURN HT,VT,FF ON, WITH ZERO PARAMETERS
	POPJ	STK,0
>
	MOVEI	W0,TRMSET+.TOLCP
	SETOM	0,TRMARG
	JRST	0,DOTRM3

ONTAP:	MOVEI	W0,TRMSET+.TOTAP
	SETOM	0,TRMARG
	JRST	0,DOTRM3

OFFTAP:	MOVEI	W0,TRMSET+.TOTAP
	SETZM	0,TRMARG

;	ROUTINES TO DO TRMOP.'S FROM TRMBLK.
;	FUNCTION CODE PASSED IN W0, TRMOP. DONE WITH AC=W0.
;	DOTRM2 IS FOR 2 WORD ARGUMENT BLOCK, DOTRM3 FOR 3 WORD.
;	ROUTINES SKIP ON SUCCESS, NO SKIP ON FAILURE.

DOTRM3:	MOVEM	W0,TRMBLK	;SAVE FUNCTION CODE
	MOVE	W0,[XWD 3,TRMBLK]
	JRST	0,DOTRM
DOTRM2:	MOVEM	W0,TRMBLK
	MOVE	W0,[XWD 2,TRMBLK]
DOTRM:	TRMOP.	W0,0
	POPJ	STK,0
	AOS	0,0(STK)
	POPJ	STK,0		;DO IT THIS WAY TO AVOID CREAMING A REGISTER
	SUBTTL	ROUTINES TO INITIALIZE BUFFER RINGS

;	EQUATES FOR RING HEADER BLOCK CONTENTS

	BUFBTP==1	;BYTE POINTER WORD OFFSET
	BUFBTC==2	;BYTE COUNT WORD OFFSET

;	ENTRY POINTS:
;	  INTBFI--INITIALIZE AN INPUT BUFFER
;	  INTBFO--INITIALIZE AN OUTPUT BUFFER (no more)
;	INPUTS TO THESE ROUTINES:
;	  HDRADR -- ADDRESS OF BUFFER RING HEADER BLOCK
;	  BF1ADR -- ADDRESS OF (AREA FOR) RING BUFFERS
;	ROUTINES NEVER SKIP.

INTBFI:	EXCH	BF1ADR,.JBFF##	;ALLOCATION IS FROM .JBFF
	INBUF	INCHN,BUFNUM
	MOVEM	BF1ADR,.JBFF##	;RESTORE .JBFF
	SETZM	0,BUFBTC(HDRADR)
	POPJ	STK,0
	SUBTTL	Routines to Initialize Channels for I/O

;	CHANNEL EQUATES

	INCHN==0	;INPUT CHANNEL
	OUTCHN==1	;OUTPUT CHANNEL

;	EQUATES FOR FILE STATUS SETTINGS

	IO.TEC==400		; Get these straight
	IO.SUP==200
	IO.SEM==100
	.IOIMG==10

;	ROUTINE TO OPEN INCHN FOR IMAGE INPUT
;	  ALSO SETS PAPER TAPE MODE ON

I8OPN:	RELEASE	INCHN,0			;TO CLEAR PREVIOUS STATUS
	MOVEI	W0,IO.TEC+IO.SUP+IO.SEM+.IOIMG
	MOVEM	W0,OPNBLK		;SET FILE STATUS
	HRRZI	HDRADR,I8BFHD		;LOAD HEADER BLOCK ADDRESS
	HRRZM	HDRADR,OPNBUF		;POINT OPEN AT HEADER BLOCK
	PUSHJ	STK,ONTAP		;SET TAPE MODE
	POPJ	STK,0			;ERROR
	PUSHJ	STK,OFFECH		;SET ECHO OFF
	POPJ	STK,0
	OPEN	INCHN,OPNBLK
	POPJ	STK,0
	HRRZI	BF1ADR,I8BUF1		;INITIALIZE BUFFER RING
	PUSHJ	STK,INTBFI
	JRST	0,OPNRET		;RETURN SUCCESS

;	ROUTINE TO OPEN INCHN FOR ASCII INPUT
;	  TURNS TAPE MODE OFF AND SETS ECHO APPROPRIATELY

I7OPN:	RELEASE	INCHN,0
	CLEARM	W0,OPNBLK	; No funny modes for ADP
	HRRZI	HDRADR,I7BFHD
	HRRZM	HDRADR,OPNBUF
	PUSHJ	STK,OFFTAP		;TURN OFF TAPE MODE
	POPJ	STK,0
	OPEN	INCHN,OPNBLK
	POPJ	STK,0
	HRRZI	BF1ADR,I7BUF1
	PUSHJ	STK,INTBFI
	SKIPN	0,ECHOFG		;SET ECHO ON/OFF
	JRST	0,OPNECH		;GO TURN IT ON
	PUSHJ	STK,OFFECH		;TURN IT OFF
	POPJ	STK,0
	JRST	0,OPNRET
OPNECH:	PUSHJ	STK,ONECH		;COME HERE TO TURN IT ON
	POPJ	STK,0
	JRST	0,OPNRET

;	ROUTINE TO OPEN OUTCHN FOR ASCII OUTPUT

O7OPN:	PUSHJ	17,BUFBLD	; Build phony buffer header for TRMOP.
;
;	Routine to open OUTCHN for image output.  There's nothing to do.
;
O8OPN:
OPNRET:	POP	STK,WX0		;COMMON RETURN POINT FOR OPN ROUTINES
	JRST	0,1(WX0)
;
;	BUFBLD--Subroutine to generate a phony buffer header.  Smashes
;	R0.  No special returns.
;
BUFBLD:	MOVE	0,[POINT 7,O7BUF]; Set up output byte pointer
	MOVEM	0,BUFBTP+O7BFHD
	MOVEI	0,23*5-1	; Set up count of room left
	MOVEM	0,BUFBTC+O7BFHD
	POPJ	17,0
	SUBTTL	ROUTINE TO INITIALIZE THIS PACKAGE

;	ROUTINE TO INITIALIZE THIS PACKAGE, CALLED BEFORE EVERY OPERATION
;	  IF PACKAGE PREVIOUSLY INITIALIZED SUCCESSFULLY, SKIP RETURN
;	  TAKEN IMMEDIATELY.  IF PREVIOUS SETUP ERROR, ERROR RETURN
;	  IMMEDIATELY TAKEN, THUS ALL OPERATIONS ABORT.  ONLY WAY TO
;	  CLEAR THIS STATE IS TO SHUT THE PACKAGE DOWN (WITH STPTER).

SETUP:	SKIPN	0,SETFLG		;CHECK THE STATE OF WORLD
	JRST	0,DOSET			;SETFLG=0 ==> NEVER INITIALIZED
	SKIPG	0,SETFLG
	POPJ	STK,0			;SETFLG<0 ==> PREVIOUS ERROR
	POP	STK,WX0			;SETFLG>0 ==> PREVIOUSLY INITIALIZED
	JRST	0,1(WX0)

DOSET:

;	ADP REQUIRES OPEN ON DEVICE BEFORE STATUSES CAN BE READ/SET,
;	SO DO PHONY ASCII OPEN, RELEASE IT, AND PROCEED
;	DOESN'T HURT ON DEC, SO DO IT UNCONDITIONALLY
	SETZM	0,OPNBLK		;ASCII MODE
	SETZM	0,OPNBUF		;NO BUFFERS AS NO I/O BEFORE RELEASE
	OPEN	INCHN,OPNBLK
	JRST	0,SETERR		;OOPS
	RELEASE	INCHN,0

	PUSHJ	STK,SAVSTS		;ATTEMPT TO SAVE CURRENT TERMINAL STATUS
	JRST	0,SETERR
IFN ADPFLG,<

;	Set $$SCM and $$CRT on, $$DEC off.  Leave $$FULL alone (if the
;	user came in with that off, there must have been some reason).
;	If $$INT was 3, clear it (thus forcing BREAK as the attention
;	key); otherwise, leave it as was.  (This allows ESC to interrupt.)

	MOVE	W0,[XWD 400040,0]	;SET CRT IN LSTAT
	MOVE	W1,[XWD 400004,16]	;SET SCM IN CRTSTS
	DMOVEM	W0,TRMARG
	MOVE	W0,[XWD 174,777777]	;SET META TO "|"
	HLRZ	1,SAVINT		; Is current interrupt ETX?
	CAIE	1,3
	HLLZ	1,SAVINT		; No. Set it to itself,
	HRRI	1,20			; whatever it is
	DMOVEM	W0,TRMARG+2
	MOVE	W0,[XWD -4,UDX]	; Leave INT alone now
	SETPAR	W0,0
	JRST	0,SETERR
	MOVE	W0,[XWD 200,16]		;CLEAR DEC IN CRTSTS
	MOVEM	W0,TRMARG
	MOVE	W0,[XWD -2,UDX]
	SETPAR	W0,0
	JRST	0,SETERR
>
	SETOM	0,TRMARG	;TURN OFF SPECIAL FUNCTIONS OF ^R AND ^T
	MOVEI	W0,TRMSET+.TORTC
	PUSHJ	STK,DOTRM3
	JRST	0,SETERR

;	DISPATCH AND OPEN INCHN AND OUTCHN APPROPRIATELY

	SKIPN	0,IN8FG
	JRST	0,SET7I
	PUSHJ	STK,I8OPN		;OPEN FOR IMAGE INPUT
	JRST	0,SETERR
	JRST	0,SETO			;GO SETUP OUTPUT
SET7I:	PUSHJ	STK,I7OPN		;OPEN FOR ASCII INPUT
	JRST	0,SETERR

SETO:	SKIPN	0,OUT8FG
	JRST	0,SET7O
	PUSHJ	STK,O8OPN		;OPEN FOR IMAGE OUTPUT
	JRST	0,SETERR
	JRST	0,SETRET
SET7O:	PUSHJ	STK,O7OPN		;OPEN FOR ASCII OUTPUT
	JRST	0,SETERR

SETRET:	AOS	0,SETFLG		;NORMAL RETURN -- FLAG INITIALIZATION
	POP	STK,WX0
	JRST	0,1(WX0)

SETERR:	SETOM	0,SETFLG		;ERROR -- FLAG PREVIOUS ERROR
	POPJ	STK,0
	SUBTTL	BASIC BUFFERED INPUT ROUTINE

;	INPUT ERROR CODES

	INERR==0	;PLAIN OLD ERROR OF SOME KIND
	INEOF==1	;EOF ON INPUT (IMAGE INPUT ONLY)
	INBRK==2	;IOBRK. SET ON INPUT ATTEMPT
	INFULL==3	;INPUT BUFFER FULL (LNI UUO ONLY)

;	ROUTINE TO INPUT A CHARACTER IN BUFFERED MODE
;	INPUT:  HDRADR -- ADDRESS OF RING BUFFER HEADER
;	OUTPUT: GETCH -- CHARACTER ON DOUBLE SKIP RETURN
;	ROUTINE DOUBLE SKIPS ON SUCCESS, SINGLE SKIPS ON EOF, NO SKIP ON ERROR.
;	IF IOBRK. SET, ROUTINE DOES NOT SKIP, AND CALLING ROUTINE SHOULD
;	CHECK FOR THIS CONDITION BEFORE SIGNALLING ERROR.

GET:	SKIPE	0,IOBRK.
	POPJ	STK,0			;NO SKIP ON IOBRK. SET
	SOSGE	0,BUFBTC(HDRADR)	;CHECK FOR EMPTY BUFFER
	JRST	0,GETBUF		;GO LOAD IT UP
	ILDB	GETCH,BUFBTP(HDRADR)	;GET NEXT CHARACTER FROM BUFFER
	POP	STK,WX0
	JRST	0,2(WX0)		;DOUBLE SKIP RETURN
GETBUF:	IN	INCHN,0			;READ NEW BUFFER
	AOSKP	TINCNT		; 0 Success. Count input break
	JMP	INPERR		; 1 Failure

;	CORRECT BYTE COUNT IF IN ASCII MODE, BY STRIPPING TRAILING NULLS
;	IN BUFFER, AS OPERATING SYSTEM ALWAYS RETURNS COUNT AS MULTIPLE
;	OF FIVE.  THIS MUST BE DONE TO MAKE ROUTINE CHKIN WORK RIGHT.

GETCNT:	SKIPE	0,IN8FG
	JRST	0,GET			;WE ONLY DO THIS IN ASCII MODE
	MOVE	W0,BUFBTC(HDRADR)	;PICK UP BYTE COUNT, DIVIDE BY 5
	IDIVI	W0,5			;TO GET WORD OFFSET IN BUFFER DATA.
					;NOTE THAT DIVISION ZEROES W1
	MOVE	WX0,W0			;GET INTO INDEX REGISTER
	ADD	WX0,0(HDRADR)		;ADD ADDRESS OF BUFFER PTR WORD
	MOVE	W0,1(WX0)		;LOAD DATA WORD
	LSHC	W0,-1			;GET RID OF BIT 35
	MOVEI	3,5		; Five characters/word
GETLP:	LSHC	W0,-7			;LOOP UNTIL NON-ZERO BYTE
	JUMPN	W1,GET			;THERE IT IS
	SOS	0,BUFBTC(HDRADR)	;DECREMENT COUNT
	SOJP	3,GETLP		; Loop for no more than one word
	JMP	GET		; Someone gave us some NULs. Quit
;
INPERR:	GETSTS	INCHN,WX0		;SOME KIND OF PROBLEM--GET STATUS
	TRZN	WX0,740000		;SKIP IF ERROR AND CLEAR IN WX0
	JRST	0,GETEOF		;NOPE--MUST BE EOF
	SETSTS	INCHN,(WX0)		;TELL MONITOR TO IGNORE ERROR
	TRNE	WX0,20000		;SEE IF WE ALSO HAD EOF
GETEOF:	AOS	0,0(STK)		;GIVE SKIP (EOF) RETURN
	POPJ	STK,0
	SUBTTL	Basic TRMOP. Output Routine
;
;	Subroutine to put out a character.  The character is buffered
;	for ASCII mode; if binary, it must be output directly.  (Sigh.)
;
PUT:	SKIPZ	OUT8FG		; Binary mode?
	JMP	PUT8		; Yes
	JUMPZ	6,NULPUT	; NUL must go out as binary
PUT7:	SOSNM	BUFBTC+O7BFHD	; No. Is there room in buffer?
	JMP	BOOT		; No. Flush it
	IDPB	6,BUFBTP+O7BFHD	; Yes. Just store the character
PUTRET:	POP	17,2		; and return+1
	JMP	1(2)
;
NULPUT:	MOVE	2,[POINT 7,O7BUF]; Anything in buffer?
	CAMN	2,BUFBTP+O7BFHD
	JMP	PUT8		; No. Out with it
BOOT:	PUSHJ	17,BOOT7	; Yes, or buffer full. Flush it
	POPJ	17,0		; 0 Error
	JUMPNZ	6,PUT7		; 1 Try again if appropriate
PUT8:	MOVEM	6,TRMARG	; Binary output. Store the character
	MOVEI	0,6		; and write it directly
	PUSHJ	17,DOTRM3
	POPJ	17,0		; 0 Bummer
	AONS	TOCNT		; 1 Count output request
	JMP	PUTRET		; Return OK
;
;	BOOT7--Subroutine to flush the ASCII output buffer.  No
;	parameters.
;
BOOT7:	CLEAR	2,0		; Put in trailing NUL
	IDPB	2,BUFBTP+O7BFHD
	MOVEI	2,O7BUF		; Find output buffer
	MOVEM	2,TRMARG
	MOVEI	0,7		; Output the string
	PUSHJ	17,DOTRM3
	POPJ	17,0		; 0 Error
	AONS	TOCNT		; 1 Count output request
	PUSHJ	17,BUFBLD	; Now rebuild the buffer header
	POP	17,2		; and return+1
	JMP	1(2)
	SUBTTL	Routines to Check Status of Buffers
;
;	Routine to determine state of input buffers
;	  SKIPS IF THERE ARE CHARACTERS STILL IN BUFFER,
;	  NO SKIP IF NEXT GET WILL CAUSE INPUT REQUEST.

CHKIN:	SKIPN	0,IN8FG			;DETERMINE BUFFER TO CHECK
	JRST	0,CHKI7
	SKIPG	0,BUFBTC+I8BFHD		;IMAGE MODE
	POPJ	STK,0			;BUFFER EMPTY
	JRST	0,CHKR
CHKI7:	SKIPG	0,BUFBTC+I7BFHD		;ASCII MODE
	POPJ	STK,0
	JRST	0,CHKR

;	ROUTINE TO DETERMINE STATE OF OUTPUT BUFFERS
;	  SKIPS IF THERE ARE UNWRITTEN CHARACTERS IN BUFFER, ELSE NO SKIP.

CHKOUT:	SKIPZ	OUT8FG		; Binary output?
	POPJ	17,0		; Yes. That's never buffered any more
	MOVE	0,BUFBTC+O7BFHD	; No. Fetch count left
	CAIE	0,23*5-1	; Is it maximum?
CHKR:	AONS	0(17)		; No. Something is there
	POPJ	17,0		; Yes. Exit+0
	SUBTTL	ROUTINE TO FLUSH OUTPUT BUFFER

;	ROUTINE TO FLUSH (WRITE) OUTPUT BUFFER
;	  SKIPS ON SUCCESS, NO SKIP ON ERROR.

FLUSH:	PUSHJ	STK,CHKOUT		;ANYTHING TO FLUSH?
FLUSHR:	AOSKP	0(17)		; No. Exit+1
	PUSHJ	17,BOOT7	; Yes. Try to put it out
	POPJ	17,0		; 0 No go
	JMP	FLUSHR		; 1 Worked
	SUBTTL	CHARACTER I/O ROUTINES USED BY UUO'S

;	ROUTINE TO READ AN IMAGE CHARACTER
;	INPUT:  NONE (INCHN ASSUMED TO BE OPEN IN IMAGE MODE)
;	OUTPUT: AC0 CONTAINS EITHER CHARACTER OR ERROR CODE. ERROR CODES
;	  RETURNED ARE INERR OR INEOF.
;	ROUTINE SKIPS IF CHARACTER READ, NO SKIP ON ERROR.

	EOFMAX==4	;NUMBER OF RETRIES ON EOF (TOPS-10 ONLY)

RD8:	MOVEI	AC0,INERR	;SET FOR ERROR RETURN
	PUSHJ	STK,CHKIN	;IF THIS REQUEST CANNOT BE SATISFIED FROM BUFFER...
	JRST	0,.+2		;THEN FLUSH ANY PENDING OUTPUT
	JRST	0,RD8BEG
	PUSHJ	STK,FLUSH
	POPJ	STK,0		;ERROR
RD8BEG:	MOVEI	HDRADR,I8BFHD	;LOAD BUFFER HEADER BLOCK ADDRESS FOR GET
IFE ADPFLG,<
	MOVEI	EOFC,EOFMAX	;LOAD MAX RETRIES (ELIMINATE ON ADP)
>
RD8GET:	PUSHJ	STK,GET
	POPJ	STK,0		;ON ERROR, DON'T CHECK FOR IOBRK., AS THERE
				;SHOULDN'T BE ANY IN IMAGE MODE
	JRST	0,RD8EOF
	MOVE	AC0,GETCH	;IF READ OK, RETURN
	POP	STK,WX0
	JRST	0,1(WX0)
RD8EOF:

;	ON EOF, ON ADP, JUST RETURN EOF AFTER REOPENING CHANNEL
;	IN CASE MORE IMAGE INPUT IS CALLED FOR. ON TOPS-10, TRY
;	REOPENING AND READING AS MANY TIMES AS EOFMAX INDICATES, AS
;	EOF CAUSED BY 10 SECOND TIMEOUT. AFTER THIS, IF NO CHARACTER
;	YET FORTHCOMING, REOPEN CHANNEL AND RETURN EOF.
	PUSHJ	STK,I8OPN	;REOPEN CHANNEL
	POPJ	STK,0
IFE ADPFLG,<
	SOJG	EOFC,RD8GET	;TRY AGAIN ON TOPS-10
>
	MOVEI	AC0,INEOF	;RETURN EOF CODE
	POPJ	STK,0

;	ROUTINE TO READ AN ASCII CHARACTER
;	INPUT:  NONE (INCHN ASSUMED TO BE OPEN IN ASCII MODE)
;	OUTPUT: AC0 CONTAINS EITHER CHARACTER OR ERROR CODE. ERROR CODES
;	  RETURNED ARE INERR OR INBRK.
;	ROUTINE SKIPS IF CHARACTER READ, NO SKIP ON ERROR.
;	NOTE: FOLLOWING SPECIAL PROCESSING IS DONE:
;	(1) THE LF AFTER CR IS EATEN.
;	(2) IF ECHO IS ON, A CR AFTER A LF ALONE IS WRITTEN.
;	(3) IN BREAK ON ALL CHARACTERS MODE, ESCAPES ARE EATEN,
;	    OTHERWISE, THEY ARE CONVERTED TO CONTROL-D'S.
;	(4) NULLS ARE EATEN.

	OPDEF	OUTCHR[TTCALL 1,0]

;	CHARACTER EQUATES RELEVENT HERE

	CR==15
	LF==12
	ESC==33
	CNTRLD==4

RD7:	MOVEI	AC0,INERR	;SET FOR ERROR RETURN
	PUSHJ	STK,CHKIN	;FORCE OUT PENDING OUTPUT IF INPUT DISMISS
	JRST	0,.+2		;REQUIRED TO SATISFY THIS REQUEST
	JRST	0,RD7BEG
	PUSHJ	STK,FLUSH
	POPJ	STK,0
RD7BEG:	MOVEI	HDRADR,I7BFHD	;LOAD BUFFER HEADER ADDRESS
	PUSHJ	STK,GET
	JRST	0,RD7ERR
	JRST	0,RD7EOF	;ON EOF, GO REOPEN (TO CLEAR EOF) AND READ

;	COMMENCE SPECIAL PROCESSING

	JUMPE	GETCH,RD7	;EAT NULLS
	CAIE	GETCH,CR
	JRST	0,RD71
;	ON ADP, IF ECHO IS OFF, OMIT THE LF EATING EVENTUALLY
	PUSHJ	STK,GET		;EAT LF WE KNOW IS AFTER CR
	JRST	0,RD7ERR
	POPJ	STK,0
	CAIE	GETCH,LF	;AND MAKE SURE ITS A LF
	POPJ	STK,0
	MOVEI	AC0,CR		;SET UP TO RETURN INPUT CHARACTER AS CR
	JRST	0,RD7RET

RD71:	CAIE	GETCH,ESC
	JRST	0,RD72
	SKIPE	0,BRKFG		;IF IN BREAK ON ALL CHARACTERS...
	JRST	0,RD7		;EAT ESCAPES
	MOVEI	AC0,CNTRLD	;ELSE, RETURN CONTROL-D
	JRST	0,RD7RET

;	CHARACTER IS NOT CR (WHICH WE ASSUME IS ALWAYS BREAK CHARACTER)
;	NOR IS IT ESCAPE. PICK UP THE NEXT CHARACTER IN BUFFER FOR
;	FOLLOWING CHECKS.

RD72:	MOVE	AC0,GETCH	;GET CURRENT CHARACTER OUT OF THE WAY
	MOVEI	GETCH,0		;SET TO NULL IF BUFFER EMPTY
	PUSHJ	STK,CHKIN	;CHECK FOR EMPTY BUFFER
	JRST	0,RD73		;ITS EMPTY
	MOVE	WX0,BUFBTP(HDRADR)
	ILDB	GETCH,WX0	;GET NEXT CHARACTER

RD73:	CAIE	AC0,LF		;FINALLY, IF CHARACTER IS NOT LF
	JRST	0,RD74		;THEN GO MAKE ONE FINAL CHECK
	CAIE	GETCH,ESC	;ALWAYS EAT ESCAPE AFTER LF
	JRST	0,RD731
	PUSHJ	STK,GET		;TO EAT IT
	JRST	0,RD7ERR
RD731:	SKIPE	0,ECHOFG	;NOW IF ECHO ON, AND BUFFER EMPTY THEN
	JRST	0,RD7RET
	PUSHJ	STK,CHKIN
	OUTCHR	0,[CR]		;ECHO A CR AS WELL
	JRST	0,RD7RET

RD74:	SKIPN	0,BRKFG		;IF IN BREAK ON ALL CHARACTERS...
	JRST	0,RD7RET
	CAIE	GETCH,ESC	;ALWAYS EAT FOLLOWING ESCAPE
	JRST	0,RD7RET
	PUSHJ	STK,GET		;TO EAT IT
	JRST	0,RD7ERR

RD7RET:	POP	STK,WX0		;SUCCESS RETURN POINT
	JRST	0,1(WX0)

RD7ERR:	MOVEI	AC0,INERR	;TO MAKE SURE ERROR CODE GETS RETURNED
	SKIPE	0,IOBRK.	;CHECK FOR ATTENTION INTERRUPT
	MOVEI	AC0,INBRK	;AND RETURN APPROPRIATE ERROR CODE
	POPJ	STK,0

RD7EOF:	PUSHJ	STK,I7OPN	;REOPEN CHANNEL ON EOF
	POPJ	STK,0
	JRST	0,RD7		;AND GO READ AGAIN

;	ROUTINE TO OUTPUT IMAGE CHARACTER
;	INPUT: AC0--CHARACTER TO WRITE
;	ROUTINE SKIPS ON SUCCESS, NO SKIP ON FAILURE

WR8:	MOVEI	HDRADR,O8BFHD
	MOVE	PUTCH,AC0
	PUSHJ	STK,PUT
	POPJ	STK,0
	POP	STK,WX0
	JRST	0,1(WX0)

;	ROUTINE TO OUTPUT ASCII CHARACTER
;	INPUT: AC0--CHARACTER TO WRITE
;	ROUTINE SKIPS ON SUCCESS, NO SKIP ON FAILURE.
;	A LF IS OUTPUT AFTER CR, AND A CR OUTPUT AFTER LF.

WR7:	MOVEI	HDRADR,O7BFHD
	MOVE	PUTCH,AC0
	PUSHJ	STK,PUT
	POPJ	STK,0
	CAIE	PUTCH,CR	;IF CR ADD LF
	JRST	0,WR71
	MOVEI	PUTCH,LF
	PUSHJ	STK,PUT
	POPJ	STK,0
	JRST	0,WR7RET
WR71:	CAIE	PUTCH,LF	;IF LF ADD CR
	JRST	0,WR7RET
	MOVEI	PUTCH,CR
	PUSHJ	STK,PUT
	POPJ	STK,0
WR7RET:	POP	STK,WX0
	JRST	0,1(WX0)
	SUBTTL	SETTER UUO
;---------- SETTER UUO ----------
;	INPUT:  AC0--NEW STATUS SETTING
;	OUTPUT: NONE.
;	RETURNS: NEVER SKIPS (FLAGS ERRORS BY SETTING SETFLG=-1)

;	STATUS BITS

	NOECHO==1
	IN8==4
	OUT8==2
	BRKALL==10
	BUFOUT==20

UUO25::	JSP	1,JNKFIR	; Fire up old style interface (junk)
	PUSHJ	STK,SETUP
	JRST	0,URET##
	PUSHJ	STK,FLUSH	;FLUSH ANY PENDING OUTPUT
	JRST	0,FLGERR
	MOVE	AC0,AC(0)	;GET NEW SETTTINGS
	SETZM	0,ECHOFG	;SET ECHOFG, OBUFFG, BRKFG TO NEW VALUES
	SETZM	0,OBUFFG
	SETZM	0,BRKFG
	TRNE	AC0,NOECHO
	SETOM	0,ECHOFG
	TRNE	AC0,BUFOUT	;SET OBUFFG
	SETOM	0,OBUFFG
	TRNE	AC0,BRKALL	;SET BRKFG
	SETOM	0,BRKFG
	MOVE	AC1,AC0		;DETERMINE WHETHER I/O MODES ARE BEING CHANGED
	XOR	AC1,PRVMSK	;BY XOR'ING WITH PREVIOUS SETTING
	MOVEM	AC0,PRVMSK	;NOW SAVE NEW SETTING
	TRNN	AC1,IN8
	JRST	0,SETECH
	TRNE	AC0,IN8		;INPUT MODE IS CHANGING
	JRST	0,SETIMI	;TO IMAGE
	PUSHJ	STK,I7OPN	;TO ASCII
	JRST	0,TERERR	;OOPS
	SETZM	0,IN8FG
	JRST	0,SETOUT
SETIMI:	PUSHJ	STK,I8OPN	;CHANGE INPUT TO IMAGE
	JRST	0,TERERR
	SETOM	0,IN8FG
	JRST	0,SETOUT
SETECH:	SKIPE	0,IN8FG		;INPUT MODE NOT CHANGING
	JRST	0,SETOUT	;IF WE ARE IN ASCII, SET ECHO ACCORDING
	SKIPN	0,ECHOFG	;TO NEW SETTING
	JRST	0,SETEON
	PUSHJ	STK,OFFECH	;TURN IT OFF
	JRST	0,TERERR
	JRST	0,SETOUT
SETEON:	PUSHJ	STK,ONECH	;TURN IT ON
	JRST	0,TERERR
SETOUT:	TRNN	AC1,OUT8	;CHECK FOR CHANGE IN OUTPUT MODE
	JRST	0,URET##	;GO HOME IF THERE IS NONE
	TRNE	AC0,OUT8
	JRST	0,SETIMO
	PUSHJ	STK,O7OPN	;SET IT TO ASCII
	JRST	0,TERERR
	SETZM	0,OUT8FG
	JRST	0,URET##
SETIMO:	PUSHJ	STK,O8OPN	;SET IT TO IMAGE
	JRST	0,TERERR
	SETOM	0,OUT8FG
	JRST	0,URET##

TERERR:	SETZM	0,IN8FG		;BEFORE FLAGGING ERROR, MAKE SURE PRVMSK
	SETZM	0,OUT8FG	;AND INDIVIDUAL FLAGS AGREE
	TRNE	AC0,IN8
	SETOM	0,IN8FG
	TRNE	AC0,OUT8
	SETOM	0,OUT8FG
FLGERR:	SETOM	0,SETFLG	;FLAG ERROR
	JRST	0,URET##	;AND GO HOME
	SUBTTL	RDTER UUO
;---------- RDTER UUO ----------
;	INPUT:  NONE.
;	OUTPUT: AC0--CURRENT STATUS SETTING, WITH BIT 0 SET IF THERE
;	  IS PENDING INPUT, AND BIT 1 SET IF THERE IS PENDING OUTPUT.
;	RETURNS: NEVER SKIPS.

;	EQUATES FOR I/O PENDING BITS

	IPEND==400000000000
	OPEND==200000000000

UUO26::	JSP	1,JNKFIR	; Fire up old style interface (junk)
	MOVE	AC0,PRVMSK	;GET PREVIOUS MASK
	PUSHJ	17,SETUP	; Make sure we're set to go
	JMP	RDTRET		; Error. Just return
	PUSHJ	STK,FLUSH	;FIRST, FLUSH OUTPUT
	JRST	0,RDTERR
	PUSHJ	STK,CHKIN	;SEE IF THERE'S ANYTHING IN OUR INPUT BUFFER
	JRST	0,.+3		;NOPE
	OR	AC0,[IPEND]	;YEP
	JRST	0,RDTOUT
	MOVEI	W0,1		;TRMOP. FUNCTION .TOSIP
	PUSHJ	STK,DOTRM2	;SKIP IF INPUT NOT EMPTY
	JRST	0,RDTOUT
	OR	AC0,[IPEND]
RDTOUT:	MOVEI	W0,2		;TRMOP. FUNCTION .TOSOP
	PUSHJ	STK,DOTRM2	;SKIP IF OUTPUT NOT EMPTY
	JRST	0,RDTRET
	OR	AC0,[OPEND]
	JRST	0,RDTRET
RDTERR:	SETOM	0,SETFLG	;FLAG ERRORS IN MANNER OF SETTER
RDTRET:	MOVEM	AC0,AC(0)	;RETURN CURRENT STATUS SETTING
	JRST	0,URET##
	SUBTTL	STPTER UUO
;---------- STPTER UUO ----------
;	INPUT:  AC FIELD=1 -- KILL OPERATION OF THIS PACKAGE, LEAVING
;		STATUS SETTINGS INTACT FOR NEXT SETUP.
;		AC FIELD=0 -- KILL OPERATION AND CLEAR STATUSES.
;	OUTPUT: NONE.
;	RETURNS: NEVER SKIPS.

UUO31::	JSP	1,JNKFIR	; Fire up old style interface (junk)
	SKIPN	0,SETFLG	;IF NOT CURRENTLY IN OPERATION
	JRST	0,CHKCLR	;MERELY CLEAR STATUSES IF CALLED FOR
	SKIPG	0,SETFLG	;IF THINGS ARE OK, THEN FLUSH OUTPUT
	JRST	0,STPNF
	PUSHJ	STK,FLUSH
	JRST	0,.+1		;IGNORE ERRORS
STPNF:	RELEASE	INCHN,0		;RELEASE OUR CHANNELS
	PUSHJ	STK,UNSSTS	;AND RESTORE PREVIOUS STATUS
	SETZM	0,SETFLG	;FLAG GROUND ZERO STATE
CHKCLR:	SKIPE	0,0(14)		;UUO DISPATCHER PLACES AC FIELD HERE
	JRST	0,URET##	;AC FIELD NON-ZERO, GO HOME
	SETZM	0,ECHOFG	;CLEAR INDIVIDUAL STATUS FLAGS
	SETZM	0,IN8FG
	SETZM	0,OUT8FG
	SETZM	0,BRKFG
	SETZM	0,OBUFFG
	SETZM	0,PRVMSK	;AND DON'T FORGET MASK
	JRST	0,URET##
	SUBTTL	SETDEV UUO
;---------- SETDEV UUO ----------
;	INPUT:  AC0--SIXBIT DEVICE NAME
;	OUTPUT: NONE.
;	RETURNS: SKIP ON SUCCESS, NO SKIP IF PACKAGE ALREADY IN OPERATION,
;	  IN WHICH CASE STPTER MUST BE DONE BEFORE SETDEV.

UUO32::	JSP	1,JNKFIR	; Fire up old style interface (junk)
	SKIPE	0,SETFLG
	JRST	0,URET##	;BOO
	MOVE	AC0,AC(0)	;SET DEVICE FIELD IN OPEN BLOCK
	MOVEM	AC0,OPNDEV
	JRST	0,USKP##
	SUBTTL	POPIN UUO
;---------- POPIN UUO ----------
;	INPUT:  NONE.
;	OUTPUT: NONE (PENDING INPUT CLEARED).
;	RETURNS: NEVER SKIPS.

UUO27::	JSP	1,JNKFIR	; Fire up old style interface (junk)
	SKIPG	0,SETFLG	;ARE WE IN OPERATION?
	JRST	0,URET##	;NOPE, THIS IS NOP
	SKIPN	0,IN8FG		;CLEAR OUR BUFFERS BY REOPENING CHANNEL
	JRST	0,CLR7I
	PUSHJ	STK,I8OPN
	JRST	0,POPIER
	JRST	0,POPIMN	;GO CLEAR MONITOR'S BUFFERS
CLR7I:	PUSHJ	STK,I7OPN
	JRST	0,POPIER
POPIMN:	MOVEI	W0,3		;TRMOP. FUNCTION .TOCIB
	PUSHJ	STK,DOTRM2	;CLEAR INPUT BUFFER
	JRST	0,URET##	;IF THIS FAILS, DON'T SWEAT IT
	JRST	0,URET##
POPIER:	SETOM	0,SETFLG	;REOPEN OF CHANNEL FAILED
	JRST	0,URET##
	SUBTTL POPOUT UUO
;---------- POPOUT UUO ----------
;	INPUT:  NONE.
;	OUTPUT: NONE (PENDING OUTPUT CLEARED).
;	RETURNS: NEVER SKIPS.

UUO30::	JSP	1,JNKFIR	; Fire up old style interface (junk)
	SKIPG	0,SETFLG	;IF NOT IN OPERATION
	JRST	0,URET##	;THIS IS NOP
	SKIPN	0,OUT8FG	;REOPEN OUR CHANNEL
	JRST	0,CLR7O
	PUSHJ	STK,O8OPN
	JRST	0,POPOER
	JRST	0,POPOMN
CLR7O:	PUSHJ	STK,O7OPN
	JRST	0,POPOER
POPOMN:	MOVEI	W0,4		;TRMOP. FUNCTION .TOCOB
	PUSHJ	STK,DOTRM2	;CLEAR OUTPUT BUFFER
	JRST	0,URET##
	JRST	0,URET##
POPOER:	SETOM	0,SETFLG
	JRST	0,URET##
	SUBTTL TCI UUO
;---------- TCI UUO ----------
;	INPUT:  NONE.
;	OUTPUT: AC0--CHARACTER READ ON SUCCESS, ERROR CODE ON FAILURE...
;		=0...PLAIN OLD ERROR
;		=1...EOF IN IMAGE INPUT
;		=2...IOBRK. SET
;	RETURNS: SKIP ON SUCCESS, NO SKIP ON FAILURE.

UUO21::	JSP	1,JNKFIR	; Fire up old style interface (junk)
	PUSHJ	STK,SETUP
	JRST	0,TCIBAD
	SKIPE	0,IN8FG		;DETERMINE INPUT MODE
	JRST	0,TCI8
	PUSHJ	STK,RD7		;READ ASCII CHARACTER
	JRST	0,TCIERR
	JRST	0,TCIRET
TCI8:	PUSHJ	STK,RD8		;READ IMAGE CHARACTER
	JRST	0,TCIERR
TCIRET:	MOVEM	AC0,AC(0)
	JRST	0,USKP##
TCIBAD:	MOVEI	AC0,INERR	;ERROR IN SETUP
TCIERR:	MOVEM	AC0,AC(0)	;SET ERROR CODE
	JRST	0,URET##
	SUBTTL TCO UUO
;---------- TCO UUO ----------
;	INPUT:  AC0--CHARACTER TO WRITE
;	OUTPUT: NONE.
;	RETURNS: SKIPS ON SUCCESS, NO SKIP ON FAILURE.

UUO22::	JSP	1,JNKFIR	; Fire up old style interface (junk)
	PUSHJ	STK,SETUP
	JRST	0,URET##
	MOVE	AC0,AC(0)	;LOAD CHARACTER TO WRITE
	SKIPE	0,OUT8FG	;DETERMINE OUTPUT MODE
	JRST	0,TCO8
	ANDI	7,177		; Make sure no junk bits given
	PUSHJ	STK,WR7		;WRITE ASCII CHARACTER
	JRST	0,URET##
	JRST	0,OUTRET
TCO8:	PUSHJ	STK,WR8		;WRITE IMAGE CHARACTER
	JRST	0,URET##
	JRST	0,OUTRET
	SUBTTL LNO UUO
;---------- LNO UUO ----------
;	INPUT:  AC0--WORD ADDRESS OF BUFFER TO WRITE
;		AC1--COUNT OF BYTES TO WRITE
;		FOR IMAGE OUTPUT, BYTES ARE PACKED 4 PER WORD, 5 PER
;		WORD IN ASCII OUTPUT.
;	OUTPUT: NONE.
;	RETURNS: SKIP ON SUCCESS, NO SKIP ON FAILURE.

UUO24::	JSP	1,JNKFIR	; Fire up old style interface (junk)
	PUSHJ	STK,SETUP
	JRST	0,USKP##
	MOVE	AC1,AC(1)	;GET BYTE COUNT IN AC1
	JUMPLE	AC1,USKP##	;CHECK FOR NOP COUNT
	SKIPE	0,OUT8FG
	JRST	0,LNO8
	MOVE	AC2,[POINT 7,0]	;SET UP ASCII BYTE POINTER IN AC2
	HRR	AC2,AC(0)
LNO7LP:	ILDB	AC0,AC2		;LOOP THROUGH BUFFER
	PUSHJ	STK,WR7
	JRST	0,URET##
	SOJG	AC1,LNO7LP
	JRST	0,OUTRET
LNO8:	MOVE	AC2,[POINT 8,0]	;SET UP IMAGE BYTE POINTER
	HRR	AC2,AC(0)
LNO8LP:	ILDB	AC0,AC2		;LOOP
	PUSHJ	STK,WR8
	JRST	0,URET##
	SOJG	AC1,LNO8LP

OUTRET:	SKIPE	0,OBUFFG	;IF NOT BUFFERING, FLUSH OUTPUT
	JRST	0,USKP##
	PUSHJ	STK,FLUSH
	JRST	0,URET##
	JRST	0,USKP##
	SUBTTL	LNI UUO
;---------- LNI UUO ----------
;	INPUT:  AC0--WORD ADDRESS OF CHARACTER BUFFER
;		AC1--MAXIMUM BYTE COUNT OF BUFFER
;	OUTPUT: AC0--ERROR CODE ON FAILURE...
;		=0...PLAIN OLD ERROR (INCLUDING BAD TERMINAL STATUSES)
;		=2...IOBRK. SET
;		=3...BUFFER FULL (AC1=MAXIMUM)
;		AC1--ON SUCCESS, CONTAINS COUNT OF BYTES READ
;	RETURNS: SKIPS ON SUCCESS, NO SKIP ON FAILURE.
;	THIS ROUTINE PERFORMS ^A,^Q,^H,^U,DEL EDITING, ECHOING REASSURANCE
;	IF ECHO IS ON AND CHARACTER CAUSING EDITING WAS BREAK CHARACTER.
;	CR IS STRIPPED AFTER ^D IF ^D WAS NOT BREAK CHARACTER.
;	^V CAUSES NEXT CHARACTER TO BE RETURNED NO MATTER WHAT IT IS.
;	ROUTINE TERMINATES BUFFER ON INPUT OF CR, LF, OR ^G.

;	INTERESTING CHARACTER EQUATES

	CNTRLA==1
	CNTRLG==7
	CNTRLH==10
	CNTRLQ==21
	CNTRLU==25
	CNTRLV==26
	DEL==177

	OPDEF	OUTSTR[TTCALL 3,0]

;	LOCAL ROUTINE TO DELETE PREVIOUS CHARACTER FROM BUFFER
;	(ASSUMES BYTE POINTER IN AC2 AND COUNT IN AC1)

DELPRV:	LDB	W0,[POINT 6,AC2,5]
	ADDI	W0,7		;SHIFT CURRENT BYTE LEFT BY INCREMENTING P FIELD
	CAIGE	W0,44		;CHECK FOR CROSSING WORD BOUNDARY
	JRST	0,DEL1		;NO CROSSING
	MOVEI	W0,1		;POSITION TO LAST BYTE OF PREVIOUS WORD
	SUBI	AC2,1
DEL1:	DPB	W0,[POINT 6,AC2,5]
	SUBI	AC1,1		;DECREMENT COUNT
	POPJ	STK,0

;	LOCAL ROUTINE TO PRINT REASSURANCE MESSAGE FOR EDITING CHARACTERS
;	Message is ASCIZ string pointed to by R7 (any length).
;	PRINTS MESSAGE IF INPUT BUFFER EMPTY AND ECHO IS ON.

REASS:	PUSHJ	STK,CHKIN	;SEE IF OUR BUFFER IS EMPTY, I.E.,
	JRST	0,.+2		;PREVIOUS CHARACTER WAS BREAK CHARACTER
	POPJ	STK,0
	SKIPE	0,ECHOFG	;CHECK FOR ECHO ON
	POPJ	STK,0
	OUTSTR	0(7)		; Print message
	AONS	TOCNT		; (This counts as output)
	POPJ	STK,0

;	LOCAL ROUTINE TO ADD CHARACTER (IN AC0) TO BUFFER
;	(ASSUMES BYTE POINTER IN AC2 AND COUNT IN AC1)
;	EXITS SIDEWAYS TO LNIFUL IF BUFFER FULL AFTER STUFF.

STUFF:	IDPB	AC0,AC2
	ADDI	AC1,1		;INCREMENT AND CHECK COUNT
	POP	STK,WX0		;MAKE SURE STACK IS CORRECT FOR SIDEWAYS EXIT
	CAML	AC1,AC(1)
	JRST	0,LNIFUL
	JRST	0,0(WX0)	;NORMAL RETURN

UUO23::	JSP	1,JNKFIR	; Fire up old style interface (junk)
	PUSHJ	STK,SETUP
	JRST	0,LNIBAD

;	CHECK FOR BOGUS TERMINAL SETTINGS FOR LNI

	SKIPE	0,IN8FG
	JRST	0,LNIBAD
	SKIPE	0,BRKFG
	JRST	0,LNIBAD
	SKIPG	0,AC(1)		;CHECK FOR ZERO LENGTH BUFFER
	JRST	0,LNIFUL

;	INITIALIZE BYTE POINTER AND COUNT

LNIBEG:	MOVE	AC2,[POINT 7,0]
	HRR	AC2,AC(0)
	MOVEI	AC1,0

;	READ NEXT CHARACTER

LNIRD:	PUSHJ	STK,RD7
	JRST	0,LNIERR

;	CHECK FOR ^G, LF, CR AND TERMINATE LOOP

LNICHK:	CAIN	AC0,CR
	JRST	0,LNI0
	CAIN	AC0,CNTRLG
	JRST	0,LNI0
	CAIE	AC0,LF
	JRST	0,LNI1
LNI0:	PUSHJ	STK,STUFF	;STUFF TERMINATING CHARACTER
	JRST	0,LNIRET	;AND GO RETURN

;	CHECK FOR CONTROL-A

LNI1:	CAIE	AC0,CNTRLA
	JRST	0,LNI2
LNI10:	JUMPZ	10,LNIRD	; If buffer empty, don't do anything
	MOVE	7,[POINT 7,BAKUP,13]; Something there. Build echo
	LDB	0,11		; as "\x", where x is deleted character
	DPB	0,7
	PUSHJ	17,DELPRV	; Back up the pointer
	JUMPZ	10,EMPLIN	; Is buffer now empty?
	TDZSKP	1,1		; No
EMPLIN:	MOVEI	1,"\"		; Yes. Include "\CRLF" in echo
	IDPB	1,7
	MOVEI	7,BAKUP		; Print verification
	PUSHJ	17,REASS
	JRST	0,LNIRD

;	CHECK FOR DELETE

LNI2:	CAIN	AC0,DEL
	JRST	0,LNI10		;SAME REASSURANCE AS CONTROL A

;	CHECK FOR CONTROL-H

LNI3:	CAIE	AC0,CNTRLH
	JRST	0,LNI4
	JUMPZ	10,LNIRD	; Nothing to do if buffer empty
	PUSHJ	STK,DELPRV
	JRST	0,LNIRD		;NO REASSURANCE AS ECHO IS BACKSPACE

;	CHECK FOR CONTROL-Q

LNI4:	CAIE	AC0,CNTRLQ
	JRST	0,LNI5
LNI41:	JUMPZ	10,LNIRD	; No echo if line empty
	MOVEI	7,[ASCIZ ' Deleted
']				; Use ADP echo
	PUSHJ	STK,REASS
	JRST	0,LNIBEG	;WHICH DELETES CURRENT CONTENTS OF BUFFER

;	CHECK FOR CONTROL-U

LNI5:	CAIN	AC0,CNTRLU
	JRST	0,LNI41		;SAME REASSURANCE AS CONTROL Q

;	CHECK FOR CONTROL-D

LNI6:	CAIE	AC0,CNTRLD
	JRST	0,LNI7
	PUSHJ	STK,STUFF	;STORE THE CONTROL-D
	PUSHJ	STK,CHKIN	;CHECK BUFFER CONTENTS
	JRST	0,.+2
	JRST	0,LNI61
	JRST	0,LNIRET
LNI61:	PUSHJ	STK,RD7		;CHECK FOR CR AFTER
	JRST	0,LNIERR
	CAIE	AC0,CR		;IF CR, THEN EAT IT AND QUIT
	JRST	0,LNICHK	;ELSE...CONTINUE
	JRST	0,LNIRET

;	MAKE QUICK CHECK FOR CONTROL-V, STUFF CHARACTER AND LOOP

LNI7:	CAIE	AC0,CNTRLV
	JRST	0,LNI71
	PUSHJ	STK,STUFF	;IF WE HAVE CONTROL-V, STUFF IT...
	PUSHJ	STK,RD7		;READ ANOTHER
	JRST	0,LNIERR
LNI71:	PUSHJ	STK,STUFF	;AND STUFF CHARACTER
	JRST	0,LNIRD		;LOOP

;	EXIT POINTS

LNIFUL:	MOVEI	AC0,INFULL	;FULL BUFFER CODE
	JRST	0,LNIERR
LNIBAD:	MOVEI	AC0,INERR	;ERROR DETECTED BY LNI ITSELF
LNIERR:	MOVEM	AC0,AC(0)	;STORE ERROR CODE
	JRST	0,URET##
LNIRET:	MOVEM	AC1,AC(1)	;NORMAL RETURN--STORE COUNT
	JRST	0,USKP##


	END
  -@!Ã