  
         U S E R          M A N U A L ( VERSION 2 ) APRIL 1979
LALR1: AN AUTOMATIC LALR(1) PARSER GENERATOR
  
1. INPUT
  
INPUT TO LALR1 IS A CONTEXT FREE GRAMMAR WRITTEN
IN A FORM OF EXTENDED BNF NOTATION SIMILAR TO [5].
THE LEXEMES OF THIS BNF ARE TERMINALS, NONTERMINALS,
AND THE METASYMBOLS ::=   !   (*   *)   ;  ?  +  -
  
(A) ALL NONTERMINAL SYMBOLS ARE ENCLOSED WITHIN
THE POINTED BRACKETS  <   AND  >. IF THE CHARACTER > IS DESIRED
WITHIN THE NONTERMINAL NAME THEN IT MUST APPEAR
TWICE.  THE NONTERMINAL <> IS INVALID.
  
(B) ALL TERMINAL SYMBOLS ARE ENCLOSED WITHIN SINGLE QUOTES.
IF A SINGLE QUOTE IS DESIRED WITHIN THE TERMINAL NAME THEN
IT MUST APPEAR TWICE. THE TERMINAL '' REPRESENTS THE "NULL
STRING."  NOTE: CONSECUTIVE TERMINALS MUST BE SEPARATED BY
ONE OR MORE BLANKS OTHERWISE THEY WILL BE INTERPRETED AS A
SINGLE TERMINAL WITH AN EMBEDDED APOSTROPHE A PART OF THE NAME.
  
(C)  THE METASYMBOL  ::= IS USED TO SEPARATE THE LEFT HAND
SIDE FROM THE RIGHT HAND SIDES OF A SET OF PRODUCTIONS WITH
THE SAME LEFT HAND SIDE.
  
(D) THE METASYMBOL  !  IS USED TO SEPARATE A SET OF ALTERNATE
RIGHT HAND SIDES WITH THE SAME LEFT HAND SIDE.
  
(E) THE METASYMBOL  ;  IS USED TO TERMINATE EACH "GROUP OF
PRODUCTIONS" WITH THE SAME LEFT HAND SIDE.  NOTE: A SEMICOLON
AFTER THE VERY LAST "GROUP OF PRODUCTIONS" IS OPTIONAL.
  
(F) THE METASYMBOLS  (*  AND *)  ( REPRESENTING THE LEFT-BRACE
AND THE RIGHT-BRACE )
ARE USED TO REPRESENT THE (KLEENE) CLOSURE.  THE EXPRESSION
(* ALPHA *), WHERE ALPHA REPRESENTS ANY SEQUENCE OF TERMINALS
OR NONTERMINALS, MEANS THAT ALPHA CAN OCCUR ZERO OR MORE TIMES.
NESTING OF THE CLOSURE OPERATION IS NOT ALLOWED.
A CONVERSION IS PERFORMED INTERNALLY BY LALR1 TO ELIMINATE ANY
CLOSURE OPERATIONS.  EACH PRODUCTION OF THE FORM
  
                <LHS> ::= ALPHA (* BETA *) GAMMA
  
IS CONVERTED INTO THE SET OF PRODUCTIONS
  
                <LHS> ::= ALPHA <X&LHS> GAMMA ;
                <X&LHS> ::= ! <X&LHS> BETA  ;
  
WHERE ALPHA, BETA, AND GAMMA REPRESENT ARBITRARY SEQUENCES OF
TERMINALS AND NONTERMINALS.   THE ACTUAL LEFT HAND SIDE FOR
EACH AUXILIARY SET OF PRODUCTIONS IS OBTAINED BY PREFIXING
THE ORIGINAL LEFT HAND SIDE WITH A UNIQUE CHARACTER
IN THE RANGE 'A' THROUGH 'Z' FOLLOWED BY '&'.
  
(G) A NULL RIGHT HAND SIDE FOR A PRODUCTION CAN EITHER BE
CODED EXPLICITLY AS THE TERMINAL '' OR BY SIMPLY CODING NOTHING.
  
(H) BLANKS AND TABS ARE COMPLETELY IGNORED EXCEPT WITHIN TERMINALS
AND NONTERMINALS. ALSO THE METASYMBOLS ::=, (*, *) MUST
NOT HAVE EMBEDDED BLANKS.
  
(I) NONE OF THE LEXICAL TOKENS MAY BE SPLIT BETWEEN LINES.
HOWEVER, IT IS PERFECTLY OKAY TO START A NEW LINE AT ANY TIME
AFTER A TOKEN HAS BEEN COMPLETELY CODED ON A LINE.
  
(J) ALL PRODUCTIONS WITH THE SAME LEFT HAND SIDE MUST BE
CODED TOGETHER AS ONE OR MORE CONSECUTIVE "GROUPS OF PRODUCTIONS."
  
(K) THE NONTERMINAL REPRESENTING THE HIGHEST SYNTACTIC CATEGORY
( I.E. THE ONE THAT WILL BE AT THE ROOT OF THE SYNTAX TREE )
MUST HAVE THE "GROUP OF PRODUCTIONS"  FOR WHICH IT IS THE LEFT HAND
SIDE CODED AS THE VERY FIRST "GROUP OF PRODUCTIONS."
  
(L) ANY LINE WITH * IN THE FIRST COLUMN IS TREATED AS A COMMENT.
  
(M) ALL VALID PASCAL CHARACTERS EXCEPT \ (WHICH IS USED INTERNALLY
AS AN END OF LINE INDICATOR) MAY OCCUR WITHIN TERMINALS
OR NONTERMINALS.
  
(N) IF A LINE IS LONGER THAN 80 CHARACTERS THEN IT IS
SPLIT UP INTO SEVERAL LINES, ALL BUT POSSIBLY THE LAST
OF WHICH ARE 80 CHARACTERS IN LENGTH.
  
(O) EXAMPLE:    SENTENCE -> ALPHA BETA
                ALPHA    -> 0 ALPHA '
                ALPHA    -> "NULL STRING"
                BETA     -> 1  BETA
                BETA     -> 1  "OR" 1,1 "OR" 1,1,1 "OR" ...
                BETA     -> "NULL STRING"
  
ONE POSSIBLE EQUIVALENT INPUT FILE FOR LALR1 WOULD BE:
  
********************************
* EXAMPLE INPUT
********************************
<SENTENCE> ::= <ALPHA> <BETA>  ;
<ALPHA>    ::= '0' <ALPHA> ''''  !   ;
<BETA>     ::= '1' <BETA>
                !   '1'  (*  ',' '1' *)  ;
<BETA>      ::=   ''
  
(P) INPUT FOR LALR1 IS NORMALLY A DISK FILE WITH FILE NAME OF YOUR
CHOICE.
  
  
ADDITIONAL FEATURES
---------- --------
  
(Q) THE METASYMBOL ? IS USED FOR INSERTING A "SEMANTIC HOOK"
(MARKER, SEE [2, P. 90]) AT ANY DESIRED PLACE WITHIN A
RIGHT HAND SIDE EXCEPT WITHIN A CLOSURE OPERATION( NOTE
THAT ? LOOKS LIKE A "HOOK").  THE LALR1 PROGRAM REPLACES EACH
? BY A UNIQUE NONTERMINAL <X?LHS> FORMED BY PREFIXING THE
LEFT HAND SIDE WITH A UNIQUE CHARACTER IN THE RANGE 'A'
THROUGH 'Z' FOLLOWED BY '?' AND ADDING THE PRODUCTION
                <X?LHS>::=;
TO THE AUXILIARY PRODUCTIONS.  THE PURPOSE OF THESE SEMANTIC
HOOKS IS TO PERFORM SEMANTIC OPERATIONS IN THE MIDDLE OF
COMPLETING THE PARSE OF A PRODUCTION WHEN THE SYNTAX-DIRECTED
TRANSLATION IS NOT "SIMPLE POSTFIX" [ 2, P. 257].
  
(R) THE METASYMBOLS + (FOR SELF-PRECEDENCE MEANING THAT
A PRODUCTION IS CONSIDERED TO HAVE "PRECEDENCE" OVER ITSELF)
AND - (  FOR NO SELF-PRECEDENCE) CAN PRECEDE THE RIGHT HAND
SIDE OF A PRODUCTION TO INDICATE THAT IF THERE IS ANY
NON-LALR(1) CONFLICT , AND THE HIGHEST PRECEDENCE PRODUCTION
INVOLVED IN THE CONFLICT IS MARKED + OR -, THEN THE CONFLICT
IS AUTOMATICALLY RESOLVED BY LALR1 IN FAVOR OF THE HIGHEST
PRECEDENCE PRODUCTION ( WHERE WE DEFINE THE RELATION "HAS
PRECEDENCE OVER"--ABBREV.  < -- AS X < Y IFF PRODUCTION_#(X)
IS NUMERICALLY LESS THAN PRODUCTION_#(Y) ).  IF A
PRODUCTION HAS A CONFLICT WITH ITSELF ( I.E. THERE IS A
CONFLICT INVOLVING BOTH A SHIFT AND A REDUCE USING THE
SAME PRODUCTION) THEN THE CONFLICT IS RESOLVED IN FAVOR
OF THE REDUCE IF + AND RESOLVED IN FAVOR OF THE SHIFT IF -.
AUTOMATIC RESOLUTION OF CONFLICTS SHOULD BE APPROACHED WITH
CAUTION SINCE THE RESULTING PARSER MAY NOT ACCEPT THE
DESIRED LANGUAGE.  SEE [4] AND THE OTHER REFERENCES CITED THERE.
  
FOR EXAMPLE:
**********************************************
*   THE PRODUCTION <E> ::= <E> '^' <E>
*   HAS PRECEDENCE OVER <E> ::= <E> '*' <E>
*   SIMPLY BY VIRTUE OF BEING CODED BEFORE
*   THE LATTER PRODUCTION.
**********************************************
*   CODING - FOR THE FOLLOWING PRODUCTION
*   GIVES PRECEDENCE TO THE SHIFT OPERATION
*   IN THE CONFLICT THAT INVOLVES
*   <E> ::= <E>  .  '^'  <E>     AND
*   <E> ::= <E>  '^'  <E>  .
*   THE MEANING IN THIS CASE IS THAT
*   '^' IS RIGHT-ASSOCIATIVE.
**********************************************
<E> ::=  -  <E>  '^'  <E>  ;
**********************************************
*   SIMILARLY CODING + FOR THE FOLLOWING
*   PRODUCTION MEANS THAT '*' IS
*   LEFT-ASSOCIATIVE.
**********************************************
<E> ::=  +  <E>  '*'  <E>  ;
<E> ::= 'CONSTANT';
<E> ::= '('  <E>  ')'  ;
  
  
(S) AUXILIARY PRODUCTIONS (FROM CLOSURE AND SEMANTIC HOOKS)
ARE WRITTEN ON AUXFILE ( LALR1.TMP ).
  
(T) MORE FORMALLY THE EXTENDED BNF SYNTAX FOR INPUT GRAMMARS IS:
  
<SYM> ::= "ANY VALID PASCAL CHARACTER EXCEPT \";
<NONTERMINAL> ::= '<' <SYM> (* <SYM> *) '>'  ;
<TERMINAL> ::= '''' (* <SYM> *) ''''   ;
<TER/NONTER> ::= <TERMINAL>  !  <NONTERMINAL> ;
<CLOSURE> ::= '(*'   (* <TER/NONTER> *)  '*)'  ;
<CLO/TER/NONTER/?> ::= <CLOSURE> ! <TERMINAL> ! <NONTERMINAL>  ! '?';
<RHS> ::= <RES> (* <CLO/TER/NONTER/?> *)  ;
<RES> ::=  !  '+'  !  '-'  ;
<PRODG> ::= <NONTERMINAL> '::=' <RHS>  (* '!' <RHS> *)  ;
<PRODSET> ::= <PRODG> (* ';' <PRODG> *)
        !     (* <PRODG> ';'  *)
  
2. RUNNING LALR1
  
TO INVOKE LALR1 TYPE
  
.RUN LALR1
  
LALR1 WILL NEXT SUCCESSIVELY PROMPT
  
INPUT:
OUTPUT:
PTABLE:
  
ASKING FOR STANDARD DEC-10 PHYSICAL FILE DESCRIPTIONS FOR
THOSE CORRESPONDING LOGICAL FILES (DEFAULTS ARE THE
RESPECTIVE DSK: FILES INPUT. OUTPUT. AND PTABLE. ).
  
IF THERE ARE ANY ERRORS IN THE INPUT THEN THE MESSAGE
  
        ERRORS IN INPUT GRAMMAR
  
APPEARS AT THE TERMINAL AND PROCESSING HALTS( SEE APPENDIX
A FOR THE ERROR MESSAGES ASSOCIATED WITH INPUT).
OTHERWISE LALR1 NEXT PROMPTS WITH
  
        PRINT ALL LR(0) SETS?:
  
IF THE RESPONSE IS  Y THEN ALL OF THE LR(0) SETS ARE PRINTED,
OTHERWISE ONLY THOSE LR(0) SETS WHICH ARE NOT LALR(1) ARE
PRINTED.  THE NEXT PROMPT IS
  
        COMPRESSED LISTING?:
  
IF THE RESPONSE IS Y THEN ALL OUTPUT IS PRINTED WITHOUT PAGINATION,
OTHERWISE A NEW PAGE IS STARTED AT EACH SECTION OF THE OUTPUT.
THE  Y  RESPONSE IS INTENDED FOR SAVING PAPER WHEN RUNNING
VERY SHORT EXAMPLE GRAMMARS. AFTER THE BULK OF THE PROCESSING
HAS OCCURRED THE FOLLOWING PROMPT WILL APPEAR:
  
        PRINT OUT TABLE?:
  
A Y RESPONSE MEANS THAT THE LALR1 PARSING TABLE WILL BE PRINTED
OTHERWISE NOT. THEN WILL APPEAR
  
        PRINT REDUCED TABLE?:
  
A Y RESPONSE MEANS TO PRINT OUT THE LR(0)-REDUCED PARSING TABLE.
THE FINAL PROMPT IS:
  
        INITPROCEDURE?:
  
A Y RESPONSE MEANS TO OUTPUT AN INITPROCEDURE FILE CORRESPONDING
TO THE REDUCED PARSING TABLE.  THE EXTENDED PARSER REQUIRED
FOR USING THIS REDUCED FORM OF THE TABLE IS GIVEN IN APPENDIX B.
  
  
3. OUTPUT
  
THE PRINTOUT FOR LALR1 WILL BE FOUND IN THE LOGICAL FILE
OUTPUT.  THE FOLLOWING DESCRIBES EACH SECTION OF THE PRINTED
OUTPUT OR AUXILIARY FILES ( IF THEY HAVE BEEN REQUESTED):
  
(A) THE FIRST SECTION OF THE PRINTOUT IS A LISTING OF THE GRAMMAR
AS CREATED BY THE USER, WITH ANY INTERNALLY GENERATED AUXILIARY
DEFINITIONS RESULTING FROM THE USE OF THE CLOSURE OPERATION OR ?
AT THE END.      IF THERE WERE  ANY  ERRORS
OR WARNINGS IN THE INITIAL PROCESSING OF THE INPUT GRAMMAR THEY
WILL BE SHOWN IMMEDIATELY AFTER THE CORRESPONDING LINE
IN ERROR ( SEE APPENDIX A FOR THE INPUT WARNING AND ERROR MESSAGES).
  
(B) THE NEXT SECTION OF PRINTOUT ( IF NO ERRORS) IS A LIST OF
THE LR(0) SETS FOR THE GRAMMAR ( IF ASKED FOR).  IN EITHER CASE
ANY STATE WITH CONFLICTS ( I.E. MORE THAN ONE POSSIBLE ACTION
FOR THAT ROW IN THE PARSING TABLE MAKING THE GRAMMAR NOT
LALR(1) )  WILL BE FLAGGED WITH THE MESSAGE
  
******** LALR1 CONFLICTS IN THIS STATE ********
  
FOR EACH SUCH CONFLICT STATE IT IS NECESSARY FOR THE USER
TO DECIDE WHETHER OR NOT IT IS POSSIBLE TO AUTOMATICALLY
LET LALR1 RESOLVE ANY CONFLICTS OR NOT.  IF THIS IS POSSIBLE
THEN THE USER MUST REORDER THE PRODUCTIONS SO THAT THE
DESIRED ACTION CORRESPONDS TO THE PRODUCTION WITH HIGHEST
PRECEDENCE AND MUST MARK THAT PRODUCTION WITH A PLUS OR MINUS.
IF THE USER REORDERS BUT FORGETS TO MARK THE PRODUCTION THEN
NO AUTOMATIC RESOLUTION WILL BE PERFORMED.  IF THE USER
DESIRES NOT TO ALLOW LALR1 TO AUTOMATICALLY RESOLVE ANY
CONFLICT FOR A STATE THEN HE MUST ENSURE THAT THE HIGHEST
PRECEDENCE PRODUCTION INVOLVED IS NOT MARKED WITH PLUS OR MINUS.
THE TYPES OF CONFLICTS THAT CANNOT BE RESOLVED BY LALR1 INCLUDE
CASES WHEN MORE THAN ONE SYMBOL LOOKAHEAD IS REQUIRED.
UPON RERUNNING THE GRAMMAR ANY STATES WITH AUTOMATIC
CONFLICT RESOLUTION WILL BE MARKED
  
******** LALR1 CONFLICTS IN THIS STATE ********
******** CONFLICTS RESOLVED ********
  
AT   THE END  OF THIS    SECTION   ONE OF
THE FOLLOWING MESSAGES WILL APPEAR TO REFLECT THE TYPE OF
THE GRAMMAR:
  
***** GRAMMAR  IS  SLR1 *****
***** GRAMMAR IS LALR1 BUT NOT SLR1 *****
***** GRAMMAR IS   N O T   LALR1 *****
  
IF THE GRAMMAR IS NOT LALR1 YET ALL CONFLICTS HAVE
BEEN AUTOMATICALLY RESOLVED THEN THE ADDITIONAL MESSAGE
  
***** ALL CONFLICTS RESOLVED *****
  
WILL APPEAR.
  
(C) THE NEXT SECTION OF OUTPUT IS THE PARSING TABLE
(LABELED ***** PARSING ACTION / GOTO TABLE *****).  THIS
TABLE USES THE SAME FORMAT AS THE DRAGON BOOK [2, P. 201]
WITH THE FOLLOWING DIFFERENCES:
  
        (1) THE STATES ARE NUMBERED STARTING AT 1 INSTEAD OF 0.
  
        (2) NEGATIVE COLUMN HEADINGS ARE THE ACTION PART OF THE
        TABLE.  EACH NEGATIVE INTEGER REPRESENTS ONE OF THE
        TERMINALS OF THE GRAMMAR (SEE THE PRINTOUT SECTION
        ****  CODES FOR THE SYMBOLS *****).
  
        (3) THE ZERO COLUMN REPRESENTS THE  $ ( ENDMARKER OR
        EQUIVALENTLY THE "NULL STRING").
  
        (4) THE POSITIVE COLUMN HEADINGS ARE THE GOTO PORTION
        OF THE TABLE.  EACH POSITIVE NUMBER REPRESENTS ONE OF
        THE NONTERMINALS ( SEE THE OUTPUT SECTION
        ***** CODES FOR THE SYMBOLS *****).
  
        (5) EACH POSITIVE ENTRY IN THE ACTION PART ( SAY ENTRY N)
        REPRESENTS THE ENTRY   SN  IN THE NOTATION OF [1].
  
        (6) EACH POSITIVE ENTRY  N  IN THE GOTO PART REPRESENTS
        EXACTLY THE SAME ENTRY  N IN THE NOTATION OF [1].
  
        (7) EACH NEGATIVE ENTRY  -M  REPRESENTS THE EQUIVALENT
        ENTRY  RM IN THE NOTATION OF [1].
  
        (8) THE CODE  -1  REPRESENTS ACC ("ACCEPT").
  
(D) THE NEXT SECTION OF OUTPUT IS THE CODES FOR ALL TERMINAL
AND NONTERMINAL SYMBOLS.
  
(E) THE NEXT SECTION IS A PRINTOUT OF ALL PRODUCTIONS AND THEIR
NUMBERS.  THE CODE  -1  IS ASSOCIATED WITH THE AUGMENTED PRODUCTION
  
                <S'> ::= <FIRST LHS NONTERMINAL>
  
WHERE <FIRST LHS NONTERMINAL> IS THE LEFT HAND SIDE OF THE
FIRST PRODUCTION THAT THE USER ENTERS INTO HIS GRAMMAR.
LISTED AFTER THE USER PRODUCTIONS MAY BE ADDITIONAL AUXILIARY
PRODUCTIONS CREATED AS THE RESULT OF THE USAGE OF THE CLOSURE
OPERATION OR THE USE OF THE SEMANTIC HOOKS ( ? ).
  
(F) THE PRINTOUT OF THE REDUCED PARSING TABLE IS SIMILAR TO
THE ORIGINAL PARSING TABLE WITH THE INTRODUCTION OF SPECIAL
ENTRIES WHOSE VALUES ARE OF THE FORM -500 - N ( THESE ENTRIES
CORRESPOND TO THE ENTRIES *N IN [3]. SEE THAT REFERENCE FOR
FURTHER INFORMATION.
  
(G) THE INITPROCEDURE FOR INITIALIZING THE REDUCED TABLES
TO DRIVE THE PARSER OF APPENDIX B ARE FOUND IN THE FILE
PTABLE    .
  
(H) THE FINAL ITEM ON THE PRINTOUT IS THE TOTAL CPU RUNTIME
IN SECONDS.
  
REFERENCES
  
[1] AHO, A.V., AND ULLMAN, J.D.  THE THEORY OF PARSING,
        TRANSLATING, AND COMPILING, VOL. 1: PARSING,
        VOL. 2: COMPILING.  PRENTICE-HALL, ENGLEWOOD CLIFFS, N.J.
        1972, 1973.
  
[2] AHO, A. V., AND ULLMAN, J. D. PRINCIPLES OF COMPILER
        DESIGN.  ADDISON-WESLEY, READING, MASS., 1977.
  
[3] ANDERSON, T., EVE, J., AND HORNING, J. J.  EFFICIENT
        LR(1) PARSERS.  ACTA INFORMAT. 2, 1 (1973), 12-39.
  
[4] AHO, A.V., AND JOHNSON, S.C.  DETERMINISTIC PARSING OF AMBIGUOUS
        GRAMMARS.  COMM. ACM 18, 8 (AUG. 1975),PP.441-452.
  
[5] WIRTH, N.  ALGORITHMS + DATA STRUCTURES = PROGRAMS.
        PRENTICE-HALL, ENGLEWOOD CLIFFS, N.J., 1976.
  
APPENDIX A  -- INPUT ERROR MESSAGES
  
  
ROUTINE ISSUING MESSAGE IS INDICATED WITHIN BRACKETS.
  
--------------------------------------------------------------
  
W A R N I N G S :
  
THESE DO NOT AFFECT FURTHER PROCESSING.
  
*****     WARNING: SYMBOL TRUNCATED
        OCCURS WHEN A TERMINAL OR NONTERMINAL NAME
        IS LONGER THAN 15 CHARACTERS AND HAS BEEN TRUNCATED
        TO 15 CHARACTERS.  THE USER MUST ENSURE THAT THE
        FIRST 15 CHARACTERS OF DIFFERENT SYMBOLS OF THE SAME
        TYPE ARE UNIQUE [CREATEPRODS].
  
*****     WARNING: AUX SYMBOL TRUNCATED
        OCCURS WHEN AUXILIARY NONTERMINAL CREATED FROM USAGE OF
        CLOSURE OPERATION IS LONGER THAN 15 CHARACTERS [CREATEPRODS].
  
*****     WARNING: HOOK SYMBOL TRUNCATED
        OCCURS WHEN AUXILIARY NONTERMINAL CREATED FROM USAGE
        OF SEMANTIC HOOK IS LONGER THAN 15 CHARACTERS [CREATEPRODS].
  
*****     WARNING: USELESS NONTERMINAL <NONTERMINAL>
        OCCURS IF <NONTERMINAL> IS USED IN A RIGHT
        HAND SIDE BUT DOES NOT OCCUR AS SOME LEFT HAND
        SIDE.  THE PARSER WILL NEVER BE ABLE TO ACCESS
        SUCH A PRODUCTION SO USER SHOULD CORRECT THIS [CREATARRAYS].
  
*****     WARNING: LINE IS SPLIT
        THIS WARNING OCCURS IF A LINE IS LONGER THAN 80 CHARACTERS.
        IN THIS CASE THE LINE IS SPLIT UP INTO TWO OR MORE LINES,
        ALL BUT POSSIBLY THE LAST OF WHICH ARE EXACTLY 80 CHARACTERS
        [CREATEPRODS].
  
  
  
--------------------------------------------------------------
  
S Y N T A X     E R R O R S :
  
THE FOLLOWING ERRORS  DETECTED IN INPUT WILL
HALT FURTHER PROCESSING PAST READING IN THE INPUT.
AFTER FINDING THE ERROR THE REMAINING INPUT IS FLUSHED
UP THROUGH THE NEXT SEMICOLON AND PROCESSING CONTINUES
AS IF THIS WERE THE START OF A NEW PRODUCTION [CREATEPRODS].
  
*****     ::= NOT FOUND
  
*****     INVALID LEFT HAND SIDE
        MUST BE A NONTERMINAL.
  
*****      INVALID SYMBOL ON RT HAND SIDE
        MUST BE ! ; (* TERMINAL NONTERMINAL OR END OF DATA
        ( ALSO + OR - IF THEY ARE LEFTMOST )
  
*****     INVALID SYMBOL IN CLOSURE
        OCCURS IF OTHER THAN NONTERMINAL OR TERMINAL
        IS FOUND WITHIN (* AND *).
  
*****     PRODUCTIONS WITH THIS LHS ALREADY SEEN
        ALL PRODUCTIONS WITH SAME LEFT HAND SIDE MUST BE
        CODED TOGETHER IN A SINGLE GROUP.
  
*****     NO INPUT GRAMMAR
        DUE TO ERRORS OR OTHERWISE, NO VALID PRODUCTIONS
        WERE FOUND.
  
  
--------------------------------------------------------------
  
S C A N N E R     E R R O R S :
  
THESE ERRORS ARE ENCOUNTERED WHEN SCANNING
FOR THE NEXT LEXICAL TOKEN.  THE TOKEN IN ERROR IS COMPLETELY
IGNORED AS IF IT HAD NOT OCCURRED IN THE INPUT STREAM. THESE
ERRORS WILL ALSO HALT PROCESSING AFTER READING IN THE INPUT [GETSYM].
  
*****     SYMBOL CONTINUES PAST END OF LINE
        TOKEN SYMBOLS MUST NOT EXTEND ACROSS LINE
        BOUNDARIES. THIS MESSAGE MAY ALSO OCCUR IF SPLITTING
        A LONG LINE BREAKS UP A LEXICAL TOKEN.
  
*****     ZERO LENGTH NONTERMINAL
        THE NONTERMINAL SYMBOL <> IS INVALID.
  
*****     (* MISTYPED
  
*****     *) MISTYPED
  
*****     ::= MISTYPED
  
*****     ILLEGAL CHARACTER [X]
        OCCURS IF INVALID INPUT CHARACTER 'X' IS FOUND.
  
  
--------------------------------------------------------------
  
O V E R F L O W    E R R O R S :
  
THESE MESSAGES APPEAR AT THE TERMINAL
AND REQUIRE RECOMPILATION WITH INCREASED ARRAY BOUNDS.
EXECUTION IS HALTED IMMEDIATELY AFTER THESE MESSAGES.
  
 [NON]TERMINAL SYMBOL TABLE OVERFLOW
        INCREASE MAXTER/MAXNONTER AND MAXNT AND RECOMPILE[CREATEPRODS].
  
TOO MANY ITEMS
        INCREASE MAXITEMS AND RECOMPILE [CREATEPRODS].
  
TOO MANY LR(0) SETS
        INCREASE MAXSETS AND RECOMPILE[CREATLR0SETS].
  
TOO MANY ELEMENTS
   INCREASE MAXBACK AND RECOMPILE[LR1LA].
  
TOO MANY AUX RULES
        CAN'T HAVE MORE THAN 26 CLOSURE OPERATIONS [CREATEPRODS].
  
TOO MANY SEM. HOOKS
        CAN'T HAVE MORE THAN 26 SEMANTIC HOOKS [CREATEPRODS].
  
APPENDIX B -- EXTENDED LR PARSER
  
  
THIS PARSER IS BASED UPON THE LALR PARSING ALGORITHM
FOUND IN [3] WITH CORRECTIONS.  THE USER SHOULD FILL IN
THE BOUNDS INDICATED BY THE ???'S WITH THE CORRECT VALUES
DETERMINED FROM THE PRINTOUT OF LALR1.  ALSO SEVERAL OF THE
PROCEDURES NEED BE WRITTEN BY THE USER TO HANDLE THE
SPECIAL FEATURES OF HIS LANGUAGE:
  
(*********************************************)
(* EXTENDED LALR1 PARSING ALGORITHM          *)
(*********************************************)
CONST
  MINSTACK = 1; (* ELEMENT AT BOTTOM OF STACK *)
  MAXSTACK = ???; (* MAXIMUM SIZE OF STACK *)
  
  MINRHSSIZE = 0;
  MAXRHSSIZE = ???; (* MAX RIGHT HAND SIDE SIZE *)
  
  ERRORSTATE = 0; (* ERROR STATE FOR PARSER *)
  MINSTATE = 1; (* FIRST STATE OF PARSER *)
  MAXSTATE = ???; (* MAXIMUM STATE OF PARSER *)
  
  MINPRODNO = ???; (* SMALLEST PRODUCTION NUMBER *)
  MAXPRODNO = -1; (* LARGEST PRODUCTION NUMBER :
                   <S'> ::= <HIGHEST SYNTACTIC CATEGORY>  *)
  SHIFT = 0; (* CODE FOR SHIFT USED BY PUSH_SYMBOL *)
  
  ACCEPT = -1; (* CODE FOR ACCEPT *)
  LR0REDUCE = -500; (* ADDEND TO INDICATE SPECIAL
                     CODE FOR REPLACED LR0-REDUCE STATE *)
  MINCODE = ???; (*  SMALLEST CODE IN PARSING TABLE
                   = LR0REDUCE + MINPRODNO *)
  
  MINTERMINAL = ???; (* MINIMUM TERMINAL CODE *)
  LAMBDA = 0; (* CODE FOR LAMBDA *)
  SPRIME = 0; (* CODE FOR <S'> *)
  MINNONTERMINAL = 1;
  MAXNONTERMINAL = ???; (* CODE FOR MAXIMUM NONTERMINAL CODE *)
  
TYPE
  STACKRANGE = MINSTACK..MAXSTACK;
  STATERANGE = MINSTATE..MAXSTATE;
  ENTRYRANGE = MINCODE..MAXSTATE; (* RANGE OF ENTRIES IN THE
                                   PARSING TABLE *)
  SYMBOLRANGE = MINTERMINAL..MAXNONTERMINAL;
  TERMINALRANGE = MINTERMINAL..LAMBDA;
  NONTERMINALRANGE = MINNONTERMINAL..MAXNONTERMINAL;
  PRODNORANGE = MINPRODNO..MAXPRODNO;
  EXPRODNORANGE = MINPRODNO..SHIFT;
  USER_DEFINED = ???; (* THIS TYPE IS USED TO HOLD USER
                         SEMANTIC INFORMATION ON THE
                         STACK FOR LATER ACCESS *)
  
VAR
  STACK: ARRAY[STACKRANGE] OF
  RECORD
    SEMANTIC_INFO: USER_DEFINED;
    STACKSTATE: STATERANGE
  END;
  
  (* PARSING TABLE *)
  P: ARRAY[STATERANGE, SYMBOLRANGE] OF ENTRYRANGE;
  (*LEFT HAND SIDE CODE FOR EACH PRODUCTION *)
  LHS: ARRAY[PRODNORANGE] OF NONTERMINALRANGE;
  (* LENGTH OF RIGHT HAND SIDE FOR EACH PRODUCTION *)
  RHSLENGTH: ARRAY[PRODNORANGE] OF MINRHSSIZE..MAXRHSSIZE;
  
  CURRENT_STATE: STATERANGE;
  TOS: STACKRANGE; (* CURRENT TOP OF STACK *)
  LOOKAHEAD: TERMINALRANGE;
  LEFT_HAND_SIDE: NONTERMINALRANGE;
  OLD_ACTION,ACTION: ENTRYRANGE;
  (************************************)
  
  < COPY THE FILE PTABLE HERE.  IT IS THE
    INITPROCEDURE FOR INITIALIZING THE ARRAYS
    P, LHS, AND RHSLENGTH FOR YOUR GRAMMAR
    NOTE: ASSUMPTION IS THAT ALL VALUES NOT IN
    ASSIGNMENT STATEMENTS ARE AUTOMATICALLY
    INITIALIZED TO ZERO!!!!   >
  
  (*************************************)
  PROCEDURE GET_SYMBOL(VAR SYMBOL: SYMBOLRANGE);
   BEGIN (* GET_SYMBOL *)
    < CALL SCANNER TO GET THE NEXT INPUT TO ASSIGN TO SYMBOL>
   END (* GET_SYMBOL *);
  (*************************************)
  PROCEDURE PUSH_SYMBOL(NEWSYMBOL: SYMBOLRANGE; ACTION: EXPRODNORANGE);
    (***********************************)
    PROCEDURE SEMANTICS;
     BEGIN (* SEMANTICS *)
      IF (ACTION = SHIFT)
      THEN <SEMANTICS ASSOCIATED WITH EACH DESIRED LEXICAL
            TOKEN FOUND IN NEWSYMBOL>
      ELSE <SEMANTICS ASSOCIATED WITH EACH PRODUCTION
            NUMBER FOUND IN ACTION>
     END (* SEMANTICS *);
   BEGIN (* PUSH_SYMBOL *)
    TOS := TOS + 1;
    SEMANTICS
   END (* PUSH_SYMBOL *);
  (******************************************)
  PROCEDURE PUSH_STATE(STATE: STATERANGE);
   BEGIN (* PUSH_STATE *)
    STACK[TOS].STACKSTATE := STATE
   END (* PUSH_STATE *);
  
  (******************************************)
  PROCEDURE POP(ENTRIES: STACKRANGE);
   BEGIN (* POP *)
    TOS := TOS - ENTRIES
   END (* POP *);
  (***************************************)
  PROCEDURE PROCESS_ERROR;
   BEGIN (* PROCESS_ERROR *)
    < PLACE ERROR PROCESSING CODE HERE >
   END (* PROCESS_ERROR *);
  
  (*MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM*)
 BEGIN (* MAIN *)
  TOS := MINSTACK;
  CURRENT_STATE := MINSTATE;
  GET_SYMBOL(LOOKAHEAD);
  
   REPEAT
    PUSH_STATE(CURRENT_STATE);
    ACTION := P[CURRENT_STATE,LOOKAHEAD];
  
    IF (ACTION > ERRORSTATE)
    THEN
    (************************* SHIFT ******************************)
     BEGIN (* SHIFT *)
      PUSH_SYMBOL(LOOKAHEAD,SHIFT);
      CURRENT_STATE := ACTION;
      GET_SYMBOL(LOOKAHEAD)
     END (* SHIFT *)
  
    ELSE
     IF (ACTION < ACCEPT)
     THEN
      (**************************** REDUCE **************************)
       BEGIN (* REDUCE *)
        IF (ACTION < LR0REDUCE)
        THEN
        (*********************ELIMINATED LR0-REDUCE ******************)
         BEGIN (* LR0-REDUCE *)
          PUSH_SYMBOL(LOOKAHEAD,SHIFT);
          GET_SYMBOL(LOOKAHEAD);
          ACTION := ACTION - LR0REDUCE; (* ACTION NOW CONTAINS THE
                                         PRODUCTION NUMBER *)
         END (* LR0-REDUCE *);
  
         REPEAT
          POP(RHSLENGTH[ACTION]);
          LEFT_HAND_SIDE := LHS[ACTION];
          OLD_ACTION := ACTION;
          ACTION := P[STACK[TOS].STACKSTATE,LEFT_HAND_SIDE];
          PUSH_SYMBOL(LEFT_HAND_SIDE,OLD_ACTION)
         UNTIL ( ACTION >= ACCEPT );
        IF (ACTION >= MINSTATE)
        THEN CURRENT_STATE := ACTION
       END (* REDUCE *);
  
    IF (ACTION = ERRORSTATE)
    THEN
    (************************* ERROR ****************)
    PROCESS_ERROR
   UNTIL (ACTION = ERRORSTATE) OR (ACTION = ACCEPT);
  IF (ACTION = ACCEPT)
  THEN PUSH_SYMBOL(SPRIME,ACCEPT)
 END (* MAIN *).
 nQ³