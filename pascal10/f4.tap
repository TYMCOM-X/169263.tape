{TEST 5.2.2-1, CLASS=QUALITY}
{
----------------------------------------------------------------------

(C) Copyright

A.H.J. Sale
R.A. Freak

July 1979

All rights reserved

This material may not be reproduced or copied in
whole or part without written permission from the authors.

Department of Information Science
University of Tasmania
Box 252C, G.P.O.,
Hobart 7000.
Tasmania
Australia.

----------------------------------------------------------------------

}

{ This program does not conform to the standard because its
  meaning is altered by the truncation of its identifiers to 8
  characters. Does the processor provide any indication that the
  program does not conform?
  Such surreptitious changes of meaning are dangerous.
  Obviously processors with 8-character significance will have
  difficulty in detecting such problems, but it can be done.
  For processors with full significance it is easier. }

program t5p2p2d1(output);
const
   valueofaverylongidentifier1 = 10;
procedure p;
var
   valueofaverylongidentifier2:integer;
begin
   valueofaverylongidentifier2:=11;
   if valueofaverylongidentifier1 <>
      valueofaverylongidentifier2 then
      writeln(' IDENTIFIERS DISTINGUISHED...5.2.2-1')
   else
      writeln(' IDENTIFIERS NOT DISTINGUISHED...5.2.2-1')
end;

begin
   p
end.
{TEST 6.1.2-1, CLASS=DEVIANCE}

{ This test checks that nil is implemented as a reserved
  word, as it should be. The compiler deviates if the program compiles
  and prints DEVIATES. }

program t6p1p2d1(output);
var
   i:(tick,cross,nil);
begin
   i:=nil;
   writeln(' DEVIATES...6.1.2-1, NIL')
end.
{TEST 6.1.2-2, CLASS=DEVIANCE}

{ This test checks that reserved words cannot in fact be redefined.
  The compiler deviates if the program compiles and prints DEVIATES}

program t6p1p2d2(output);
var
   thing:(var,string);
begin
   thing:=string;
   writeln(' DEVIATES...6.1.2-2, RESERVED WORDS')
end.
{TEST 6.1.2-3, CLASS=CONFORMANCE}

{ This test checks the implementation of identifiers
  and reserved words to see that the two are correctly distinguished.
  The compiler fails if the program does not compile and
  print PASS. }

program t6p1p2d3(output);
var
   procedurex,procedurf,procedur:char;
   functionx,functiom,functio:integer;
   iffy:boolean;
begin
   procedurex:='0';
   procedurf:='1';
   procedur:='2';
   functionx:=0;
   functiom:=1;
   functio:=2;
   iffy:=true;
   writeln(' PASS...6.1.2-3, IDENTIFIERS')
end.
{TEST 6.1.3-1, CLASS=CONFORMANCE}

{ The Pascal Standard permits identifiers to be of any length
  This test will simply print out 'PASS' if the compiler accepts
  identifiers of lengths up to 70 characters. }

program t6p1p3d1(output);
const
   i10iiiiiii = 10;
   i20iiiiiiiiiiiiiiiii = 20;
   i30iiiiiiiiiiiiiiiiiiiiiiiiiii = 30;
   i40iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii = 40;
   i50iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii = 50;
   i60iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii = 60;
i70iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
								= 70;

begin
   if i10iiiiiii + i20iiiiiiiiiiiiiiiii +
      i30iiiiiiiiiiiiiiiiiiiiiiiiiii +
      i40iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii +
      i50iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii +
      i60iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii +
i70iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii
      <> 280 then
      writeln(' FAIL...6.1.3-1')
   else
      writeln(' PASS...6.1.3-1')
end.
{TEST 6.1.3-2, CLASS=CONFORMANCE}

{ The Pascal Standard states that matching upper and lower
  case letters are equivalent in identifiers and word-symbols
  (i.e. reserved words) if they are permitted. If this is the
  case for this compiler, then the program shall print 'PASS'.
  The compiler fails  if the program cannot be compiled.
  This test is irrelevant for one case compilers. }

program t6p1p3d2(output);
var
   conform  : integer;

Begin
   BEGIN
      Conform:=1;
      CONFORM:=2;
      If conform = 2 then
	 writeln(' PASS...6.1.3-2')
   enD
end.
{TEST 6.1.3-3, CLASS=QUALITY}

{ Although the Standard places no limit on the LENGTH of
  identifiers, they must be UNIQUE in at least the first 8
  characters. This program will determine the significance
  of identifiers from 3 characters to 20 characters.
  This program is of course non-standard, and relies on scope
  masquerades. It assumes a naive significance limit exists,
  or that there is none. Some compilers may violate the assumption
  by hashing an identifier tail or preserving the real length. }

program t6p1p3d3(output);
const
   i3i = 3;
   i4ii = 1;
   i5iii = 1;
   i6iiii = 1;
   i7iiiii = 1;
   i8iiiiii = 1;
   i9iiiiiii = 1;
   i10iiiiiii = 1;
   i11iiiiiiii = 1;
   i12iiiiiiiii = 1;
   i13iiiiiiiiii = 1;
   i14iiiiiiiiiii = 1;
   i15iiiiiiiiiiii = 1;
   i16iiiiiiiiiiiii = 1;
   i17iiiiiiiiiiiiii = 1;
   i18iiiiiiiiiiiiiii = 1;
   i19iiiiiiiiiiiiiiii = 1;
   i20iiiiiiiiiiiiiiiii = 1;

procedure signif;
const
   i3j = 0;
   i4ij = 0;
   i5iij = 0;
   i6iiij = 0;
   i7iiiij = 0;
   i8iiiiij = 0;
   i9iiiiiij = 0;
   i10iiiiiij = 0;
   i11iiiiiiij = 0;
   i12iiiiiiiij = 0;
   i13iiiiiiiiij = 0;
   i14iiiiiiiiiij = 0;
   i15iiiiiiiiiiij = 0;
   i16iiiiiiiiiiiij = 0;
   i17iiiiiiiiiiiiij = 0;
   i18iiiiiiiiiiiiiij = 0;
   i19iiiiiiiiiiiiiiij = 0;
   i20iiiiiiiiiiiiiiiij = 0;

var
   x : integer;
begin
   x:=i3i + i4ii + i5iii + i6iiii + i7iiiii + i8iiiiii +
      i9iiiiiii + i10iiiiiii + i11iiiiiiii + i12iiiiiiiii +
      i13iiiiiiiiii + i14iiiiiiiiiii + i15iiiiiiiiiiii +
      i16iiiiiiiiiiiii + i17iiiiiiiiiiiiii + i18iiiiiiiiiiiiiii +
      i19iiiiiiiiiiiiiiii + i20iiiiiiiiiiiiiiiii;

   if x = 20 then
      writeln(' NUMBER OF SIGNIFICANT CHARACTERS >= 20')
   else
      writeln(' NUMBER OF SIGNIFICANT CHARACTERS = ', x)
end;

begin
   signif;
end.
{TEST 6.1.5-1, CLASS=CONFORMANCE}

{ This program tests the conformance of the compiler to
  the syntax productions for numbers specified by the
  Pascal Standard.
  If all productions are permitted the program will
  print 'PASS'. The compiler fails if the program will
  not compile. }

program t6p1p5d1(output);

const
   { all cases are legal productions }
   a = 1;
   b = 12;
   c = 0123;
   d = 123.0123;
   e = 123.0123E+2;
   f = 123.0123E-2;
   g = 123.0123E2;
   h = 123E+2;
   i = 0123E-2;
   j = 0123E2;

begin
   writeln(' PASS...6.1.5-1')
end.
{TEST 6.1.5-2, CLASS=CONFORMANCE}

{ This program simply tests if very long numbers are permitted.
  The value should be representable despite its length. }

program t6p1p5d2(output);
const
   reel = 123.456789012345678901234567890123456789;
begin
   writeln(' PASS...6.1.5-2')
end.
{TEST 6.1.5-3, CLASS=DEVIANCE}

{ The number productions specified in the Pascal Standard
  clearly state that a decimal point must be preceded by
  a digit sequence.
  The compiler deviates if the program compiles, in which case
  the program will print 'DEVIATES', or if one of the cases is
  accepted.
  The compiler conforms if all the cases are rejected. }

program t6p1p5d3(output);
const
   r = .123;
var
   i : real;
begin
   i:=.123;
   i:=-.123;
   writeln(' DEVIATES...6.1.5-3');
end.
{TEST 6.1.5-4, CLASS=DEVIANCE}

{ The number productions specified in the Pascal Standard
  clearly state that a decimal point must be followed by
  a digit sequence.
  The compiler deviates if the program compiles, in which case
  the program will print 'DEVIATES'.
  The compiler conforms if the program fails to compile. }

program t6p1p5d4(output);
var
   i : real;

begin
   i:=0123.;
   writeln(' DEVIATES...6.1.5-4');
end.
{TEST 6.1.5-5, CLASS=DEVIANCE}

{ Spaces in numbers are forbidden by the Pascal Standard
  This includes spaces around '.' and 'E'. The compiler
  deviates if ONE or MORE of the cases below are accepted.
  The compiler conforms if ALL cases are rejected. }

program t6p1p5d5(output);
const
   one	 = 1 234;
   two	 = 0 .1234;
   three = 0. 1234;
   four  = 1234 E2;
   five  = 1234E 2;
   six	 = 1234E- 2;
   seven = 1234E+ 2;
begin
   writeln(' DEVIATES...6.1.5-5')
end.
{TEST 6.1.5-6, CLASS=DEVIANCE}

{ The Pascal standard allows equivalence of upper and
  lower-case letters in names and reserved words only.
  Will the compiler accept 'e' as equivalent to 'E'?
  It should not. The test is not relevant
  to one-case processors. }

program t6p1p5d6(output);
var
   i : real;
begin
   i:=123e2;
   writeln(' DEVIATES...6.1.5-6')
end.
{TEST 6.1.6-1, CLASS=CONFORMANCE}

{ Labels are permitted in standard Pascal. This program
  simply tests if they are permitted by this compiler.
  The compiler fails if the program will not compile
  (or the message printed out is incorrect). }

program t6p1p6d1(output);
label
   1,2,3,4,5;

begin
      write(' P');
      goto 4;
   1: write('.6');
      goto 5;
   2: write('SS');
      goto 3;
   3: write('..');
      goto 1;
   4: write('A');
      goto 2;
   5: writeln('.1.6-1');
end.
{TEST 6.1.6-2, CLASS=CONFORMANCE}

{ Labels should be distinguished by their apparent integral value
  according to the Pascal Standard.
  This program tests if this is the case for this compiler. If so
  then the program shall print PASS. }

program t6p1p6d2(output);
label
   5,6,7;
begin
      goto 5;
0006: goto 7;
   5: goto 6;
 007: writeln('PASS...6.1.6-2')
end.
{TEST 6.1.7-1, CLASS=CONFORMANCE}

{ Character strings consisting of a single character
  are the constants of the standard type char. This
  program simply tests that these are permitted by
  the compiler.
  The compiler fails if the program will not compile. }

program t6p1p7d1(output);
const
   one = '1';
   two = '2';
var
   twotoo : char;
begin
   if (one <> two) and (two = '2') then
      begin
      twotoo:='2';
      if twotoo = two then
	 writeln(' PASS...6.1.7-1')
      else
	 writeln(' FAIL...6.1.7-1')
      end
   else
      writeln(' FAIL...6.1.7-1')
end.
{TEST 6.1.7-2, CLASS=CONFORMANCE}

{ The Pascal standard does not place an upper limit
  on the length of strings. This program tests if strings
  are permitted up to a length of 68 characters. The
  compiler fails if the program will not compile. }

program t6p1p7d2(output);
type
   string1 = packed array[1..68] of char;
   string2 = packed array[1..33] of char;
var
   alpha : string1;
   i	 : string2;
begin
   alpha:=
'ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOP';
   i:='IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII';
   writeln(' PASS...6.1.7-2')
end.
{TEST 6.1.7-3, CLASS=CONFORMANCE}

{ The Pascal standard allows quotes to appear as char
  constants and permits them to appear in strings.
  If this is desired, they must be written twice.
  This program tests that the compiler will allow this.
  The compiler fails if the program will not compile. }

program t6p1p7d3(output);
const
   quote = '''';
   strquote = 'CAN''T';
begin
   writeln(' PASS...6.1.7-3')
end.
{TEST 6.1.7-4, CLASS=DEVIANCE}

{ This program tests that strings of different lengths are
  not compatible (i.e. 1..m and 1..n).
  The compiler fails if the program compiles. }

program t6p1p7d4(output);
const
   string1 = 'STRING1';
var
   string2 : packed array[1..5] of char;
begin
   string2:=string1;
   writeln(' DEVIATES...6.1.7-4')
end.
{TEST 6.1.7-5, CLASS=DEVIANCE}

{ The Pascal Standard specifically states that character
  strings are constants of the type
      packed array[1..n] of char
  This program tests that this type is not compatible
  with unpacked arrays.
  The compiler conforms if the program fails to compile. }

program t6p1p7d5(output);
var
   string1 : packed array[1..4] of char;
   string2 : array[1..4] of char;
begin
   string1:='STR1';
   string2:='STR2';
   writeln(' DEVIATES...6.1.7-5')
end.
{TEST 6.1.7-6, CLASS=DEVIANCE}

{ Again, a character string is a constant of the type
      packed array[1..n] of char.
  This program tests that strings are not compatible
  with bounds other than 1..n.
  The compiler conforms if the program fails to compile. }

program t6p1p7d6(output);
var
   string1 : packed array[1..4] of char;
   string2 : packed array[0..3] of char;
   string3 : packed array[2..5] of char;
begin
   string1:='STR1';
   string2:='STR2';
   string3:='STR3';
   writeln(' DEVIATES...6.1.7-6')
end.
{TEST 6.1.7-7, CLASS=DEVIANCE}

{ Again, as character strings are constants of the type
      packed array[1..n] of char,
  they should not be compatible with packed arrays of
  subranges of char.
  The compiler conforms if the program will not compile. }

program t6p1p7d7(output);
type
   alpha = 'A'..'Z';
var
   string1 : packed array[1..4] of char;
   string2 : packed array[1..4] of alpha;
begin
   string1:='FOUR';
   string2:='FOUR';
   writeln(' DEVIATES...6.1.7-7')
end.
{TEST 6.1.7-8, CLASS=DEVIANCE}

{ Similarly to 6.1.7-7, subranges of char should not be
  compatible with packed arrays of char. However, if the extension
  is allowed, it should be correctly handled.
  Standards conforming processors will not compile the program,
  compilers which permit the extension should detect the error
  at compile-time or run-time, but should not execute without
  error. }

program t6p1p7d8(output);
type
   digit = '0'..'9';
var
   string1 : packed array[1..4] of char;
   string2 : packed array[1..4] of digit;
begin
   string1:='FOUR';
   string2:='FOUR';
   writeln(' DEVIATES...6.1.7-8')
end.
{TEST 6.1.7-9, CLASS=DEVIANCE}

{ Some compilers may allow compatibility between strings and char
  constants. The two types for which they are constants are not
  compatible.
  This program tests what the compiler will allow.
  If all cases are accepted the program will print DEVIATES.
  However, if one or more of the cases are accepted, then the
  compiler deviates for those cases. }

program t6p1p7d9(output);
const
   a = 'A';
var
   string1 : packed array[1..4] of char;
   string2 : packed array[1..1] of char;
   achar   : char;
begin
   string1:=a;		{ CASE 1 }
   string1:='A';	{ CASE 2 }
   string2:=a;		{ CASE 3 }
   string2:='A';	{ CASE 4 }
   achar:=string2;	{ CASE 5 }
   string1:='A	 ';
   achar:=string1;	{ CASE 6 }
   string1:='	A';
   achar:=string1;	{ CASE 7 }
   writeln(' DEVIATES...6.1.7-9')
end.
{TEST 6.1.7-10, CLASS=DEVIANCE}

{ The Pascal Standard states that string types are compatible
  if they have the same number of components.
  Some compilers may allow assignment of one string type to another,
  padding out with spaces or truncating characters if they are
  not of the same lengths.
  All the cases below should be strictly rejected.
  The compiler deviates if one or more are accepted. }

program t6p1p7d10(output);
var
   string1 : packed array[1..4] of char;
   string2 : packed array[1..6] of char;
begin
   writeln('DEVIATES...6.1.7-10');
   string1:='AB';	{ 1-pad with spaces ? }
   writeln('CASE 1 : ', string1);
   string1:='ABCD';
   string2:=string1;	{ 2-what happens here ? }
   writeln('CASE 2 : ', string2);
   string1:='ABCDEFG';	{ 3-what happens here ? }
   writeln('CASE 3 : ', string1)
end.
{TEST 6.1.7-11, CLASS=DEVIANCE}

{ The Pascal Standard says that a character string is a sequence of
  characters enclosed by apostrophes, consequently there is no
  NULL string. Does the compiler allow this in programs.
  The compiler conforms if the program does not compile. }

program t6p1p7d11(output);
begin
   writeln('':20);
   writeln(' DEVIATES...6.1.7-11')
end.
{TEST 6.1.8-1, CLASS=CONFORMANCE}

{ The Pascal Standard states that a comment is considered to
  be a token separator. This program tests if the compiler
  allows this.
  The compiler fails if the program cannot be compiled. }

program{ Is this permitted to be here? }t6p1p8d1(output){ Or here? };
var
   i{ control variable }:{ colon }integer{ type };
begin
   for{ This is a FOR loop }i{ control variable }:={ assignment }
      1{ initial value }to{ STEP 1 UNTIL }1{ repetitions }do{ go }
      writeln{ write statement }(' PASS...6.1.8-1')
end.
{TEST 6.1.8-2, CLASS=CONFORMANCE}

{ The Pascal Standard permits an open curly bracket to
  appear in a comment. This program tests that the
  compiler will allow this.
  The compiler fails if the program will not compile. }

program t6p1p8d2(output);
begin
   { Is a { permitted in a comment? }
   writeln(' PASS...6.1.8-2')
end.
{TEST 6.1.8-3, CLASS=CONFORMANCE}

{ This program tests that if the compiler allows both
  forms of comments, must the delimiters be the same.
  If only one form of comment is permitted, the test is not relevant. }

program t6p1p8d3(output);
begin
   { This is a standard comment }
   (* This is an alternative form *)
   { What will happen here? *).....}
   (* Or here? }.....*)
   writeln(' PASS...6.1.8-3')
end.
{TEST 6.1.8-4, CLASS=QUALITY}

{ In the case of an unclosed comment, does the compiler help
  the programmer to detect that this is so ? Hard to trace run-time
  errors may occur  if a comment accidentally encloses 1 or more
  statements. }

program t6p1p8d4(output);
var
   i : integer;
begin
   i:=10;
   { Now write out the value of i.
   writeln(' THE VALUE OF I IS:', i);
   { The value of i will not be printed because of the unclosed
     previous comment. }
   i:=0
end.
{TEST 6.1.8-5, CLASS=DEVIANCE}

{ Nested comments are not permitted in Pascal and hence
  this program should not compile. The compiler deviates if the
  program compiles and prints DEVIATES. }

program t6p1p8d5(output);
begin
   { writeln(' RAN')
   { writeln(' RAN1') }
   writeln(' RAN2') }
   writeln(' DEVIATES...6.1.8-5, NESTED COMMENTS')
end.
{TEST 6.2.1-1, CLASS=CONFORMANCE}

{ This program includes a sample of each declaration
  part in its minimal form.  Every possibility is covered elsewhere
  in the validation suite, but the test is made here. }

program t6p2p1d1(output);
label
   1;
const
   one = 1;
type
   small = 1..3;
var
   tiny : smaprocedure p(var x : small);
begin
   x:=1
end;
begin
   goto 1;
1: p(tiny);
   if (tiny = one) then
      writeln(' PASS...6.2.1-1')
end.
{TEST 6.2.1-2, CLASS=CONFORMANCE}

{ This program checks that multiple repetitions are possible
  in the declaration parts, and is provided as a check.  Practically
  all occurrences will re-appear elsewhere in the validation
  suite. }

program t6p2p1d2(output);
label
   1,2,3;
const
   one=1;
   two=2;
   three=3;
type
   small = 1..3;
   larger = 1..10;
   biggest = 1..100;
var
   tiny : small;
   soso : larger;
   big : biggest;
procedure p(var x : small);
begin
   x:=1
end;
procedure q(var y : larger);
begin
   y:=2
end;
procedure r(var z : biggest);
begin
   z:=3
end;
begin
   p(tiny); goto 2;
1: r(big); goto 3;
2: q(soso); goto 1;
3: if (tiny=one) and (soso=two) and (big=three) then
      writeln(' PASS...6.2.1-2')
end.
{TEST 6.2.1-3, CLASS=DEVIANCE}

{ Checks to see that labels are not permitted unless
  they have been declared in the heading }

program t6p2p1d3(output);
begin
   3: writeln(' DEVIATES...6.2.1-3')
end.
{TEST 6.2.1-4, CLASS=DEVIANCE}

{ Checks to see that labels may not be given two sites
  in the executable part.  Since the label is not used
  in a goto this program is a stringent test. }

program t6p2p1d4(output);
label
   9;
begin
   9: write(' DEVIATES');
      if true <> false then
	 9: writeln('...6.2.1-4')
end.
{TEST 6.2.1-5, CLASS=DEVIANCE}

{ This program declares a label, but it is not sited
  nor referenced.  This is illegal, as each declared
  label must appear once (and only once) in the executable
  part of the program. }

program t6p2p1d5(output);
label
   9;
begin
   writeln(' DEVIATES...6.2.1-5')
end.
{TEST 6.2.1-6, CLASS=CONFORMANCE}

{ This is the minimal program. }

program t6p2p1d6;
begin
end.
{TEST 6.2.1-7, CLASS=ERRORHANDLING}

{ The Pascal Standard states that '..local variables have values
  which are undefined at the beginning of the statement part..'.
  The undefined value is dependent on the implementation.
  Ideally the program should not run. However, if it does, the
  program shall print the value of i, whether it be a system
  initialized value or rubbish left over from procedure q. }

program t6p2p1d7(output);

procedure q;
var
   i,j : integer;
begin
   i:=2;
   j:=3
end;

procedure r;
var
   i : integer;
begin
   writeln('ERROR NOT DETECTED...6.2.1-7: THE VALUE OF I IS ', I)
end;

{ Program body }
begin
   q;
   r
end.
{TEST 6.2.1-8, CLASS=QUALITY}

{ This test checks that a large number of types may be declared
  in a program. It is an attempt to discover any small limit imposed
  on the number of types by a compiler. }

program t6p2p1d8(output);
type
   t1 = 0..1;
   t2 = 0..2;
   t3 = 0..3;
   t4 = 0..4;
   t5 = 0..5;
   t6 = 0..6;
   t7 = 0..7;
   t8 = 0..8;
   t9 = 0..9;
   t10 = 0..10;
   t11 = 0..11;
   t12 = 0..12;
   t13 = 0..13;
   t14 = 0..14;
   t15 = 0..15;
   t16 = 0..16;
   t17 = 0..17;
   t18 = 0..18;
   t19 = 0..19;
   t20 = 0..20;
   t21 = 0..21;
   t22 = 0..22;
   t23 = 0..23;
   t24 = 0..24;
   t25 = 0..25;
   t26 = 0..26;
   t27 = 0..27;
   t28 = 0..28;
   t29 = 0..29;
   t30 = 0..30;
   t31 = 0..31;
   t32 = 0..32;
   t33 = 0..33;
   t34 = 0..34;
   t35 = 0..35;
   t36 = 0..36;
   t37 = 0..37;
   t38 = 0..38;
   t39 = 0..39;
   t40 = 0..40;
   t41 = 0..41;
   t42 = 0..42;
   t43 = 0..43;
   t44 = 0..44;
   t45 = 0..45;
   t46 = 0..46;
   t47 = 0..47;
   t48 = 0..48;
   t49 = 0..49;
   t50 = 0..50;
var
   v1 : t1;
   v2 : t2;
   v3 : t3;
   v4 : t4;
   v5 : t5;
   v6 : t6;
   v7 : t7;
   v8 : t8;
   v9 : t9;
   v10 : t10;
   v11 : t11;
   v12 : t12;
   v13 : t13;
   v14 : t14;
   v15 : t15;
   v16 : t16;
   v17 : t17;
   v18 : t18;
   v19 : t19;
   v20 : t20;
   v21 : t21;
   v22 : t22;
   v23 : t23;
   v24 : t24;
   v25 : t25;
   v26 : t26;
   v27 : t27;
   v28 : t28;
   v29 : t29;
   v30 : t30;
   v31 : t31;
   v32 : t32;
   v33 : t33;
   v34 : t34;
   v35 : t35;
   v36 : t36;
   v37 : t37;
   v38 : t38;
   v39 : t39;
   v40 : t40;
   v41 : t41;
   v42 : t42;
   v43 : t43;
   v44 : t44;
   v45 : t45;
   v46 : t46;
   v47 : t47;
   v48 : t48;
   v49 : t49;
   v50 : t50;
begin
   writeln(' 50 TYPES COMPILED...6.2.1-8')
end.
{TEST 6.2.1-9, CLASS=QUALITY}

{ This test checks that a large number of labels may be declared
  in a program. It is an attempt to detect a small compiler limit on
  the number of labels. }

program t6p2p1d9(output);
label
   1,2,3,4,5,6,7,8,9,10,
   11,12,13,14,15,16,17,18,19,20,
   21,22,23,24,25,26,27,28,29,30,
   31,32,33,34,35,36,37,38,39,40,
   41,42,43,44,45,46,47,48,49,50;
begin
   1: ;
   2: ;
   3: ;
   4: ;
   5: ;
   6: ;
   7: ;
   8: ;
   9: ;
   10: ;
   11: ;
   12: ;
   13: ;
   14: ;
   15: ;
   16: ;
   17: ;
   18: ;
   19: ;
   20: ;
   21: ;
   22: ;
   23: ;
   24: ;
   25: ;
   26: ;
   27: ;
   28: ;
   29: ;
   30: ;
   31: ;
   32: ;
   33: ;
   34: ;
   35: ;
   36: ;
   37: ;
   38: ;
   39: ;
   40: ;
   41: ;
   42: ;
   43: ;
   44: ;
   45: ;
   46: ;
   47: ;
   48: ;
   49: ;
   50: ;
   writeln(' 50 LABELS DECLARED AND SITED...6.2.1-9')
end.
{TEST 6.2.2-1, CLASS=CONFORMANCE}

{ The Pascal Standard permits redefinition of a user name, by a
  further defining occurrence in a range (eg. procedure block)
  enclosed by the first defining occurence. This second range
  (and all ranges enclosed by it) are excluded from the scope of
  the defining occurence of the first range.
  This program tests the scope conformance of the compiler
  for user names. }

program t6p2p2d1(output);
const
   range = 10;
var
   i : integer;
   pass : boolean;
procedure redefine;
const
   range = -10;
var
   i : integer;
begin
   i:=range;
end;

begin
   i:=1;
   pass:=false;
   redefine;
   if range=-10 then
      writeln(' FAIL...6.2.2-1: SCOPE ERROR-RANGE')
   else
      pass:=true;
   if i=-10 then
      writeln(' FAIL...6.2.2-1: SCOPE ERROR-I')
   else
      if pass then
	 writeln(' PASS...6.2.2-1')
end.
{TEST 6.2.2-2, CLASS=CONFORMANCE}

{ The Pascal Standard allows a user to redefine a predefined name.
  This program tests whether this is allowed by this compiler. }

program t6p2p2d2(output);
var
   true : boolean;
begin
   true:=false;
   if true = false then
      writeln(' PASS...6.2.2-2')
   else
      writeln(' FAIL...6.2.2-2')
end.
{TEST 6.2.2-3,CLASS=CONFORMANCE}

{ This program is similar to 6.2.2-4, however a type identifier,
  say T, which specifies the domain of a pointer type ^T, is
  permitted to have its defining occurence anywhere in the type
  definition part in which ^T occurs.
  Thus in this example, (node=real)s' scope is excluded from the
  type definition of ouch.
  The compiler fails if the program does not compile or fails at
  run time. }

program t6p2p2d3(output);
type
   node = real;
procedure ouch;
type
   p = ^node;
   node = boolean;
var
   ptr : p;
begin
   new(ptr);
   ptr^:=true;
   writeln(' PASS...6.2.2-3')
end;
begin
   ouch;
end.
{TEST 6.2.2-4, CLASS=DEVIANCE}

{ The Pascal Standard says that the defining occurrence of an
  identifier or label precedes all corresponding occurrences of
  that identifier or label in the program text (except for specific
  pointercase). The scope of an identifier or label also includes
  the whole block in which it is defined, thereby disallowing
  any references to an outer identifier of the same name preceeding
  the defining occurrence.  Some compilers may not conform
  to this and allow some scope overlap.
  The compiler conforms if the program does not compile and objects
  to the use of 'red' in ouch preceding its definition. }

program t6p2p2d4(output);
const
   red = 1;
   violet = 2;
procedure ouch;
const
   m = red;
   n = violet;
type
   a = array[m..n] of integer;
var
   v : a;
   colour : (yellow,green,blue,red,indigo,violet);
begin
   v[1]:=1;
   colour:=red;
end;
begin
   ouch;
   writeln(' DEVIATES...6.2.2-4 --> SCOPE ERROR NOT DETECTED')
end.
{TEST 6.2.2-5, CLASS=CONFORMANCE}

{ Similarly to 6.2.2-2, labels are allowed to be redefined
  in a range enclosed by the first defining occurrence
  (eg. procedures and functions). This program tests if
  this is permitted by this compiler. }

program t6p2p2d5(output);
label
   4,5,6;
var
   i : integer;
procedure redefine;
label
   6,7,8;
var
   j : integer;
begin
      j:=1;
      goto 6;
   7: j:=j-1;
      goto 8;
   6: j:=j+1;
      goto 7;
   8: j:=0;
end;

begin
      goto 4;
   5: i:=i+1;
      goto 6;
   4: i:=1;
      redefine;
      goto 5;
   6: if i=1 then
	 writeln(' FAIL...6.2.2-5')
      else
	 writeln(' PASS...6.2.2-5')
end.
{TEST 6.2.2-6, CLASS=CONFORMANCE}

{ As for the other conformance tests in this section,
  it is possible to redefine a field-name of a record within
  the same scope as this record.
  The compiler also fails if the program does not compile. }

program t6p2p2d6(output);
var
   j : integer;
   x : record
	 j:integer
       end;
begin
   j:=1;
   x.j:=2;
   with x do
      j:=3;
   if (j=1) and (x.j=3) then writeln(' PASS...6.2.2-6')
   else  writeln(' FAIL...6.2.2-6')
end.
{TEST 6.2.2-7, CLASS=DEVIANCE}

{ It is possible to redefine a function name within the scope
  of a function name. This test checks that the inner function
  redefines f, whether an erroneous assignment to f is detected or
  whether the erroneous outer f, with no function assignment is
  allowed to execute. }

program t6p2p2d7(output);
var
   bool:boolean;
   j:integer;

function f(i:integer) : integer;
   function f(i:integer) : integer;
   begin
      f:=i
   end;
begin
   if bool then
      writeln(' FAIL...6.2.2-7, PROCEDURE SCOPE')
      { FAILs if the call is recursive }
   else begin
      bool:=true;
      f:=f(i);
   end
end;

begin
   bool:=false;
   j:=f(1);
   if (j=1) then
      writeln(' DEVIATES...6.2.2-7, PROCEDURE SCOPE');
end.
{TEST 6.2.2-8, CLASS=CONFORMANCE}

{ It is possible to declare a function but not assign a value
  to that function at that level. This program assigns a value
  to a function from within a function within the function.
  The compiler fails if the program does not compile or it prints
  FAIL. }

program t6p2p2d8(output);
var
   j,k:integer;

function f1(i:integer):integer;
   function f2(i:integer):integer;
      function f3(i:integer):integer;
      begin
	 f3:=1;
	 f1:=i
      end;
   begin
      f2:=f3(i)
   end;
begin
   j:=f2(i)
end;

begin
   k:=f1(5);
   if (k=5) then
      writeln(' PASS...6.2.2-8, FUNCTION')
   else
      writeln(' FAIL...6.2.2-8, FUNCTION')
end.
{TEST 6.2.2-9, CLASS=DEVIANCE}

{ This program attempts to assign a value to a function outside
  the bounds of the function. The compiler deviates if the
  program prints DEVIATES. }

program t6p2p2d9(output);
var
   i:integer;

function f1:integer;
begin
   f1:=6
end;

function f2(i:integer):integer;
begin
   f2:=i;
   f1:=5
end;

begin
   i:=f1;
   i:=f2(2);
   writeln(' DEVIATES...6.2.2-9, FUNCTION')
end.
{TEST 6.2.2-10, CLASS=CONFORMANCE}

{ This obscure program is nevertheless standard Pascal.
  An inner scope hides part of a type while leaving other parts
  accessible. The compiler fails if the program does not
  compile or the program prints FAIL. }

program t6p2p2d10(output);
type
   colour=(red,amber,green);
var
   c:colour;

procedure nested;
type
   colour=(purple,red,blue);
var
   paint:colour;
begin
   c:=green;
   paint:=red;
   c:=pred(amber);
   if (ord(c)<>0) or (ord(paint)<>1) then
      writeln(' FAIL...6.2.2-10, SCOPE');
end;

begin
   nested;
   if (c<> red) then
      writeln(' FAIL...6.2.2-10, SCOPE')
   else
      writeln(' PASS...6.2.2-10, SCOPE')
end.
{TEST 6.3-1, CLASS=CONFORMANCE}

{ This program exhibits all legal productions for a constant
  in a const declaration. }

program t6p3d1(output);
const
   ten = 10;
   minusten = -10;
   minustentoo = -ten;
   decade = ten;
   dot = '.';
   stars = '****';
   on = true;
   pi = 3.1415926;
   minuspi = - pi;
begin
   writeln(' PASS...6.3-1')
end.
{TEST 6.3-2, CLASS=DEVIANCE}

{ This program checks that signed chars are not permitted.
  Note that minus may have a worse effect than plus. }

program t6p3d2(output);
const
   dot = '.';
   plusdot = + dot;
begin
   writeln(' DEVIATES...6.3-2')
end.
{TEST 6.3-3, CLASS=DEVIANCE}

{ This program checks that signed strings are not permitted.
  Note that minus may have a worse effect than plus. }

program t6p3d3(output);
const
   stars = '****';
   plusstars = + stars;
begin
   writeln(' DEVIATES...6.3-3')
end.
{TEST 6.3-4, CLASS=DEVIANCE}

{ This program checks that signed scalars are not permitted.
  Note than minus may have a worse effect than plus. }

program t6p3d4(output);
const
   truth = true;
   plustruth = + truth;
begin
   writeln(' DEVIATES...6.3-4')
end.
{TEST 6.3-5, CLASS=DEVIANCE}

{ This program tests that signed constants are not permitted
  in other contexts than const declarations. }

program t6p3d5(output);
const
   dot = '.';
begin
   writeln(' DEVIATES', +dot, '..6.3-5')
end.
{TEST 6.3-6, CLASS=DEVIANCE}

{ A constant may not be used in its own declaration - the
  following is a pathological case which should be detected
  or at least handled with care. }

program t6p3d6(output);
const
   ten = 10;

procedure p;
const
   ten = ten;
begin
   if ten=10 then
      writeln(' DEVIATES...6.3-6: SCOPE ERROR')
   else
      writeln(' DEVIATES...6.3-6: DEFINITION POINT ERROR')
end;

begin
   p
end.
{TEST 6.4.1-1, CLASS=CONFORMANCE}

{ This program tests to see that pointer types can be
  declared anywhere in the type part.  This freedom
  is explicitly permitted in the standard. }

program t6p4p1d1(output);
type
   ptr1     = ^ polar;
   polar    = record r,theta : real end;
   purelink = ^ purelink;
   ptr2     = ^ person;
   ptr3     = ptr2;
   person   = record
		  mother,father : ptr2;
		  firstchild	: ptr2;
		  nextsibling	: ptr3
	      end;
begin
   writeln(' PASS...6.4.1-1')
end.
{TEST 6.4.1-2, CLASS=DEVIANCE}

{ This program tests that attempts to use types in their
  own definitions are detected.  Two examples are
  attempted. Both should fail. }

program t6p4p1d2(output);
type
   x  = record
	    xx : x
	end;
   y  = array[0..1] of y;
begin
   writeln(' DEVIATES...6.4.1-2')
end.
{TEST 6.4.1-3, CLASS=DEVIANCE}

{ This program also tests that attempts to use types in
  their own definitions are detected, but inserts a nasty
  scope twist by making another type with the same identifier
  available in an outer scope.	It should be excluded from this
  scope, according to the Standard. }

program t6p4p1d3(output);
type
   x  = integer;

procedure p;
type
   x  = record
	    y : x
	end;
begin
   writeln(' DEVIATES...6.4.1-3: SCOPE ERROR')
end;

begin
   p
end.
{TEST 6.4.2.2-1, CLASS=CONFORMANCE}

{ This program tests that the standard simple types have all
  been implemented. They are denoted by predefined type identifiers.
  The compiler fails if the program does not compile. }

program t6p4p2p2d1(output);
var
   a : integer;
   b : real;
   c : boolean;
   d : char;
begin
   a:=6*2+3;
   b:=3.14159*2;
   c:=(a=15);
   d:='Z';
   writeln(' PASS...6.4.2.2-1')
end.
{TEST 6.4.2.2-2, CLASS=CONFORMANCE}

{ The Pascal Standard specifies that the values an integer may
  take are within the range -maxint..+maxint.
  This program checks this. }

program t6p4p2p2d2(output);
type
   natural = 0..maxint;
   whole = -maxint..+maxint;
var
   i : natural;
   j : whole;
   k : integer;
begin
   i:=maxint;
   j:=-maxint;
   k:=maxint;
   writeln(' PASS...6.4.2.2-2')
end.
{TEST 6.4.2.2-3, CLASS=CONFORMANCE}

{ The Pascal Standard states that type BOOLEAN has truth values
  denoted by the identifiers true and false, and that they are
  such that false is less than true.
  This program tests if the compiler allows this. }

program t6p4p2p2d3(output);
begin
   if false < true then
      writeln(' PASS...6.4.2.2-3')
   else
      writeln(' FAIL...6.4.2.2-3')
end.
{TEST 6.4.2.2-4, CLASS=CONFORMANCE}

{ The Pascal Standard states that the character values representing
  the digits 0..9 are ordered and contiguous.
  The program tests these two criteria for these characters. }

program t6p4p2p2d4(output);
var
   a,b : boolean;
begin
   a:=(succ('0') = '1') and
      (succ('1') = '2') and
      (succ('2') = '3') and
      (succ('3') = '4') and
      (succ('4') = '5') and
      (succ('5') = '6') and
      (succ('6') = '7') and
      (succ('7') = '8') and
      (succ('8') = '9') ;

   b:=('0' < '1') and
      ('1' < '2') and
      ('2' < '3') and
      ('3' < '4') and
      ('4' < '5') and
      ('5' < '6') and
      ('6' < '7') and
      ('7' < '8') and
      ('8' < '9') ;
   if a and b then
      writeln(' PASS...6.4.2.2-4')
   else
      writeln(' FAIL...6.4.2.2-4')
end.
{TEST 6.4.2.2-5, CLASS=CONFORMANCE}

{ The Pascal Standard states that the upper-case letters A-Z are
  ordered, but not necessarily contiguous.
  This program determines if this is so, and prints
  a message as to whether the compiler passes or not . }

program t6p4p2p2d5(output);
begin
   if ('A' < 'B') and ('B' < 'C') and ('C' < 'D') and
      ('D' < 'E') and ('E' < 'F') and ('F' < 'G') and
      ('G' < 'H') and ('H' < 'I') and ('I' < 'J') and
      ('J' < 'K') and ('K' < 'L') and ('L' < 'M') and
      ('M' < 'N') and ('N' < 'O') and ('O' < 'P') and
      ('P' < 'Q') and ('Q' < 'R') and ('R' < 'S') and
      ('S' < 'T') and ('T' < 'U') and ('U' < 'V') and
      ('V' < 'W') and ('W' < 'X') and ('X' < 'Y') and
      ('Y' < 'Z') then
      writeln(' PASS...6.4.2.2-5')
   else
      writeln(' FAIL...6.4.2.2-5: NO ORDERING')
end.
{TEST 6.4.2.2-6, CLASS=CONFORMANCE}

{ The Pascal Standard states that the lower-case letters a-z are
  ordered, but not necessarily contiguous.
  This program determines if this is so, and prints
  a message as to whether the compiler passes or not .
   NOTE: this program uses lower-case char constants and may
	 fail for this reason. The test is also irrelevant for
	 one-case compilers. }

program t6p4p2p2d6(output);
begin
   if ('a' < 'b') and ('b' < 'c') and ('c' < 'd') and
      ('d' < 'e') and ('e' < 'f') and ('f' < 'g') and
      ('g' < 'h') and ('h' < 'i') and ('i' < 'j') and
      ('j' < 'k') and ('k' < 'l') and ('l' < 'm') and
      ('m' < 'n') and ('n' < 'o') and ('o' < 'p') and
      ('p' < 'q') and ('q' < 'r') and ('r' < 's') and
      ('s' < 't') and ('t' < 'u') and ('u' < 'v') and
      ('v' < 'w') and ('w' < 'x') and ('x' < 'y') and
      ('y' < 'z') then
      writeln(' PASS...6.4.2.2-6')
   else
      writeln(' FAIL...6.4.2.2-6: NO ORDERING')
end.
{TEST 6.4.2.2-7, CLASS=IMPLEMENTATIONDEFINED}

{ The Pascal Standard states that the value of maxint is
  dependent on the implementation.
  This program prints out the implementation defined value
  of maxint. }

program t6p4p2p2d7(output);
begin
   writeln(' THE IMPLEMENTATION DEFINED VALUE OF MAXINT IS ',
	    maxint)
end.
{TEST 6.4.2.3-1, CLASS=CONFORMANCE}

{ This program checks the possible syntax productions for
  enumerated types, as specified by the Pascal Standard.
  The compiler fails if the program does not compile. }

program t6p4p2p3d1(output);
type
   singularitytype = (me);
   switch	   = (on,off);
   maritalstatus   = (married,divorced,widowed,single);
   colour	   = (red,pink,orange,yellow,green);
   cardsuit	   = (heart,diamond,spade,club);
var
   i : singularitytype;
begin
   i:=me;
   writeln(' PASS...6.4.2.3-1')
end.
{TEST 6.4.2.3-2, CLASS=CONFORMANCE}

{ The Pascal Standard states that the ordering of the values
  of the enumerated type is determined by the sequence in which
  the constants are listed, the first being before the last.
  The compiler fails if the program does not compile. }

program t6p4p2p3d2(output);
var
   suit : (club,spade,diamond,heart);
   a	: boolean;
   b	: boolean;
begin
   a:=(succ(club)=spade) and
      (succ(spade)=diamond) and
      (succ(diamond)=heart);

   b:=(club < spade) and
      (spade < diamond) and
      (diamond < heart);

   if a and b then
      writeln(' PASS...6.4.2.3-2')
   else
      writeln(' FAIL...6.4.2.3-2')
end.
{TEST 6.4.2.4-1, CLASS=CONFORMANCE}

{ This program tests that a type may be defined as a subrange
  of another ordinal-type (host-type).
  The compiler fails if one or more of the cases below are rejected. }

program t6p4p2p4d1(output);
type
   colour      = (red,pink,orange,yellow,green,blue);
   somecolour  = red..green;
   century     = 1..100;
   twentyone   = -10..+10;
   digits      = '0'..'9';
   zero        = 0..0;
   logical     = false..true;
var
   tf : logical;

begin
   tf:=true;
   writeln(' PASS...6.4.2.4-1')
end.
{TEST 6.4.2.4-2, CLASS=DEVIANCE}

{ This program tests to see if real constants are permitted
  in a subrange declaration. The Pascal Standard states that
  a subrange definition must be of a subrange of another ordinal
  type. This rules out real constants in the definition. }

program t6p4p2p4d2(output);
type
   wiregauge = 0.001..0.2;
begin
   writeln(' DEVIATES...6.4.2.4-2')
end.
{TEST 6.4.2.4-3, CLASS=DEVIANCE}

{ The Pascal Standard states that the first constant in a definition
  specifies the lower bound, which is less than or equal to the
  upper bound.
  This program tests the compilers' conformance to this point.
  The compiler conforms if both the cases are rejected. }

program t6p4p2p4d3(output);
type
   mixedup = 100..0;
   reverse = 'Z'..'A';
begin
   writeln(' DEVIATES...6.4.2.4-3 : EMPTY SUBRANGES ALLOWED')
end.
{TEST 6.4.3.1-1, CLASS=DEVIANCE}

{ The Pascal Standard states that only structured types may be
  PACKED (array, set, file and record types).
  This program tests this point. The compiler conforms if
  the program will not compile. }

program t6p4p3p1d1(output);
type
   switch = packed(on,off);
   state  = packed(high,low,invalid);
   decade   = packed 0..10;
begin
   writeln(' DEVIATES...6.4.3.1-1 : IMPROPER USE OF PACKED')
end.
{TEST 6.4.3.1-2, CLASS=DEVIANCE}

{ The Pascal Standard states that a structured type identifier
  may not be used in a PACKED type definition.
  The compiler passes if the program fails to compile. }

program t6p4p3p1d2(output);
type
   complex = record
	       realpart : real;
	       imagpart : real;
	     end;
   packcom = packed complex;
begin
   writeln(' DEVIATES...6.4.3.1-2 : IMPROPER USE OF PACKED')
end.
{TEST 6.4.3.1-3, CLASS=CONFORMANCE}

{ The Pascal Standard allows array, set, file and
  record types to be declared as PACKED.
  The program simply tests that all these are
  permitted.
  The compiler fails if the program will not compile. }

program t6p4p3p1d3(output);
type
   urray    = packed array[1..10] of char;
   rekord   = packed record
		  bookcode : integer;
		  authorcode : integer;
	      end;
   fyle     = packed file of urray;
   card     = (heart,diamond,spade,club);
   sett     = packed set of card;
begin
   writeln(' PASS...6.4.3.1-3')
end.
{TEST 6.4.3.2-1, CLASS=CONFORMANCE}

{ This program tests all the valid productions for an
  array declaration from the syntax specified by the
  Pascal Standard.
  The compiler fails if one or more cases are rejected. }

program t6p4p3p2d1(output);
type
   cards       = (two,three,four,five,six,seven,eight,nine,ten,jack,
		  queen,king,ace);
   suit        = (heart,diamond,spade,club);
   hand        = array[cards] of suit;
   picturecards= array[jack..king] of suit;
   played      = array[cards] of array[heart..diamond] of boolean;
   playedtoo   = array[cards,heart..diamond] of boolean;
begin
   writeln(' PASS...6.4.3.2-1')
end.
{TEST 6.4.3.2-2, CLASS=DEVIANCE}

{ The Pascal Standard states that an index-type must be an
  ordinal-type. This does not include REAL.
  This program tests if the compiler will allow real bounds. }

program t6p4p3p2d2(output);
type
   reeltest = array[1.5..10.1] of real;
begin
   writeln(' DEVIATES...6.4.3.2-2')
end.
{TEST 6.4.3.2-3, CLASS=CONFORMANCE}

{ An index type may be an ordinal type, This allows
  the use of BOOLEAN, INTEGER and some userdefined type
  names to be used as an index type.
  This program tests if the compiler will permit these
  except for INTEGER, which is included in a separate program. }

program t6p4p3p2d3(output);
type
   digits   = '0'..'9';
   colour   = (red,pink,orange,yellow);
   intensity   = (bright,dull);
var
   alltoo   : array[boolean] of boolean;
   numeric  : array[digits] of integer;
   colours  : array[colour] of intensity;
   code     : array[char] of digits;
begin
   numeric['0']:=0;
   colours[pink]:=bright;
   alltoo[true]:=false;
   code['A']:='0';
   writeln(' PASS...6.4.3.2-3')
end.
{TEST 6.4.3.2-4, CLASS=QUALITY}

{ As mentioned in 6.4.3.2-3, an index type is an ordinal type,
  thus INTEGER may appear as an index type. However on most
  machines this would represent an unusually large array, and
  thus may not be allowed by the compiler.
  This program tests if such a declaration is permitted, and if
  not, is the diagnostic appropriate. }

program t6p4p3p2d4(output);
type
   everything = array[integer] of integer;
var
   all	 : everything;
begin
   all[maxint]:=1;
   all[0]:=1;
   all[-maxint]:=1;
   writeln(' QUALITY...6.4.3.2-4: -->INTEGER BOUNDS PERMITTED')
end.
{TEST 6.4.3.2-5, CLASS=DEVIANCE}

{ Strings must have a subrange of integers as an index type.
  The compiler deviates if this program compiles and
  prints DEVIATES. }

program t6p4p3p2d5(output);
type
   colour = (red,blue,yellow,green);
   cl1 = blue..green;
var
   s:packed array[cl1] of char;
begin
   s:='ABC';
   writeln(' DEVIATES...6.4.3.2-5, INDEX TYPE')
end.
{TEST 6.4.3.3-1, CLASS=CONFORMANCE}

{ This program simply tests that all valid productions from
  the syntax for record types (as specified by the Pascal Standard)
  are accepted by this compiler.
  The compiler fails if one or more cases are rejected. }

program t6p4p3p3d1(output);
type
   string   = packed array[1..25] of char;
   married  = (false,true);
   shape    = (triangle,rectangle,square,circle);
   angle    = 0..90;
   a	    = record
	       year : integer;
	       month : 1..12;
	       day : 1..31
	      end;
   b	    = record
	       name,firstname : string;
	       age : 0..99;
	       case  married of
		  true: (spousename : string);
		  false : ()
	      end;
   c	    = record
	       case s : shape of
		  triangle : (side : real;
			      inclination,angle1,angle2 : angle);
		  square,rectangle : (side1,side2 : real;
				      skew,angle3 : angle);
		  circle : (diameter : real)
	      end;
   d	    = record ; end;
   e	    = record
		case married of
		  true : (spousename : string);
		  false : ();
		end;
begin
   writeln(' PASS...6.4.3.3-1')
end.
{TEST 6.4.3.3-2, CLASS=CONFORMANCE}

{ The Pascal Standard states that the occurrence of a field
  identifier within the identifier list of a record section is
  its defining occurence as a field identifier for the record
  type in which the record section occurs.
  This should allow redefinition of a field identifier in another
  type declaration.
  The compiler fails if the program does not compile. }

program t6p4p3p3d2(output);
type
   a	 = record
	    realpart : real;
	    imagpart : real
	   end;
   realpart = (notimaginary,withbody,withsubstance);
begin
   writeln(' PASS...6.4.3.3-2')
end.
{TEST 6.4.3.3-3, CLASS=CONFORMANCE}

{ The Pascal Standard permits the declaration of an empty record,
  this empty record serves little purpose, and for this reason
  some compilers will not allow it to be used.
  The compiler fails if the program does not compile. }

program t6p4p3p3d3(output);
type
   statuskind  = (defined,undefined);
   emptykind   = record end;
var
   empty : emptykind;
   number: record
	    case status:statuskind of
	       defined	: (i : integer);
	       undefined: (e : emptykind)
	    end;
begin
   with number do
   begin
      status:=defined;
      i:=7
   end;
   writeln(' PASS...6.4.3.3-3')
end.
{TEST 6.4.3.3-4, CLASS=CONFORMANCE}

{ Similarly to 6.4.3.3-2, a tag-field may be redefined
  elsewhere in the declaration part.
  The compiler fails if the program will not compile. }

program t6p4p3p3d4(output);
type
   which = (white,black,warlock,sand);
var
   polex : record
	     case which:boolean of
	       true: (realpart:real;
		      imagpart:real);
	       false:(theta:real;
		      magnit:real)
	    end;
begin
   polex.which:=true;
   polex.realpart:=0.5;
   polex.imagpart:=0.8;
   writeln(' PASS...6.4.3.3-4')
end.
{TEST 6.4.3.3-5, CLASS=ERRORHANDLING}

{ The Pascal Standard states that if a change of variant occurs
  (by assigning a value associated with a  variant to the
  tag-field), then the fields associated with the previous variants
  cease to exist. This program causes the error to occur. }

program t6p4p3p3d5(output);
type
   two = (a,b);
var
   variant : record
	       case tagfield:two of
		  a: (m:integer);
		  b: (n:integer);
	     end;
   i : integer;
begin
   variant.tagfield:=a;
   variant.m:=1;
   i:=variant.n;     {illegal}
   writeln(' ERROR NOT DETECTED...6.4.3.3-5')
end.
{TEST 6.4.3.3-6, CLASS=ERRORHANDLING}

{ The program causes an error by accessing a field with
  an undefined value. The undefinition arises because
  when a change of variant occurs, those fields associated with
  the new variant come into existence with undefined
  values. }

program t6p4p3p3d6(output);
type
   two = (a,b);
var
   variant : record
	       case tagfield:two of
		  a : (m : integer;
		       l : integer);
		  b : (n : integer;
		       o : integer)
	     end;
   i : integer;
begin
   variant.tagfield:=a;
   variant.m:=1;
   variant.l:=1;
   variant.tagfield:=b;
   variant.n:=1;
   i:=variant.o;     { illegal }
   writeln(' ERROR NOT DETECTED...6.4.3.3-6')
end.
{TEST 6.4.3.3-7, CLASS=ERRORHANDLING}

{ This test is similar to 6.4.3.3-5, except that no tagfield is
  used.
  Variant changes occur implicitly as a result of
  assignment to fields. The fields associated with the new
  variant come into existence with undefined values. }

program t6p4p3p3d7(output);
type
   two = (a,b);
var
   variant : record
	       case two of
		  a : (m : integer);
		  b : (n : integer);
	     end;
   i : integer;
begin
   variant.m:=2;
   i:=variant.n;     { illegal }
   writeln(' ERROR NOT DETECTED...6.4.3.3-7')
end.
{TEST 6.4.3.3-8, CLASS=ERRORHANDLING}

{ Similar to 6.4.3.3-5, except that no tag-field is used.
  A change of variant occurs by reference to a field associated
  with a new variant. Again, these fields come into existance
  undefined.
  The compiler conforms if the program does not compile. }

program t6p4p3p3d8(output);
type
   two = (a,b);
var
   variant : record
	       case two of
		  a:(m:integer;
		     l:integer);
		  b:(n:integer;
		     o:integer)
	     end;
   i : integer;
begin
   variant.n:=1;
   variant.o:=1;
   variant.m:=1;
   i:=variant.l;     {illegal}
   writeln(' ERROR NOT DETECTED...6.4.3.3-8')
end.
{TEST 6.4.3.3-9, CLASS=QUALITY}

{ Note this program relies on the compiler deviating for tests
  6.4.3.3-5 to 6.4.3.3-8.
  If the compiler conforms for these tests, this program will
  not compile/run.
  The method of storage for fields of variants may differ,
  depending on the method of definition.
  Programmers should not rely on the VALUES of fields under
  one variant still being accessible from another. However, the
  relationships between the two variants in this example may be
  determined by the output of the program. }

program t6p4p3p3d9(output);
type
   two = (a,b);
var
   variant : record
	       case tagfield : two of
		  a: (i,j,k : integer);
		  b: (l : integer;
		      m : integer;
		      n : integer)
	     end;
begin
   variant.tagfield:=a;
   variant.i:=1;
   variant.j:=2;
   variant.k:=3;
   variant.tagfield:=b;
   if (variant.l=1) and (variant.m=2) then
      writeln(' EXACT CORRELATION-- I:L  J:M  K:N')
   else
   if (variant.l=3) and (variant.m=2) then
      writeln(' REVERSE CORRELATION -- I:N  J:M  K:L')
   else
      writeln(' UNKNOWN CORRELATION - lmn are:',
	       variant.l,variant.m,variant.n)
end.
{TEST 6.4.3.3-10, CLASS=CONFORMANCE}

{ The Pascal Standard states that case constants must be distinct,
  and are of an ordinal type which is compatible with the
  tag-field.
  This program tests to see if the compiler will permit case
  constants outside the tag-field subrange - it should .
  The compiler passes if the program runs.
  A warning might be appropriate, however, as fields outside the
  tagfield subrange are not accessible. }

program t6p4p3p3d10(output);
type
   a = 0..3;
   b = record
	 case c:a of
	    0: (d:array[1..2] of boolean);
	    1: (e:array[1..3] of boolean);
	    2: (f:array[1..4] of boolean);
	    3: (g:array[1..5] of boolean);
	    4: (h:array[1..6] of boolean)
       end;
begin
   writeln(' PASS...6.4.3.3-10')
end.
{TEST 6.4.3.3-11, CLASS=DEVIANCE}

{ This program is similar to 6.4.3.3-3, except here, the
  empty record is assigned a value. This should not be possible.
  The program conforms if the program does not compile or run. }

program t6p4p3p3d11(output);
type
   statuskind  = (defined,undefined);
   emptykind   = record end;
var
   empty : emptykind;
   number: record
	    case status:statuskind of
	       defined	: (i : integer);
	       undefined: (e : emptykind)
	    end;
begin
   with number do
   begin
      status:=undefined;
      e:=666
   end;
   writeln(' PASS...6.4.3.3-11')
end.
{TEST 6.4.3.3-12, CLASS=ERRORHANDLING}

{ This program is similar to 6.4.3.3-3, except here
  an error is caused by assigning the undefined value
  of the variable empty to the field e.
  This error should be detected. }

program t6p4p3p3d12(output);
type
   statuskind  = (defined,undefined);
   emptykind   = record end;
var
   empty : emptykind;
   number: record
	    case status:statuskind of
	       defined	: (i : integer);
	       undefined: (e : emptykind)
	    end;
begin
   with number do
   begin
      status:=undefined;
      e:=empty	     { undefined despite being empty }
   end;
   writeln(' PASS...6.4.3.3-12')
end.
{TEST 6.4.3.3-13, CLASS=CONFORMANCE}

{ This test checks that nested variants are allowed
  with the appropriate syntax. The compiler fails if the
  program does not compile and print PASS. }

program t6p4p3p3d13(output);
type
   a=record
       case b:boolean of
       true: (c:char);
       false: (case d:boolean of
	       true: (e:char);
	       false: (f:integer))
      end;
var
   g:a;
begin
   g.b:=false;
   g.d:=false;
   g.f:=1;
   writeln(' PASS...6.4.3.3-13, VARIANTS')
end.
{TEST 6.4.3.4-1, CLASS=CONFORMANCE}

{ This program simply tests that set types as described in the
  Pascal Standard are permitted.
  The compiler fails if the program will not compile. }

program t6p4p3p4d1(output);
type
   colour   = (red,blue,pink,green,yellow);
   setone   = set of colour;
   settwo   = set of blue..green;
   setthree = set of boolean;
   setfour  = set of 1..10;
   setfive  = set of 0..3;
   setsix   = set of (heart,diamond,spade,club);
begin
   writeln(' PASS...6.4.3.4-1')
end.
{TEST 6.4.3.4-2, CLASS=IMPLEMENTATIONDEFINED}

{ This program tests if a set of char is permitted by the
  compiler. }

program t6p4p3p4d2(output);
var
   s : set of char;
begin
   s:=[';',' ','9','z'];
   if ([';',' ','9','z'] <= s) then
      writeln(' IMPLEMENTATION ALLOWS SET OF CHAR')
   else
      writeln(' IMPLEMENTATION DOES NOT ALLOW SET OF CHAR')
end.
{TEST 6.4.3.4-3, CLASS=DEVIANCE}

{ The Pascal Standard states that the base-type of the range
  of a set must be an ordinal-type. This should eliminate sets with
  real and structured ranges. Some compilers may allow these and
  hence will deviate for those cases not flagged as errors. }

program t6p4p3p4d3(output);
type
   legalset = set of 1..3;
   urray    = array[1..4] of integer;
   setone   = set of real;		    { case 1 }
   settwo   = set of record a : 0..3 end;   { case 2 }
   setthree = set of array[1..5] of real;   { case 3 }
   setfour  = set of urray;		    { case 4 }
   setfive  = set of legalset;		    { case 5 }
   setsix   = set of set of 1..4;	    { case 6 }
begin
   writeln(' DEVIATES...6.4.3.4-3')
end.
{TEST 6.4.3.4-4, CLASS=IMPLEMENTATIONDEFINED}

{ The Pascal Standard states that the largest and smallest values
  permitted in the base-type of a set-type are implementation
  defined.
  The size of the base-type permitted may be determined by
  examining which of the cases below are accepted by the compiler. }

program t6p4p3p4d4(output);
type
   setone   = set of -1..+1;
   settwo   = set of char;
   setthree = set of 0..1000;
   setfour  = set of 0..10;
   setfive  = set of 0..20;
   setsix   = set of 0..30;
   setseven = set of 0..40;
   seteight = set of 0..50;
   setnine  = set of 0..60;
   setten   = set of 0..70;
var
   s : setthree;
begin
   s:=[1000];
   writeln(' IMPLEMENTATIONDEFINED...6.4.3.4-4 -->',
	    'GOOD IMPLEMENTATION OF SETS')
end.
{TEST 6.4.3.4-5, CLASS=QUALITY}

{ This test is an implementation of Warshall's algorithm
  in Pascal. It serves to give a program which can be used both
  to time a simple procedure using sets, and which can measure
  the space requirements. In both cases the measurements of the
  procedure Warshall are to be compared.

  By way of comparison, the Tasmanian compiler on the Burroughs
  B6700 yielded
      space = 143 bytes ( 6864 bits)
      time = 0.816461 seconds
   }
program t6p4p3p4d5(output);
const
   size = 79;	{array is (size+1) by (size+1) square}
   words = 4;	{size div 16}
   bitsperword = 16;   {assume everyone allows this}
   bitsminus1 = 15;   {bitsperword-1}
type
   btype = array [0..size] of array [0..words]
	 of set of 0..bitsminus1;
var
   seed:integer;
   t1,t2:real;
   original,closure:btype;

function generate:integer;
begin
   seed:=57*seed+1;
   generate := (seed mod (size+1));
   seed:=seed mod 571
end;   {of generate}

procedure fill(var a:btype; p:integer);
var
   i:0..size;
   j:0..bitsminus1;
   k,l:0..maxint;
begin
   for j:=0 to words do a[0][j]:=[];
   for i:=1 to size do a[i]:=a[0];
   for k:=1 to p do begin
      i:=generate;
      l:=generate;
      j:=l div bitsperword;
      a[i][j] := a[i][j]+[(l mod bitsperword)]
   end
end;   {of fill}

procedure print(var b:btype);
var
   i,j:0..size;
begin
   for i:=0 to size do begin
      write(' ');
      for j:=0 to size do begin
	 if (j mod bitsperword) in b[i][j div bitsperword] then
	    write('+')
	 else
	    write('-')
      end;
      writeln
   end
end;   {of print}

procedure warshallsalgorithm(var a,b:btype);
   {examine the code to see how many bytes of 8-bits are required}
var
   i,j:0..size;
   k:0..words;
begin
   b:=a;
   for i:=0 to size do
      for j:=0 to size do
	 if (i mod bitsperword) in b[j][i div bitsperword] then
	    for k:=0 to words do
	       b[j][k] := b[j][k]+b[i][k];
end;   {of warshallsalgorithm}

begin	 {of main program}
   seed:=1;
   fill(original,125);
   t1:=processtime;   {ie begin timing however you do it}
   warshallsalgorithm(original,closure);
   t2:=processtime;   {ie stop timing}
   writeln(' TIME=',t2-t1);
   writeln(' ORIGINAL MATRIX');
   print(original);
   writeln(' TRANSITIVE CLOSURE');
   print(closure)
end.
{TEST 6.4.3.5-1, CLASS=CONFORMANCE}

{ A file-type is a structured type consisting of a sequence of
  components which are all one type. All cases in this program
  should pass.
  The compiler fails if one or more cases are rejected. }

program t6p4p3p5d1(output);
type
   i = integer;
var
   ptrtoi: ^i;
   file1 : file of char;
   file2 : file of real;
   file3 : file of
	    record
	       a : integer;
	       b : boolean
	    end;
   file4 : file of set of (red,blue,green,purple);
   file5 : file of ptrtoi;
begin
   writeln(' PASS...6.4.3.5-1')
end.
{TEST 6.4.3.5-2, CLASS=CONFORMANCE}

{ The Pascal Standard provides for a predefined filetype, type
  TEXT. Variables of type TEXT are called TEXT FILES. This program
  tests that such a type is permitted and that the type adheres
  to the structure laid down in the Standard. The compiler fails
  if the program will not compile and run. }

program t6p4p3p5d2(output);
var
  file1 : text;
  chare : char;
procedure ahaa;
begin
   writeln(' FAIL...6.4.3.5-2')
end;

begin
   rewrite(file1);
   writeln(file1);		    { no characters, but a linemarker}
   writeln(file1,'ABC');	    { characters and linemarker}
   reset(file1);
   if eoln(file1) then get(file1)
   else ahaa;
   if file1^='A' then get(file1)
   else ahaa;
   if file1^='B' then get(file1)
   else ahaa;
   if file1^='C' then get(file1)
   else ahaa;
   if eoln(file1) and (file1^=' ') then get(file1)
   else ahaa;
   if eof(file1) then
      writeln(' PASS...6.4.3.5-2')
   else ahaa
end.
{TEST 6.4.3.5-3, CLASS=CONFORMANCE}

{ This program tests if an end of line marker is inserted at the
  end of the line, if not explicitly done in the program.
  The structure of a text file requires a closing linemarker.
  Conforming compilers will either insert the linemarker, or
  report a run-time error. }

program t6p4p3p5d3(output);
var
   file1 : text;
   chare : char;
begin
   rewrite(file1);
   write(file1,'A');
   reset(file1);
   get(file1);
   if eoln(file1) then writeln(' PASS...6.4.3.5-3')
		  else writeln(' FAIL...6.4.3.5-3')
end.
{TEST 6.4.3.5-4, CLASS=CONFORMANCE}

{ This program tests if an end-of-line marker is inserted at
  the end of the line on the predefined file output, if
  not explicitly done in the program (i.e. is the buffer
  flushed). See also test 6.4.3.5-3. }

program t6p4p3p5d4(output);
begin
   write(' PASS...6.4.3.5-4')
end.
{TEST 6.4.4-1, CLASS=CONFORMANCE}

{ This program simply tests that pointer types as described in the
  Pascal Standard are permitted. }

program t6p4p4d1(output);
type
   sett     = set of 1..2;
   urray    = array[1..3] of integer;
   rekord   = record
	       a : integer;
	       b : boolean
	      end;
   ptr9     = ^sett;
   pureptr  = ^pureptr;
var
   ptr1  : ^integer;
   ptr2  : ^real;
   ptr3  : ^boolean;
   ptr4  : ^sett;
   ptr5  : ^urray;
   ptr6  : ^rekord;
   ptr7  : pureptr;
   ptr8  : ptr9;
begin
   new(ptr1);
   new(ptr2);
   new(ptr3);
   new(ptr4);
   new(ptr5);
   new(ptr6);
   new(ptr7);
   new(ptr8);
   writeln(' PASS...6.4.4-1')
end.
{TEST 6.4.4-2, CLASS=DEVIANCE}

{ This program tests the diagnostic that should be produced by
  the compiler if the type to which a pointer points is not
  found. }

program t6p4p4d2(output);
var
   pointer1 : ^real;
   pointer2 : ^rekord;
begin
   new(pointer1);
   pointer1:=nil;
   new(pointer2);
   pointer2:=nil;
   writeln(' DEVIATES...6.4.4-2')
end.
{TEST 6.4.4-3, CLASS=DEVIANCE}

{ Pointers to items in the stack are not allowed.
  The ^ symbol is not permitted to act as an operator
  giving the reference to a variable. The compiler deviates
  if the program compiler and prints DEVIATES. }

program t6p4p4d3(output);
var
   p: ^integer;
   x:integer;
begin
   x:=10;
   p:=^x;
   writeln(' DEVIATES...6.4.4-3, POINTER')
end.
{TEST 6.4.5-1, CLASS=CONFORMANCE}

{ The Pascal Standard states that types designated at two or more
  different places in the program text are identical if the same
  type identifier is used at these places, or if different identifiers
  are used which have been defined to be equivalent to each other.
  This program simply tests that the compiler conforms to the
  Standard's  description of identity.
  The compiler fails if the program does not compile. }

program t6p4p5d1(output);
type
   t1 = array[1..5] of boolean;
   t2 = t1;
   t3 = t2;
var
   a : t1;
   b : t2;
   c : t3;
procedure identical(var a : t1; var b : t2; var c : t3);
begin
   a[1]:=true;
   b[1]:=false;
   c[1]:=true
end;

begin
   a[1]:=true;
   b[1]:=false;
   c[1]:=false;
   identical(a,b,c);
   identical(c,a,b);
   identical(b,c,a);
   writeln(' PASS...6.4.5-1')
end.
{TEST 6.4.5-2, CLASS=DEVIANCE}

{ This program simply tests that the compiler does not deviate
  from the Standard in the case of subranges of the same host
  being treated as identical.
  The program should fail to compile/execute if the compiler
  conforms. }

program t6p4p5d2(output);
type
   colour = (red,pink,orange,yellow,green,blue);
   subone = red..yellow;
   subtwo = pink..blue;
var
   colour1 : subone;
   colour2 : subtwo;

procedure test(var col1 : subone);
begin
   writeln(' DEVIATES...6.4.5-2')
end;

begin
   { Although colour1 and colour2 are compatible (i.e. subone and
     subtwo are compatible), they are not identical, and the call
     to TEST should fail. }
   colour2:=pink;
   test(colour2)
end.
{TEST 6.4.5-3, CLASS=DEVIANCE}

{ This test is similar to 6.4.5-2, except that deviance in the
  case of arrays is tested.
  The program should not compile/execute if the compiler
  conforms. }

program t6p4p5d3(output);
type
   urrayone = array[1..10] of char;
   urraytwo = array[1..10] of char;
var
   arrayone : urrayone;
   arraytwo : urraytwo;

procedure test(var urray : urrayone);
begin
   writeln(' DEVIATES...6.4.5-3')
end;

begin
   { The two arraytypes, urrayone and urraytwo, are not identical
     and hence the call to TEST should fail. }
   test(arraytwo)
end.
{TEST 6.4.5-4, CLASS=DEVIANCE}

{ This program is similar to 6.4.5-3, except that deviance in the
  case of records is tested.
  The program should fail to compile/execute if the compiler
  conforms. }

program t6p4p5d4(output);
type
   recone = record
	       a : integer;
	       b : boolean
	    end;
   rectwo = record
	       c : integer;
	       d : boolean
	    end;
var
   recordone : recone;
   recordtwo : rectwo;

procedure test(var rec : recone);
begin
   writeln(' DEVIATES...6.4.5-4')
end;

begin
   { Although the two record types are compatible, they
     are not identical, and hence the call to TEST
     should fail. }
   recordtwo.c:=0;
   recordtwo.d:=true;
   test(recordtwo)
end.
{TEST 6.4.5-5, CLASS=DEVIANCE}

{ Again, this test is similar to 6.4.5-4, except that deviance
  for pointers is tested.
  Although the two pointers in this example point to the same
  type, they are not identical.
  The compiler conforms if the program does not compile/execute. }

program t6p4p5d5(output);
type
   rekord = record
	       a : integer;
	    end;
   ptrone = ^rekord;
   ptrtwo = ^rekord;
var
   ptrtorec    : ptrone;
   ptrtorectoo : ptrtwo;

procedure test(var ptr : ptrone);
begin
   writeln(' DEVIATES...6.4.5-5')
end;

begin
   new(ptrtorectoo);
   ptrtorectoo:=nil;
   test(ptrtorectoo)
end.
{TEST 6.4.5-6, CLASS=CONFORMANCE}

{ Two types are compatible if they are identical or if one is a
  subrange of the other, or if both are subranges of the same type.
  This program tests these points, but with only subranges of the
  same type having some overlap.
  If the message produced is incomplete, or the program does not
  compile, then the compiler fails.}

program t6p4p5d6(output);
type
   colour   = (red,pink,orange,yellow,green,blue,brown);
   colourtoo= colour;
var
   col1  : colour;
   col2  : colourtoo;
   subcol1  : red..yellow;
   subcol2  : orange..blue;
begin
   col1:=red;
   col2:=red;
   if col1 = col2 then write(' PA');
   subcol1:=red;
   if col1 = subcol1 then write('S');
   subcol1:=yellow;
   subcol2:=yellow;
   if subcol1 = subcol2 then writeln('S...6.4.5-6')
end.
{TEST 6.4.5-7, CLASS=CONFORMANCE}

{ This program tests that two subranges of the same type with
  no overlap are considered as compatible by the compiler.
  The compiler fails if the program does not compile. }

program t6p4p5d7(output);
type
   color = (red,pink,orange,yellow,green,blue,brown);
var
   col1 : red..yellow;
   col2 : green..brown;
begin
   col1:=yellow;
   col2:=green;
   if col1 < col2 then writeln(' PASS...6.4.5-7')
		  else writeln(' FAIL...6.4.5-7')
end.
{TEST 6.4.5-8, CLASS=CONFORMANCE}

{ The Pascal Standard states that string types with the same
  number of components are compatible.
  The compiler fails if the program does not compile. }

program t6p4p5d8(output);
var
   string1 : packed array[1..4] of char;
   string2 : packed array[1..4] of char;
begin
   string1:='ABCD';
   string2:='EFGH';
   if 'ABC' = 'ABC' then
      if string1 <> string2 then
	 writeln(' PASS...6.4.5-8')
      else
	 writeln(' FAIL...6.4.5-8')
   else
      writeln(' FAIL...6.4.5-8')
end.
{TEST 6.4.5-9, CLASS=CONFORMANCE}

{ The Pascal Standard states that set types of compatible base-types
  are compatible. This program tests that this is so for this
  compiler.
  The compiler fails if the program does not compile. }

program t6p4p5d9(output);
type
   colour = (red,pink,orange,yellow,green,blue,brown);
var
   set1 : set of red..orange;
   set2 : set of orange..brown;
begin
   set1:=[orange];
   set2:=[orange];
   if set1=set2 then writeln(' PASS...6.4.5-9')
		else writeln(' FAIL...6.4.5-9')
end.
{TEST 6.4.5-10, CLASS=DEVIANCE}

{ Some implementations may have an implicit ordering
  between different types, and allow these to be compared etc.,
  thus not conforming to the compatibility rules of the Pascal
  Standard.
  The compiler conforms if the program does not compile, or
  fails to run. }

program t6p4p5d10(output);
var
   colour : (red,green,blue);
begin
   if red < 0 then writeln(' DEVIATES...6.4.5-10')
	      else writeln(' DEVIATES...6.4.5-10')
end.
{TEST 6.4.5-11, CLASS=DEVIANCE}

{ The Pascal Standard permits compatibility only between string
  types of the same number of components.
  Some compilers may allow compatibility between string types
  with different numbers of components. (see 6.1.7-4 and 6.....)
  The compiler conforms if the program does not compile. }

program t6p4p5d11(output);
begin
   if 'CAT' < 'HOUND' then writeln(' DEVIATES...6.4.5-11')
end.
{TEST 6.4.5-12, CLASS=CONFORMANCE}

{ If two types are declared equivalent, they inherit all properties
  in common, including operators and special attributes. This
  is clecked by an analogue of type boolean. The compiler passes
  if the program compiles and prints PASS. }

program t6p4p5d12(output);
const
   on=true;
   off=false;
type
   logical=boolean;
var
   test:integer;
   b1,b2:boolean;
   l1,l2:logical;
begin
   test:=0;
   b1:=true;   b2:=off;
   l1:=true;   l2:=off;
   if l2 then test:=test+1;
   l2:=b2;
   if b1=b2 then test:=test+1;
   b2:=l2;
   if b2 or l2 then test:=test+1;
   if test=0 then
      writeln(' PASS...6.4.5-12, TYPES')
   else
    writeln(' FAIL...6.4.5-12, TYPES')
end.
{TEST 6.4.5-13, CLASS=DEVIANCE}

{ This test is similar to 6.4.5-2, except that deviance in the
  case of arrays is tested.
  The program should not compile/execute if the compiler
  conforms. }

program t6p4p5d13(output);
type
   urrayone = array[1..10] of boolean;
   urraytwo = array[1..10] of boolean;
var
   arrayone : urrayone;
   arraytwo : urraytwo;

procedure test(var urray : urrayone);
begin
   writeln(' DEVIATES...6.4.5-13')
end;

begin
   { The two arraytypes, urrayone and urraytwo, are not identical
     and hence the call to TEST should fail. }
   test(arraytwo)
end.
{TEST 6.4.6-1, CLASS=CONFORMANCE}

{ This program tests that all assignment compatible types as
  described by the Pascal Standard, are permitted by this compiler.
  This program tests only those uses in assignment statements.
  All cases have been tested elsewhere, but are included here
  together for consistency.
  The compiler fails if one or more of the cases below
  are rejected. }

program t6p4p6d1(output);
type
   colour = (red,pink,yellow);
   rekord = record
	       a : integer;
	       b : boolean
	    end;
var
   i	 : integer;
   j	 : real;
   col1  : colour;
   col2  : pink..yellow;
   col3  : set of colour;
   col4  : set of red..pink;
   urray1   : array[1..6] of integer;
   urray2   : array[1..4] of integer;
   record1  : rekord;
   record2  : rekord;
begin
   i:=2;
   j:=i;
   col1:=yellow;
   col2:=col1;
   col3:=[pink];
   col4:=col3;
   urray2[1]:=0;
   urray1[6]:=urray2[1];
   record1.a:=2;
   record1.b:=true;
   record2:=record1;
   writeln(' PASS...6.4.6-1')
end.
{TEST 6.4.6-2, CLASS=CONFORMANCE}

{ This test is similar to 6.4.6-1, except that it tests the use
  of assignment compatibility in actual and formal parameters.
  The compiler fails if the program does not compile. }

program t6p4p6d2(output);
type
   colour = (red,pink,yellow,green);
   subcol1 = yellow..green;
   subcol2 = set of colour;
   subcol3 = set of pink..green;
var
   a	    : integer;
   b	    : real;
   colour1  : colour;
   colour2  : pink..green;
   colour3  : set of colour;
   colour4  : set of yellow..green;

procedure compat(i : integer; j : real;
		 col1 : colour; col2 : subcol1;
		 col3 : subcol2; col4 : subcol3);
begin
end;

begin
   compat(2,2.4,yellow,yellow,[pink],[pink]);
   a:=2;
   b:=3.1;
   colour1:=pink;
   colour2:=green;
   colour3:=[yellow];
   colour4:=[yellow];
   compat(a,b,colour1,colour2,colour3,colour4);
   compat(a,a,colour2,colour2,colour4,colour4);
   writeln(' PASS...6.4.6-2')
end.
{TEST 6.4.6-3, CLASS=CONFORMANCE}

{ This program tests a part of 6.5.2.1, that states that an index
  expression is assignment compatible with the index type
  specified in the definition of the array type.
  The compiler fails if the program does not compile. }

program t6p4p6d3(output);
type
   colour = (red,pink,orange,yellow,green);
   intensity = (bright,dull);
var
   array1 : array[yellow..green] of boolean;
   array2 : array[colour] of intensity;
   array3 : array[1..99] of integer;
   colour1 : red..yellow;
   i	  : integer;
begin
   array1[yellow]:=true;
   colour1:=yellow;
   array1[colour1]:=false;
   array2[colour1]:=bright;
   array3[1]:=0;
   i:=2;
   array3[i*3+2]:=1;
   writeln(' PASS...6.4.6-3')
end.
{TEST 6.4.6-4, CLASS=ERRORHANDLING}

{ The Pascal standard says that if the two types in an assignment
  compatibility test (T1 and T2) are compatible ordinal types
  and the value of the expression E which is of type T2 is not in
  the closed interval specified by the type T1, an error occurs.
  Does this compiler detect this. }

program t6p4p6d4(output);
type
   subrange = 0..5;
var
   i : subrange;
begin
   i:=5;
   i:=i*2;    { error }
   writeln(' ERROR NOT DETECTED...6.4.6-4')
end.
{TEST 6.4.6-5, CLASS=ERRORHANDLING}

{ This program is similar to 6.4.6-4, except that parameter
  assignment compatibility is tested.
  The program causes an error to occur which should be detected. }

program t6p4p6d5(output);
type
   subrange = 0..5;
var
   i : subrange;
procedure test(a : subrange);
begin
   a:=5
end;

begin
   i:=5;
   test(i*2);	   { error }
   writeln(' ERROR NOT DETECTED...6.4.6-5')
end.
{TEST 6.4.6-6, CLASS=ERRORHANDLING}

{ This program is similar to 6.4.6-4, except that array
  subscript assignment compatibility is tested.
  The program causes an error, which should be detected. }

program t6p4p6d6(output);
type
   colour = (red,pink,orange,yellow,green);
var
   v	 : colour;
   urray : array[red..orange] of boolean;
begin
   v:=orange;
   urray[succ(v)]:=true;      { error }
   writeln(' ERROR NOT DETECTED...6.4.6-6')
end.
{TEST 6.4.6-7, CLASS=ERRORHANDLING}

{ Similarly for 6.4.6-4, if two types are compatible set types,
  and any of the members of the set expression E (of type T2)
  is not in the closed interval specified by the base-type of the
  type T1, an error occurs.
  Again, does the compiler detect this. }

program t6p4p6d7(output);
type
   colour = (red,pink,orange,yellow,green,blue);
   subone = red..orange;
   subtwo = pink..yellow;
var
   setone : set of subone;
   settwo : set of subtwo;
begin
   settwo:=[pink,yellow];
   setone:=settwo;		       { should be an error }
   writeln(' ERROR NOT DETECTED...6.4.6-7')
end.
{TEST 6.4.6-8, CLASS=ERRORHANDLING}

{ This test is similar to 6.4.6-7, except that assignment
  compatibility for sets passed as parameters is tested.
  The program causes an error which should be detected. }

program t6p4p6d8(output);
type
   colour   = (red,pink,orange,yellow,green,blue);
   subone   = red..green;
   settwo   = set of yellow..blue;
var
   setone : set of subone;
procedure test(a : settwo);
begin
end;

begin
   setone:=[red,pink,orange];
   test(setone);
   writeln(' ERROR NOT DETECTED...6.4.6-8')
end.
{TEST 6.4.6-9, CLASS=DEVIANCE}

{ The Pascal Standard allows assignment of integers to reals,
  but not reals to integers.
  Does this compiler allow assignment of reals to integers.
  If so, it does not conform to the Standard.
  The compiler conforms if the program does not compile. }

program t6p4p6d9(output);
var
   i : real;
   j : integer;
procedure test(a:integer);
begin
end;

begin
   i:=6.345;
   j:=i;
   test(6.345);
   writeln(' DEVIATES...6.4.6-9')
end.
{TEST 6.4.6-10, CLASS=DEVIANCE}

{ The Pascal Standard states that the two types T1 and T2
  (in determining assignment compatibility) must neither be a
  a file type nor a structured type with a file component.
  This program tests the first part of this statement.
  The compiler conforms if the program does not compile. }

program t6p4p6d10(output);
var
   file1 : text;
   file2 : text;
begin
   reset(file1);
   rewrite(file2);
   writeln(file1,'ABC');
   file2:=file1;
   writeln(' DEVIATES...6.4.6-10')
end.
{TEST 6.4.6-11, CLASS=DEVIANCE}

{ This program tests the latter half of the statement in
  6.4.6-10.
  The compiler conforms if the program does not compile. }

program t6p4p6d11(output);
type
   rekord = record
	       f : text;
	       a : integer
	    end;
var
   record1 : rekord;
   record2 : rekord;
begin
   record1.a:=1;
   reset(record1.f);
   rewrite(record2.f);
   writeln(record1.f);
   record2:=record1;;
   writeln(' DEVIATES...6.4.6-11')
end.
{TEST 6.4.6-12, CLASS=DEVIANCE}

{ The standard specifies that a filetype T2 cannot be
  assignment-compatible with an identical type T1, nor can a
  structure containing such a filetype. This precludes any
  assignments involving files. The compiler deviates if the program
  compiles and prints DEVIATES. }

program t6p4p6d12(output);
var
   f1,f2:text;
begin
   rewrite(f1);
   writeln(f1,' DEVIATES');
   writeln(' DEVIATES...6.4.6-12, FILES');
   f2:=f1;
end.
{TEST 6.5.1-1, CLASS=CONFORMANCE}

{ Here is included two examples from the Pascal Standard.
  The first is from section 6.4.7, and consists of legal type
  declarations. The second is from section 6.5.1, and consists
  of legal variable declarations.
  The compiler fails if the program does not compile. }

program t6p5p1d1(output);
type
   count    = integer;
   range    = integer;
   colour   = (red,yellow,green,blue);
   sex	    = (male,female);
   year     = 1900..1999;
   shape    = (triangle,rectangle,circle);
   card     = array[1..80] of char;
   str	    = file of char;
   angle    = real;
   polar    = record
		  r : real;
		  theta : angle
	      end;
   person   = ^ persondetails;
   persondetails = record
	    name, firstname : str;
	    age : integer;
	    married : boolean;
	    father,child,sibling : person;
	    case s:sex of
	       male   : (enlisted,bearded : boolean);
	       female : (pregnant : boolean)
	    end;
   tape     = file of persondetails;
   intfile  = file of integer;

var
   x,y,z    : real;
   i,j	    : integer;
   k	    : 0..9;
   p,q,r    : boolean;
   operator : (plus,minus,times);
   a	    : array[0..63] of real;
   c	    : colour;
   f	    : file of char;
   hue1,hue2 : set of colour;
   p1,p2    : person;
   m,m1,m2  : polar;
   pooltape : array[1..4] of tape;
begin
   writeln(' PASS...6.5.1-1')
end.
{TEST 6.5.1-2, CLASS=QUALITY}

{ This test checks that long declaration lists are allowed by
  the compiler. The test may detect a small compiler limit . }

program t6p5p1d2(output);
var
   i0,i1,i2,i3,i4,i5,i6,i7,i8,i9,
   i10,i11,i12,i13,i14,i15,i16,i17,i18,i19,
   i20,i21,i22,i23,i24,i25,i26,i27,i28,i29,
   i30,i31,i32,i33,i34,i35,i36,i37,i38,i39,
   i40,i41,i42,i43,i44,i45,i46,i47,i48,i49,
   i50,i51,i52,i53,i54,i55,i56,i57,i58,i59,
   i60,i61,i62,i63,i64,i65,i66,i67,i68,i69,
   i70,i71,i72,i73,i74,i75,i76,i77,i78,i79,
   i80,i81,i82,i83,i84,i85,i86,i87,i88,i89,
   i90,i91,i92,i93,i94,i95,i96,i97,i98,i99
   : integer;
begin
  i0:=0; i1 :=1; i2:=2; i3:=3; i4:=4; i5:=5; i6:=6; i7:=7;i8:=8; i9:=9;
  i10:=i0+1; i11:=i1+1; i12:=i2+1; i13:=i3+1; i14:=i4+1;
  i15:=i5+1; i16:=i6+1; i17:=i7+1; i18:=i8+1; i19:=i9+1;
  i20:=i10+i0; i21:=i11+i1; i22:=i12+i2; i23:=i13+i3; i24:=i14+i4;
  i25:=i15+i5; i26:=i16+i6; i27:=i17+i7; i28:=i18+i8; i29:=i19+i9;
  i30:=i20+i10; i31:=i21+i11; i32:=i22+i12; i33:=i23+i13; i34:=i24+i14;
  i35:=i25+i15; i36:=i26+i16; i37:=i27+i17; i38:=i28+i18; i39:=i29+i19;
  i40:=i30+i20; i41:=i31+i21; i42:=i32+i22; i43:=i33+i23; i44:=i34+i24;
  i45:=i35+i25; i46:=i36+i26; i47:=i37+i27; i48:=i38+i28; i49:=i39+i29;
  i50:=i40+i30; i51:=i41+i31; i52:=i42+i32; i53:=i43+i33; i54:=i44+i34;
  i55:=i45+i35; i56:=i46+i36; i57:=i47+i37; i58:=i48+i38; i59:=i49+i39;
  i60:=i50+i40; i61:=i51+i41; i62:=i52+i42; i63:=i53+i43; i64:=i54+i44;
  i65:=i55+i45; i66:=i56+i46; i67:=i57+i47; i68:=i58+i48; i69:=i59+i49;
  i70:=i60+i50; i71:=i61+i51; i72:=i62+i52; i73:=i63+i53; i74:=i64+i54;
  i75:=i65+i55; i76:=i66+i56; i77:=i67+i57; i78:=i68+i58; i79:=i69+i59;
  i80:=i70+i60; i81:=i71+i61; i82:=i72+i62; i83:=i73+i63; i84:=i74+i64;
  i85:=i75+i65; i86:=i76+i66; i87:=i77+i67; i88:=i78+i68; i89:=i79+i69;
  i90:=i80+i70; i91:=i81+i71; i92:=i82+i72; i93:=i83+i73; i94:=i84+i74;
  i95:=i85+i75; i96:=i86+i76; i97:=i87+i77; i98:=i88+i78; i99:=i89+i79;
  i0:=i90+i91+i92+i93+i94+i95+i96+i97+i98+i99;
  if (i0=2815) then
     writeln(' LONG DECLARATIONS ALLOWED...6.5.1-2')
  else
     writeln(' LONG DECLARATIONS NOT ALLOWED...6.5.1-2');
end.
{TEST 6.5.3.2-1, CLASS=ERRORHANDLING}

{ This test is similar to 6.4.5-6, except that a two
  dimensional array is used. This may present some problems to
  particular implementations. }

program t6p5p3p2d1(output);
var
   urray : array[1..10,1..10] of integer;
   i	 : integer;
begin
   i:=3;
   urray[i*2,i*4]:=0;
   writeln(' ERROR NOT DETECTED...6.5.3.2-1')
end.
{TEST 6.5.3.2-2, CLASS=CONFORMANCE}

{ This test checks that the two ways of indexing a multi-dimensional
  array are equivalent. The compiler fails if the program does
  not compile and print PASS.}

program t6p5p3p2d2(output);
var
   a:array[1..4,1..4] of integer;
   b:array[1..4] of
      array[1..4] of integer;
   p:packed array [1..4,1..4]of char;
   q:packed array[1..4] of
      packed array [1..4] of char;
   i,j,counter:integer;
begin
   counter:=0;
   for i:= 1 to 4 do
      for j:=1 to 4 do
      begin
	 a[i,j] := j;
	 b[i,j] := j;
	 case j of
	 1:
	   begin
	       p[i,j]:='F';
	       q[i,j]:='F';
	   end;
	 2:
	   begin
	       p[i,j]:='A';
	       q[i,j]:='A';
	   end;
	 3:
	   begin
	       p[i,j]:='I';
	       q[i,j]:='I';
	   end;
	 4:
	   begin
	       p[i,j]:='L';
	       q[i,j]:='L';
	   end;
	 end;
      end;
   for i:=1 to 4 do
      for j:=1 to 4 do
      begin
	 if a[i][j] <> a[i,j] then
	    counter:=counter+1;
	 if b[i][j] <> b[i,j] then
	    counter:=counter+1;
	 if p[i][j] <> p[i,j] then
	    counter:=counter+1;
	 if q[i][j] <> q[i,j] then
	    counter:=counter+1;
      end;
   if counter=0 then
      writeln(' PASS...6.5.3.2-2, INDEXING')
   else
      writeln(' FAIL...6.5.3.2-2, INDEXING')
end.
{TEST 6.5.3.4-1, CLASS=CONFORMANCE}

{ The Pascal Standard states that the existance of a file
  variable f with components of type T implies the existence
  of a buffer variable of type T.
  Only the one component of a file variable determined by the
  current file position is directly accessible.
  The program tests that file buffers may be referenced in this
  implementation.
  The compiler fails if the program does not compile. }

program t6p5p3p4d1(output);
type
   rekord = record
	       urray : array[1..2] of char;
	       a : integer;
	       b : real
	    end;
var
   fyle : file of rekord;
begin
   rewrite(fyle);
   fyle^.urray[1]:='O';
   fyle^.urray[2]:='K';
   fyle^.a:=10;
   fyle^.b:=2.345;
   put(fyle);
   with fyle^ do
   begin
      urray[1]:='O';
      urray[2]:='K';
      a:=4;
      b:=3.456
   end;
   put(fyle);
   writeln(' PASS...6.5.3.4-1')
end.
{TEST 6.5.4-1, CLASS=ERRORHANDLING}

{ The Pascal Standard states that an error occurs if a pointer
  variable has a value NIL at the time it is dereferenced.
  This program tests that the error is detected. The diagnostic
  should be checked for suitability. }

program t6p5p4d1(output);
type
   rekord = record
	       a : integer;
	       b : boolean
	    end;
var
   pointer : ^rekord;
begin
   pointer:=nil;
   pointer^.a:=1;
   pointer^.b:=true;
   writeln(' ERROR NOT DETECTED...6.5.4-1')
end.
{TEST 6.5.4-2, CLASS=ERRORHANDLING}

{ Similarly to 6.5.4-1, an error occurs if a pointer variable
  has an undefined value when it is dereferenced. }

program t6p5p4d2(output);
type
   rekord = record
	       a : integer;
	       b : boolean
	    end;
var
   pointer : ^rekord;
begin
   pointer^.a:=1;
   pointer^.b:=true;
   writeln(' ERROR NOT DETECTED...6.5.4-2')
end.
{TEST 6.6.1-1, CLASS=CONFORMANCE}

{ This program simply tests the syntax for procedures as defined
  by the Pascal Standard.
  The compiler fails if the program does not compile. }

program t6p6p1d1(output);
var
   a : integer;
   b : real;
procedure withparameters(g : integer; h : real);
var
   c : integer;
   d : real;
begin
   c:=g;
   d:=h
end;

procedure parameterless;
begin
   write(' PASS')
end;

begin
   a:=1;
   b:=2;
   withparameters(a,b);
   parameterless;
   writeln('...6.6.1-1')
end.
{TEST 6.6.1-2, CLASS=CONFORMANCE}

{ This program tests the implementation of FORWARD declaration,
  recursive activation, and multilevel referencing of a var
  parameter in procedures.
  The compiler fails if the program will not compile. }

program t6p6p1d2(output);
var
   c : integer;

procedure one(var a : integer);
   forward;

procedure two(var b : integer);
begin
   b:=b+1;
   one(b)
end;

procedure one;
begin
   a:=a+1;
   if a = 1 then two(a)
end;

begin
   c:=0;
   one(c);
   if c = 3 then
      writeln(' PASS...6.6.1-2')
end.
{TEST 6.6.1-4, CLASS=DEVIANCE}

{ This program tests if the compiler allows the formal parameter
  list to be included in the subsequent procedure declaration of
  a forward procedure.
  The compile conforms to the Standard if the program does not
  compile. }

program t6p6p1d4(output);
var
   c : integer;

procedure one(var a : integer);
   forward;

procedure two(var b : integer);
begin
   b:=b+1;
   one(b)
end;

procedure one(var a : integer);
begin
   a:=a+1;
   if a = 1 then two(a)
end;

begin
   c:=0;
   one(c);
   writeln(' DEVIATES...6.6.1-4')
end.
{TEST 6.6.1-5, CLASS=DEVIANCE}

{ If the compiler permits the formal parameter list to be included
  in the subsequent procedure declaration of a forward procedure
  (6.6.1-4), does it check the parameter list is the same ?
  The compiler deviates if the program compiles, and only conforms
  if the second formal parameter list is flagged as an error. }

program t6p6p1d5(output);
var
   c : integer;

procedure one(var a : integer);
   forward;

procedure two(var b : integer);
begin
   b:=b+1;
   one(b)
end;

procedure one(a : integer);
begin
   a:=a+1;
   if a = 1 then two(a)
end;

begin
   c:=0;
   one(c);
   writeln(' DEVIATES...6.6.1-5')
end.
{TEST 6.6.1-6, CLASS=DEVIANCE}

{ This program tests the compilers actions for a procedure declared
  as forward, but no matching subsequent procedure declaration
  for the forward procedure occurs. }

program t6p6p1d6(output);
var
   c : integer;

procedure two(var b : integer);
   forward;

procedure one(var a : integer);
begin
   a:=a+1;
   if a = 1 then two(a)
end;

begin
   c:=0;
   one(c)
   writeln(' DEVIATES...6.6.1-6, FORWARD PROCEDURE');
end.
{TEST 6.6.1-7, CLASS=QUALITY}

{ This test checks that procedures may be nested to 15 levels.
  The test may detect a small compiler limit.  The limit may
  arise due to failure of a register allocation scheme, a limited
  reserved size for a display, or a field set aside for lexical
  level information, or some combination of these. }

program t6p6p1d7(output);
var
   i:integer;

procedure p1;
   procedure p2;
      procedure p3;
	 procedure p4;
	    procedure p5;
	       procedure p6;
		  procedure p7;
		     procedure p8;
			procedure p9;
			   procedure p10;
			      procedure p11;
				 procedure p12;
				    procedure p13;
				       procedure p14;
					  procedure p15;
					  begin
					     i:=i+1;
					  end;
				       begin
					  p15
				       end;
				    begin
				       p14
				    end;
				 begin
				    p13
				 end;
			      begin
				 p12
			      end;
			   begin
			      p11
			   end;
			begin
			   p10
			end;
		     begin
			p9
		     end;
		  begin
		     p8
		  end;
	       begin
		  p7
	       end;
	    begin
	       p6
	    end;
	 begin
	    p5
	 end;
      begin
	 p4
      end;
   begin
      p3
   end;
begin
   p2
end;

begin
    i:=0;
    p1;
    writeln(' NESTED PROCEDURES TO 15 LEVELS IMPLEMENTED...6.6.1-7');
 end.
{TEST 6.6.2-1, CLASS=CONFORMANCE}

{ This program simply tests the syntax for functions as defined
  by the Pascal Standard.
  The compiler fails if the program does not compile. }

program t6p6p2d1(output);
var
   a ,
   twopisquared : real;
   b : integer;

function power(x : real; y : integer):real;  { y>=0 }
var
   w,z : real;
   i : 0..maxint;
begin
   w:=x;
   z:=1;
   i:=y;
   while i > 0 do
   begin
      { z*(w tothepower i)=x tothepower y }
      if odd(i) then z:=z*w;
      i:=i div 2;
      w:=sqr(w)
   end;
   { z=x tothepower y }
   power:=z
end;

function twopi : real;
begin
   twopi:=6.283185
end;

begin
   a:=twopi;
   b:=2;
   twopisquared:=power(a,b);
   writeln(' PASS...6.6.2-1')
end.
{TEST 6.6.2-2, CLASS=CONFORMANCE}

{ Similarly to 6.6.1-2, functions may be declared as forward.
  This program tests that forward declaration and recursion in
  functions is permitted.
  The compiler fails if the program does not compile. }

program t6p6p2d2(output);
var
   c : integer;
function one(a : integer) : integer;
   forward;

function two(b : integer) : integer;
var
   x : integer;
begin
   x:=b+1;
   x:=one(x);
   two:=x
end;

function one;
var
   y : integer;
begin
   y:=a+1;
   if y=1 then y:=two(y);
   one:=y
end;

begin
   c:=0;
   c:=one(c);
   if c = 3 then
      writeln(' PASS...6.6.2-2')
end.
{TEST 6.6.2-3, CLASS=CONFORMANCE}

{ The Pascal Standard specifies that the result type of a function
  can only be a simple type or a pointer type.
  This program checks that the simple types and pointer types are
  permitted.
  The compiler fails if the program does not compile. }

program t6p6p2d3(output);
type
   subrange = 0..3;
   enumerated = (red,yellow,green);
   rectype = record
	       a : integer
	     end;
   ptrtype = ^rectype;
var
   a : real;
   b : integer;
   c : boolean;
   d : subrange;
   e : enumerated;
   f : char;
   g : ptrtype;

function one : real;
begin
   one:=2.63
end;
function two : integer;
begin
   two:=2
end;
function three : boolean;
begin
   three:=false
end;
function four : subrange;
begin
   four:=2
end;
function five : enumerated;
begin
   five:=yellow
end;
function six : char;
begin
   six:='6'
end;
function seven : ptrtype;
begin
   seven:=nil
end;

begin
   a:=one;
   b:=two;
   c:=three;
   d:=four;
   e:=five;
   f:=six;
   g:=seven;
   writeln(' PASS...6.6.2-3')
end.
{TEST 6.6.2-4, CLASS=DEVIANCE}

{ This program tests the compilers actions when the type of
  result returned by a function is not a simple type.
  All the cases should be rejected by the compiler if it
  conforms to the Standard. }

program t6p6p2d4(output);
type
   wrekord = record
	       a : integer;
	       b : boolean
	     end;
   sett    = set of 0..3;
   urray   = array[1..3] of char;
var
   record1 : wrekord;
   set1    : sett;
   array1  : urray;

function one : sett;
begin
   one:=[0..3]
end;

function two : urray;
begin
   two:='ABC'
end;

function three : wrekord;
var
   rekord : wrekord;
begin
   rekord.a:=1;
   rekord.b:=true;
   three:=rekord
end;

begin
   record1:=one;
   set1:=two;
   array1:=three;
   writeln(' DEVIATES...6.6.2-4')
end.
{TEST 6.6.2-5, CLASS=DEVIANCE}

{ The Pascal Standard specifies that at least one assignment
  statement which assigns a value to the function identifier
  must occur in the function block.
  Does the compiler permit a function declaration with
  no assignment to the function identifier?
  The compiler deviates if it does. }

program t6p6p2d5(output);
var
   a : integer;
function illegal(var b : integer) : integer;
var
   x : integer;
begin
   x:=b*2
end;

begin
   a:=2;
   a:=illegal(a);
   writeln(' DEVIATES...6.6.2-5')
end.
{TEST 6.6.2-6, CLASS=ERRORHANDLING}

{ The Pascal Standard states that the result of a function will
  be the last value assigned to its identifier. If no assignment
  occurs then the result is undefined.
  This program contains a function with an assignment to its
  identifier, however the assignment is never executed. An error
  should occur during execution. }

program t6p6p2d6(output);
var
   radius ,
   circlearea : real;
function area(a : real) : real;
var
   x : real;
begin
   if a > 0 then x:=3.1415926*a*a
	    else area:=0
end;

begin
   radius:=2;
   circlearea:=area(radius);
   writeln(' ERROR NOT DETECTED...6.6.2-6')
end.
{TEST 6.6.2-7, CLASS=CONFORMANCE}

{ This test checks that functions are not prohibited from altering
  their environment (ie. side effects). Though side effects are
  generally not to be encouraged, they are part of standard Pascal
  and do have genuine uses. Functions with side effect occur
  elsewhere in the validation suite. }

program t6p6p2d7(output);
type
   ptrtochar = ^char;
var
   c1,c2,c3,dummy:char;
   p1,p2:ptrtochar;

function testa(ptr:ptrtochar):char;
   {sneakiest, uses pointers}
var
   pp:ptrtochar;
begin
   pp:=ptr;
   pp^ := 'P';
   testa:='1'
end;

procedure assign;
   {used by testb}
begin
   c1:='A'
end;

function testb:char;
   {sneaky, calls a procedure}
begin
   assign;
   testb:='2'
end;

function testc:char;
   {blatantly changes the environment via write}
begin
   write(' ',p1^,c1,c2,c3,p2^);
   testc:='6'
end;

function testd:ptrtochar;
   {blatantly sneaky: modifying the environment via new
      and then passing it out}
var
   pp:ptrtochar;
begin
   new(pp);
   pp^:='.';
   testd:=pp
end;

function teste:char;
   {the most used side effect:global access}
begin
   c2:='S';
   teste:='3'
end;

function testf(var c:char):char;
   {straightforward}
begin
   c:='S';
   testf:='4'
end;

begin {of main program}
   new(p1);
   p1^:='F'; c1:='A'; c2:='I'; c3:='L';
   p2:=nil;
      {which defines all variables}
   dummy:=testa(p1);
   dummy:=testb;
   dummy:=teste;
   dummy:=testf(c3);
   p2:=testd;
   dummy:=testc;
   writeln('..6.6.2-7, ENVIRONMENT')
end.
{TEST 6.6.3.1-1, CLASS=CONFORMANCE}

{ This program tests that parameters as described by the Pascal
  Standard are permitted by the compiler, especially long
  identifier lists. A parameter list with 30 elements is thought
  long enough to test most applications using procedure/function
  parameter lists. This test occurs elsewhere in the suite, but
  is included here for consistency.
  The compiler fails if the program does not compile. }

program t6p6p3p1d1(output);
type
   colour   = (red,orange,yellow,green,blue,brown);
   subrange = red..blue;
   rekord   = record
	       a : integer
	      end;
   ptrtype  = ^rekord;
var
   a,b,c,d,e,f,g,h,i,j,
   k,l,m,n,o,p,q,r,s,t : integer;
   colone : colour;
   coltwo : colour;
   colthree : colour;
   u,v,w,x : real;
   y,z : boolean;
   ptr : ptrtype;

procedure testone(a1,b1,c1,d1,e1,f1,g1,h1,i1,j1,k1,
		  l1,m1,n1,o1,p1,q1,r1,s1,t1 : integer;
		  colourone : subrange;
		  colourtwo,colourthree : colour;
		  u1,v1,w1,x1 : real;
		  y1,z1 : boolean;
		  ptr : ptrtype);
begin
   write(' PASS')
end;
procedure testtwo(var a1,b1,c1,d1,e1,f1,g1,h1,i1,j1,k1,
		  l1,m1,n1,o1,p1,q1,r1,s1,t1 : integer;
		  var colourone : subrange;
		  var colourtwo,colourthree : colour;
		  var u1,v1,w1,x1 : real;
		  var y1,z1 : boolean;
		  var ptr : ptrtype);
begin
   writeln('...6.6.3.1-1')
end;

begin
   a:=0; b:=0; c:=0; d:=0; e:=0; f:=0; g:=0;
   h:=0; i:=0; j:=0; k:=0; l:=0; m:=0; n:=0;
   o:=0; p:=0; q:=0; r:=0; s:=0; t:=0;
   colone:=orange;
   coltwo:=brown;
   colthree:=red;
   u:=0; v:=0; w:=0; x:=0;
   y:=true;
   z:=false;
   new(ptr);
   testone(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,
	   colone,coltwo,colthree,u,v,w,x,y,z,ptr);
   testtwo(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,
	   colone,coltwo,colthree,u,v,w,x,y,z,ptr);
end.
{TEST 6.6.3.1-2, CLASS=CONFORMANCE}

{ This program is similar to 6.6.3.1-1, except that set,
  record and array parameter lists are tested.
  The compiler fails if the program does not compile. }

program t6p6p3p1d2(output);
type
   sett     = set of 0..20;
   rekord   = record
	       a : integer
	      end;
   urray    = array[boolean] of boolean;
var
   setone, settwo,setthree,setfour,setfive,setsix : sett;
   recone,rectwo,recthree,recfour,recfive : rekord;
   urrayone,urraytwo,urraythree,urrayfour : urray;

procedure testone(set1,set2,set3,set4,set5,set6 : sett;
		  rec1,rec2,rec3,rec4,rec5 : rekord;
		  urray1,urray2,urray3,urray4 : urray);
begin
   write(' PASS')
end;

procedure testtwo(var set1,set2,set3,set4,set5,set6 : sett;
		  var rec1,rec2,rec3,rec4,rec5 : rekord;
		  var urray1,urray2,urray3,urray4 : urray);
begin
   writeln('...6.6.3.1-2')
end;

begin
   setone:=[1];   settwo:=[1];	 setthree:=[1];
   setfour:=[1];  setfive:=[1];  setsix:=[1];
   recone.a:=1;   rectwo.a:=1;	 recthree.a:=1;
   recfour.a:=1;  recfive.a:=1;
   urrayone[true]:=false;  urraytwo[true]:=false;
   urraythree[true]:=false;   urrayfour[true]:=false;

   testone(setone,settwo,setthree,setfour,setfive,setsix,
	    recone,rectwo,recthree,recfour,recfive,
	    urrayone,urraytwo,urraythree,urrayfour);
   testtwo(setone,settwo,setthree,setfour,setfive,setsix,
	    recone,rectwo,recthree,recfour,recfive,
	    urrayone,urraytwo,urraythree,urrayfour);
end.
{TEST 6.6.3.1-3, CLASS=CONFORMANCE}

{ This program tests that files may be passed to
  procedures as parameters, as a file is a type, and any
  type may be passed as a parameter.
  The compiler fails if the program does not compile. }

program t6p6p3p1d3(output);
type
   fyle = text;
var
   elyf : fyle;
procedure test(var anyfile : fyle);
begin
   rewrite(anyfile);
   writeln(anyfile,'THIS FILE WAS A PARAMETER');
   writeln(' PASS...6.6.3.1-3')
end;
begin
   test(elyf)
end.
{TEST 6.6.3.1-4, CLASS=DEVIANCE}

{ The occurrence of an identifier within an identifier list of
  a parameter group is its defining occurence as a parameter
  identifier for the formal parameter list in which it occurs
  and any corresponding procedure block or function block.
  This precludes the declaration of a local variable with the same
  name as an identifier in the formal parameter list.
  Does the compiler detect this as an error, or allow it
  to occur with some form of side effect?
  The compiler conforms if the program does not compile. }

program t6p6p3p1d4(output);
var
   i : integer;
procedure deviates(var x : integer);
   var x : integer;
begin
   x:=2*x;
   writeln(' DEVIATES...6.6.3.1-4 : x=',x)
end;
procedure deviates1(x : integer);
   var x : integer;
begin
   x:=0;
   x:=2*x;
   writeln(' DEVIATES...6.6.3.1-4 : x=',x)
end;

begin
   i:=5;
   deviates(i);
   i:=5;
   deviates1(i)
end.
{TEST 6.6.3.1-5, CLASS=CONFORMANCE}

{ When a procedure (or function) with a parameter list is
  included in the formal parameter list of another procedure
  (or function), the identifiers in the parameter list of the
  procedure parameter have defining occurences for that list
  and the corresponding block for the procedure only, and not
  for the block of the procedure to which it is passed.
  The example in this program should be passed by the compiler. }

program t6p6p3p1d5(output);
var
   i : integer;
procedure alsoconforms(x : integer);
begin
   writeln(' PASS...6.6.3.1-5')
end;

procedure conforms(procedure alsoconforms(x : integer));
   var x : boolean;
begin
   x:=true;
   alsoconforms(1)
end;

begin
   i:=2;
   conforms(alsoconforms(i))
end.
{TEST 6.6.3.2-1, CLASS=CONFORMANCE}

{ This program would have tested that the actual parameters to
  a procedure/function are assignment compatible with the type
  of the formal parameter.
  However, this test is carried out by test 6.4.6-2, and the
  user is refered to there. }
program t6p6p3p2d1;
begin
end.
{TEST 6.6.3.3-1, CLASS=CONFORMANCE}

{ This program would have tested that the actual parameters to
  a procedure/function are identical to the type of the formal
  parameters.
  This test is carried out by program 6.4.5-1, and the user is
  refered to there. }
program t6p6p3p3d1;
begin
end.
{TEST 6.6.3.3-2, CLASS=CONFORMANCE}

{ The Pascal Standard states that any operation involving the
  formal parameter is performed immediately on the actual
  parameter. Depending on how variable parameter passing is
  implemented, this test may cause some compilers to fail.
  The compiler fails if the program does not compile, or the
  program states that this is so. }

program t6p6p3p3d2(output);
var
   direct : integer;
   pass  : boolean;
procedure indirection(var indirect : integer; var result : boolean);
   begin
      indirect:=2;
      if indirect<>direct then
	 result:=false
      else
	 result:=true
   end;
begin
   direct:=1;
   pass:=false;
   indirection(direct,pass);
   if pass then
      writeln(' PASS...6.6.3.3-2')
   else
      writeln(' FAIL...6.6.3.3-2')
end.
{TEST 6.6.3.3-3, CLASS=CONFORMANCE}

{ If the variable passed as a parameter involves the indexing
  of an array, or the dereferencing of a pointer, then these
  actions are executed before the activation of the block.
  The compiler fails if the program does not compile or the
  program states that this is so. }

program t6p6p3p3d3(output);
type
   rekord = record
	       a : integer;
	       link : ^rekord;
	       back : ^rekord
	    end;
var
   urray : array[1..2] of integer;
   i	 : integer;
   temptr,ptr : ^rekord;
procedure call(arrayloctn : integer;
	       ptrderef : integer);
   begin
      i:=i+1;
      ptr:=ptr^.link;
      if (urray[i-1] <> arrayloctn) or
	 (ptr^.back^.a <> ptrderef) then
	 writeln(' FAIL...6.6.3.3-3')
      else
	 writeln(' PASS...6.6.3.3-3')
   end;
begin
   urray[1]:=1;
   urray[2]:=2;
   i:=1;
   new(ptr);
   ptr^.a:=1;
   new(temptr);
   temptr^.a:=2;
   ptr^.link:=temptr;
   temptr^.back:=ptr;
   call(urray[i],ptr^.a)
end.
{TEST 6.6.3.4-1, CLASS=CONFORMANCE}

{ This program tests that procedures may be passed to other
  procedures and functions as parameters.
  The compiler fails if the program does not compile and run. }

program t6p6p3p4d1(output);
var
   i : integer;
procedure a(procedure b);
   begin
      write(' PASS');
      b
   end;
procedure c;
   begin
      write('.')
   end;
function d(procedure b) : integer;
   begin
      b;
      d:=2
   end;

begin
   a(c);
   i:=d(c);
   if i=2 then
      writeln('.6.6.3.4-1')
end.
{TEST 6.6.3.4-2, CLASS=CONFORMANCE}

{ This program tests that the environment of procedure
  parameters is as stated in the Pascal Standard.
  The compiler fails if the program does not compile, or
  the program states that this is so. }

program t6p6p3p4d2(output);
var
   globalone, globaltwo : integer;
procedure p(procedure f(procedure a,b);procedure g);
   var
      localtop : integer;
   procedure r;
      begin
	 if globalone=1 then
	 begin
	    if (globaltwo<>2) or (localtop<>1) then
	       writeln(' FAIL1...6.6.3.4-2')
	 end
	 else
	    if globalone=2 then
	    begin
	       if (globaltwo<>2) or (localtop<>2) then
		  writeln(' FAIL2...6.6.3.4-2')
	       else
		  writeln(' PASS...6.6.3.4-2')
	    end
	    else
	       writeln(' FAIL3...6.6.3.4-2');
	 globalone:=globalone+1;
      end;     { of r }
   begin    { of p }
      globaltwo:=globaltwo+1;
      localtop:=globaltwo;
      if globaltwo=1 then
	 p(f,r)
      else
	 f(g,r)
   end;     { of p }
procedure q(procedure f,g);
   begin
      f;
      g
   end;
procedure dummy;
begin
   writeln(' FAIL4...6.6.3.4-2')
end;

begin
   globalone:=1;
   globaltwo:=0;
   p(q,dummy)
end.
{TEST 6.6.3.5-1, CLASS=CONFORMANCE}

{ Similarly to 6.6.3.4-1, this program tests that functions may
  be passed to procedures and functions as parameters.
  The compiler fails if the program does not compile and run. }

program t6p6p3p5d1(output);
var
   j : integer;
procedure a(function b : integer);
   var
      i : integer;
   begin
      i:=b;
      write(' PASS')
   end;
function c : integer;
   begin
      c:=2
   end;
function d(function b : integer) : integer;
   begin
      d:=b
   end;
begin
   a(c);
   j:=d(c);
   if j=2 then
      writeln('...6.6.3.5-1')
end.
{TEST 6.6.3.5-2, CLASS=DEVIANCE}

{ This test checks functional compatibility in that function
  types are required to be identical. The compiler deviates if the
  program compiles and prints DEVIATES. }

program t6p6p3p5d2(output);
type
   natural=0..maxint;
var
   k:integer;

function actual(i:natural):natural;
begin
   actual:=i
end;

procedure p(function formal(i:natural):integer);
begin
   k:=formal(10)
end;

begin
   p(actual);
   writeln(' DEVIATES...6.6.3.5-2, FUNC TYPES NOT IDENTICAL')
end.
{TEST 6.6.3.6-1, CLASS=DEVIANCE}

{ This test checks that constants are not permitted
  as var parameters. The compiler deviates if the program
  compiles and prints DEVIATES. }

program t6p6p3p6d1(output);
const
   x=1;
var
   y:integer;
procedure assign(var p:integer);
begin
   p:=100
end;

begin
   assign(y);
   assign(x);	{disallowed}
   writeln(' DEVIATES...6.6.3.6-1, VAR PARAMS')
end.
{TEST 6.6.3.6-2, CLASS=DEVIANCE}

{ This test checks that parameter list compatibility is correctly
  implemented. The compiler deviates if the program compiles
  and prints DEVIATES. }

program t6p6p3p6d2(output);
type
   natural = 0..maxint;

procedure actual(i:integer; n:natural);
begin
   i:=n
end;

procedure p(procedure formal(a:integer;b:integer));
var
   k,l:integer;
begin
   k:=1; l:=2;
   formal(k,l)
end;

begin
   p(actual);
   writeln(' DEVIATES...6.6.3.6-2, VALUE PARS NOT IDENT TYPES')
end.
{TEST 6.6.3.6-3, CLASS=DEVIANCE}

{ This test checks that parameter list compatibility is correctly
  implemented. The compiler deviates if the program compiles
  and prints DEVIATES. }

program t6p6p3p6d3(output);
type
   natural = 0..maxint;

procedure actual(i:integer; n:natural);
begin
   i:=n
end;

procedure p(procedure formal(var a:integer;b:natural));
var
   k,l:integer;
begin
   k:=1; l:=2;
   formal(k,l)
end;

begin
   p(actual);
   writeln(' DEVIATES...6.6.3.6-3, VALUE/VAR MISMATCH')
end.
{TEST 6.6.3.6-4, CLASS=DEVIANCE}

{ This test checks that parameter list compatibility is correctly
  implemented. The compiler deviates if the program compiles
  and prints DEVIATES. }

program t6p6p3p6d4(output);
type
   natural = 0..maxint;

procedure actual(var i:integer;var  n:natural);
begin
   i:=n
end;

procedure p(procedure formal(var a:integer;var b:integer));
var
   k,l:integer;
begin
   k:=1; l:=2;
   formal(k,l)
end;

begin
   p(actual);
   writeln(' DEVIATES...6.6.3.6-4, VAR PARS NOT IDENT TYPES')
end.
{TEST 6.6.3.6-5, CLASS=DEVIANCE}

{ This test checks that parameter list compatibility is correctly
  implemented. The compiler deviates if the program compiles
  and prints DEVIATES. }

program t6p6p3p6d5(output);
type
   natural = 0..maxint;

procedure actual(i:integer; j:integer; n:natural);
begin
   i:=n
end;

procedure p(procedure formal(a:integer;b:integer));
var
   k,l:integer;
begin
   k:=1; l:=2;
   formal(k,l)
end;

begin
   p(actual);
   writeln(' DEVIATES...6.6.3.6-5, NO OF PARS DIFFERENT')
end.
{TEST 6.6.4.1-1, CLASS=CONFORMANCE}

{ This program tests that predefined standard procedures may
  be redefined with no conflict.
  The compiler fails if the program does not compile and run. }

program t6p6p4p1d1(output);
var
   i : integer;
procedure write(var a : integer);
   begin
      a:=a+2
   end;
procedure get(var a : integer);
   begin
      a:=a*2
   end;

begin
   i:=0;
   write(i);
   get(i);
   if i=4 then
      writeln(' PASS...6.6.4.1-1')
   else
      writeln(' FAIL...6.6.4.1-1')
end.
{TEST 6.6.5.2-1, CLASS=ERRORHANDLING}

{ This program causes an error to occur, as eof(f) does
  not yield true prior to execution of a put on the file f.
  The error should be detected at compile-time or run-time. }

program t6p6p5p2d1(output);
var
   fyle : text;
begin
   rewrite(fyle);
   writeln(fyle,'ABC');
   reset(fyle);      { eof is false and f^='A' }
   put(fyle);	     { causes an error }
   writeln(' ERROR NOT DETECTED...6.6.5.2-1')
end.
{TEST 6.6.5.2-2, CLASS=ERRORHANDLING}

{ This program causes an error to occur as eof(f) does
  not yield false prior to execution of a get on the file f.
  The error should be detected at compile-time or run-time. }

program t6p6p5p2d2(output);
var
   fyle : text;
begin
   rewrite(fyle);
   writeln(fyle,'ABC');
   reset(fyle);
   get(fyle);		 { fyle^='A' }
   get(fyle);		{ fyle^='B' }
   get(fyle);		{ fyle^='C' }
   get(fyle);		{ fyle^ undefined...eof is true }
   get(fyle);		{ error since eof is true }
   writeln(' ERROR NOT DETECTED...6.6.5.2-2')
end.
{TEST 6.6.5.2-3, CLASS=CONFORMANCE}

{ This program tests if true is assigned to eof if the file f
  is empty when reset. }

program t6p6p5p2d3(output);
var
   fyle : text;
begin
   reset(fyle);
   if eof(fyle) then
      writeln(' PASS...6.6.5.2-3')
   else
      writeln(' FAIL...6.6.5.2-3')
end.
{TEST 6.6.5.2-4, CLASS=CONFORMANCE}

{ This program tests that the first element of a file f
  is assigned to the buffer variable f^ when the procedure
  reset is used with the file f. }

program t6p6p5p2d4(output);
var
   fyle : text;
begin
   rewrite(fyle);
   writeln(fyle,'ABC');
   writeln(fyle,'DEF');
   reset(fyle);
   if fyle^='A' then
      writeln(' PASS...6.6.5.2-4')
   else
      writeln(' FAIL...6.6.5.2-4')
end.
{TEST 6.6.5.2-5, CLASS=CONFORMANCE}

{ This program checks that a rewrite on the file f sets
  eof to be true. }

program t6p6p5p2d5(output);
var
   fyle : text;
begin
   rewrite(fyle);
   if eof(fyle) then
      writeln(' PASS...6.6.5.2-5')
   else
      writeln(' FAIL...6.6.5.2-5')
end.
{TEST 6.6.5.2-6, CLASS=ERRORHANDLING}

{ This program causes an error to occur by changing the
  current file position of a file f, while the buffer
  variable is an actual parameter to a procedure.
  The error should be detected by the compiler, or at
  run-time. }

program t6p6p5p2d6(output);
var
   fyle : text;
procedure naughty(f : char);
   begin
      if f='G' then
	 put(fyle)
   end;
begin
   rewrite(fyle);
   fyle^:='G';
   naughty(fyle^);
   writeln(' ERROR NOT DETECTED...6.6.5.2-6')
end.
{TEST 6.6.5.2-7, CLASS=ERRORHANDLING}

{ This test is similar to 6.6.5.2-6, except that the
  buffer variable is an element of the record variable list
  of a with statement.
  The error should be detected by the compiler or at
  run-time. }

program t6p6p5p2d7(output);
type
   sex	 = (male,female,notgiven);
   socialsecuritynumber = 0..10000;
   rekord = record
	       a : socialsecuritynumber;
	       b : sex
	    end;
var
   fyle : file of rekord;
begin
   rewrite(fyle);
   with fyle^ do
   begin
      a:=9999;
      b:=notgiven;
      put(fyle)
   end;
   writeln(' ERROR NOT DETECTED...6.6.5.2-7')
end.
{TEST 6.6.5.3-1, CLASS=CONFORMANCE}

{ This program checks that the procedure new has
  been implemented. Both forms of new are tested
  and both should pass. }

program t6p6p5p3d1(output);
type
   two	    = (a,b);
   recone   = record
	       i : integer;
	       j : boolean
	      end;
   rectwo   = record
	       c : integer;
	       case tagfield : two of
		  a : (m : integer);
		  b : (n : boolean)
	      end;
   recthree = record
	       c : integer;
	       case tagfield : two of
		  a : (case tagfeeld : two of
			   a : (o : real);
			   b : (p : char));
		  b : (q : integer)
	      end;
var
   ptrone : ^recone;
   ptrtwo : ^rectwo;
   ptrthree : ^recthree;
begin
   new(ptrone);
   new(ptrtwo,a);
   ptrtwo^.tagfield:=a;
   new(ptrthree,a,b);
   ptrthree^.tagfield:=a;
   ptrthree^.tagfeeld:=a;
   writeln(' PASS...6.6.5.3-1')
END.
{TEST 6.6.5.3-2, CLASS=CONFORMANCE}

{ This program tests that new and dispose operate as described
  in the Standard, however the undefinition of the pointer
  variable by dispose is not tested.
  The compiler fails if the program does not compile
  and run to completion. }

program t6p6p5p3d2(output);
var
   ptr : ^integer;
   i   : integer;
begin
   for i:=1 to 10 do
   begin
      new(ptr);
      ptr^:=i;
      dispose(ptr)
   end;
   writeln(' PASS...6.6.5.3-2')
end.
{TEST 6.6.5.3-3, CLASS=ERRORHANDLING}

{ This program causes an error to occur as the pointer
  parameter of dispose is nil. The error should be detected
  by the compiler or at run-time. }

program t6p6p5p3d3(output);
type
   rekord = record
	    a : integer;
	    b : boolean
	   end;
var
   ptr : ^rekord;
begin
   ptr:=nil;
   dispose(ptr);
   writeln(' ERROR NOT DETECTED...6.6.5.3-3')
end.
{TEST 6.6.5.3-4, CLASS=ERRORHANDLING}

{ Similarly to 6.6.5.3-3, an error is caused by the
  pointer variable of dispose being undefined.
  The error should be detected by the compiler
  or at run-time. }

program t6p6p5p3d4(output);
type
   rekord = record
	     a : integer;
	     b : boolean
	    end;
var
   ptr : ^rekord;
begin
   dispose(ptr);
   writeln(' ERROR NOT DETECTED...6.6.5.3-4')
end.
{TEST 6.6.5.3-5, CLASS=ERRORHANDLING}

{ This program causes an error to occur as a variable
  which is currently an actual variable parameter is
  refered to by the pointer parameter of dispose.
  The error should be detected by the compiler or
  at run-time. }

program t6p6p5p3d5(output);
var
   ptr : ^integer;
procedure error(a:integer);
   var
      x : integer;
   begin
      x:=a*2;
      dispose(ptr)
   end;
begin
   new(ptr);
   ptr^:=6;
   error(ptr^);
   writeln(' ERROR NOT DETECTED...6.6.5.3-5')
end.
{TEST 6.6.5.3-6, CLASS=ERRORHANDLING}

{ This program causes an error to occur as a variable which
  is an element of the record-variable-list of a with
  statement is refered to by the pointer parameter of
  dispose. }

program t6p6p5p3d6(output);
type
   subrange = 0..9999;
   rekord   = record
	       name : packed array[1..15] of char;
	       employeeno : subrange
	      end;
var
   ptr : ^rekord;
begin
   new(ptr);
   with ptr^ do
   begin
      name:='HARRY M. MULLER';
      employeeno:=9998;
      dispose(ptr)
   end;
   writeln(' ERROR NOT DETECTED...6.6.5.3-6')
end.
{TEST 6.6.5.3-7, CLASS=ERRORHANDLING}

{ This program causes an error to occur, as a variable
  created by the use of the variant form of new is used
  as an operand in an expression.
  The error should be detected by the compiler, or at
  run-time. }

program t6p6p5p3d7(output);
type
   two	    = (a,b);
   rekord   = record
	       case tagfield:two of
		  a : (m : boolean);
		  b : (n : char)
	      end;
var
   ptr	    : ^rekord;
   r	    : rekord;
begin
   new(ptr,a);
   ptr^.m:=true;
   r:=ptr^;
   writeln(' ERROR NOT DETECTED...6.6.5.3-7')
end.
{TEST 6.6.5.3-8, CLASS=ERRORHANDLING}

{ This test is similar to 6.6.5.3-7, except that the
  variable created is used as the variable in an assignment
  statement.
  The error should be detected by the compiler or at
  run-time. }

program t6p6p5p3d8(output);
type
   two	    = (a,b);
   rekord   = record
	       case tagfield:two of
		  a : (m : boolean);
		  b : (n : char)
	      end;
var
   ptr : ^rekord;
   r   : rekord;
begin
   new(ptr,b);
   r.tagfield:=b;
   r.n:='A';
   ptr^:=r;
   writeln(' ERROR NOT DETECTED...6.6.5.3-8')
end.
{TEST 6.6.5.3-9, CLASS=ERRORHANDLING}

{ This test is similar to 6.6.5.3-7, except that the
  variable created is used as an actual parameter.
  The error should be detected by the compiler or at
  run-time. }

program t6p6p5p3d9(output);
type
   two	    = (a,b);
   rekord   = record
	       case tagfield:two of
		  a : (m : boolean);
		  b : (n : char)
	      end;
var
   ptr : ^rekord;
procedure error(c : rekord);
   begin
      writeln(' ERROR NOT DETECTED...6.6.5.3-9')
   end;
begin
   new(ptr,a);
   ptr^.m:=true;
   error(ptr^)
end.
{TEST 6.6.5.4-1, CLASS=CONFORMANCE}

{ This program tests that pack and unpack are
  implemented in this compiler as according to the
  Standard.
  The compiler fails if the program does not compile. }

program t6p6p5p4d1(output);
type
   colourtype = (red,pink,orange,yellow,green,blue);
var
   unone    : array[3..24] of char;
   pacone   : packed array[1..4] of char;
   untwo    : array[4..8] of colourtype;
   pactwo   : packed array[6..7] of colourtype;
   i	    : integer;
   colour   : colourtype;
begin
   pacone:='ABCD';
   unpack(pacone,unone,5);
   colour:=red;
   for i:=4 to 8 do
   begin
      untwo[i]:=colour;
      colour:=succ(colour)
   end;
   pack(untwo,5,pactwo);
   if unone[5]='A' then
      writeln(' PASS...6.6.5.4-1')
   else
      writeln(' FAIL...6.6.5.4-1')
end.
{TEST 6.6.6.1-1, CLASS=IMPLEMENTATIONDEPENDENT}

{ The Pascal Standard does not state what action takes place
  when a standard function is used as a functional
  parameter. The effect is implementation dependent.
  This program uses a standard function as a parameter to a
  procedure. The compiler may reject this as an error, or
  may permit it as it should other functional parameters. }

program t6p6p6p1d1(output);
procedure quidnunk(function a(b : integer):boolean);
   var
      x : integer;
   y : boolean;
   begin
      x:=5;
      y:=a(x);
      if x=1 then
	 writeln(' STANDARD FUNCTIONS PERMITTED AS PARAMETERS',
		  '...6.6.6.1-1')
      else
	 writeln(' STANDARD FUNCTIONS NOT PERMITTED AS ',
		  'PARAMETERS...6.6.6.1-1')
   end;
begin
   quidnunk(odd)
end.
{TEST 6.6.6.2-1, CLASS=CONFORMANCE}

{ This program tests the implementation of the arithmetic
  function abs. Both real and integer expressions are used.
  The compiler fails if the program does not compile and run. }

program t6p6p6p2d1(output);
const
   pi = 3.1415926;
var
   i, counter : integer;
   r : real;
function myabs1(i : integer):integer;
   begin
      if i<0 then
	 myabs1:=-i
      else
	 myabs1:=i
   end;
function myabs2(r:real):real;
   begin
      if r<0 then
	 myabs2:=-r
      else
	 myabs2:=r
   end;
begin
   counter:=0;
   for i:=-10 to 10 do
   begin
      if abs(i)=myabs1(i) then
	 counter:=counter+1
   end;

   r:=-10.3;
   while r<10.3 do
   begin
      if abs(r)=myabs2(r) then
	 counter:=counter+1;
      r:=r+0.9
   end;

   if counter=44 then
      writeln(' PASS...6.6.6.2-1')
   else
      writeln(' FAIL...6.6.6.2-1:ABS')
end.
{TEST 6.6.6.2-2, CLASS=CONFORMANCE}

{ This program tests the implementation of the arithmetic
  function sqr. Both real and integer expressions are used.
  The compiler fails if the program does not compile and run. }

program t6p6p6p2d2(output);
var
   i,counter : integer;
   variable : real;
begin
   counter := 0;
   for i:= -10 to 10 do
   begin
      if sqr(i) = i*i then
	 counter := counter + 1;
   end;
   variable := -10.3;
   while (variable < 10.3) do
   begin
      if (sqr(variable) = variable*variable) then
	 counter := counter+1;
      variable := variable + 0.9;
   end;
   if (counter = 44) then
      writeln(' PASS...6.6.6.2-2')
   else
      writeln(' FAIL...6.6.6.2-2:SQR')
end.
{TEST 6.6.6.2-3, CLASS=CONFORMANCE}

{ This program tests the implementation of the arithmetic
  functions sin, cos, exp, ln, sqrt, and arctan.
  A rough accuracy test is done, but is not the purpose
  of this program.
  The compiler fails if the program does not compile and run. }

program t6p6p6p2d3(output);
const
   pi = 3.1415926;
var
   counter : integer;
begin
   counter:=0;
   if (sin(pi)<0.000001) and
      ((0.70710<sin(pi/4)) and (sin(pi/4)<0.70711)) then
      counter:=counter+1
   else
      writeln(' FAIL...6.6.6.2-3 : SIN');

   if (cos(pi)<-0.99999) and
      ((0.70710<cos(pi/4)) and (cos(pi/4)<0.70711)) then
      counter:=counter+1
   else
      writeln(' FAIL...6.6.6.2-3 : COS');

   if ((2.71828<exp(1)) and (exp(1)<2.71829)) and
      ((0.36787<exp(-1)) and (exp(-1)<0.36788)) and
      ((8103.08392<exp(9)) and (exp(9)<8103.08393)) then
      counter:=counter+1
   else
      writeln(' FAIL...6.6.6.2-3 : EXP');

   if (ln(exp(1))>0.99999) and
      ((0.69314<ln(2)) and (ln(2)<0.69315)) then
      counter:=counter+1
   else
      writeln(' FAIL...6.6.6.2-3 : LN');

   if (sqrt(25)=5) and
      ((5.09901<sqrt(26)) and (sqrt(26)<5.09902)) then
      counter:=counter+1
   else
      writeln(' FAIL...6.6.6.2-3 : SQRT');

   if ((0.09966<arctan(0.1)) and (arctan(0.1)<0.09967)) and
      (arctan(0)=0) then
      counter:=counter+1
   else
      writeln(' FAIL...6.6.6.2-3 : ARCTAN');

   if counter=6 then
      writeln(' PASS...6.6.6.2-3')
end.
{TEST 6.6.6.2-4, CLASS=ERRORHANDLING}

{ This program causes an error to occur as an expression
  with a negative value is used as an argument for the
  arithmetic function ln.
  The error should be detected at run-time. }

program t6p6p6p2d4(output);
var
   m : real;
begin
   m:=-2.71828;
   m:=ln(m*2);
   writeln(' ERROR NOT DETECTED...6.6.6.2-4')
end.
{TEST 6.6.6.2-5, CLASS=ERRORHANDLING}

{ This program causes an error to occur as a negative
  argument is used for the sqrt function.
  The error should be detected at run-time. }

program t6p6p6p2d5(output);
var
   m	: real;
   i, j : integer;
begin
   i:=256;
   j:=i*2;
   j:=j-257;
   m:=sqrt(j-i);
   writeln(' ERROR NOT DETECTED...6.6.6.2-5')
end.
{TEST 6.6.6.2-6, CLASS=QUALITY}

{ This test checks the implementation of the sqrt function. }

program t6p6p6p2d6(output);

var


{     data required

	 none

      other subprograms in this package

	 machar - An environmental inquiry program providing
		  information on the floating-point arithmetic
		  system.  Note that the call to machar can
		  be deleted provided the following five
		  parameters are assigned the values indicated

		  ibeta - the radix of the floating-point system
		  it	  the number of the base-ibeta digits in the
			  significand of a floating-point number
		  eps	  the smallest positive floating-point
			  number such that 1.0+eps <> 1.0
		  xmin	- the smallest positive floating-point
			  number
		  xmax	- the largest finite floating-point no.

       randl(x) - A function subprogram returning logarithmically
		  distributed random real numbers.  In particular,
			 a * randl(ln(b/a))
		  is logarithmically distributed over (a,b)

	 random - A function subprogram returning random real
		  numbers uniformly distributed over (0,1)


      standard subprograms required

	  abs, ln, exp, sqrt
								      }

   i , ibeta , iexp ,  irnd , it , j , k , k1 , machep , maxexp ,
   iy,minexp , n , negep , ngrd : integer ;
   a , albeta , b , beta , c , eps , epsneg , r5 , r6 , r7 , sqbeta , w
   , x , xmax , xmin , xn , x1 , y , z : real ;
procedure machar (var ibeta , it , irnd , ngrd , machep , negep , iexp,
  minexp , maxexp : integer ; var eps , epsneg , xmin , xmax : real ) ;

var


{     This subroutine is intended to determine the characteristics
      of the floating-point arithmetic system that are specified
      below.  The first three are determined according to an
      algorithm due to M. Malcolm, CACM 15 (1972), pp. 949-951,
      incorporating some, but not all, of the improvements
      suggested by M. Gentleman and S. Marovich, CACM 17 (1974),
      pp. 276-277.  The version given here is for single precision.

      Latest revision - October 1, 1976.

      Author - W. J. Cody
	       Argonne National Laboratory

      Revised for Pascal - R. A. Freak
			   University of Tasmania
			   Hobart
			   Tasmania

      ibeta    is the radix of the floating-point representation
      it       is the number of base ibeta digits in the floating-point
		  significand
      irnd     =  0 if the arithmetic chops,
		  1 if the arithmetic rounds
      ngrd     =  0 if	irnd=1, or if  irnd=0  and only  it  base ibeta
		    digits participate in the post normalization shift
		    of the floating-point significand in multiplication
		  1 if	irnd=0	and more than  it  base  ibeta	digits
		    participate in the post normalization shift of the
		    floating-point significand in multiplication
      machep   is the exponent on the smallest positive floating-point
		  number  eps such that  1.0+eps <> 1.0
      negeps   is the exponent on the smallest positive fl. pt. no.
		  negeps such that  1.0-negeps <> 1.0, except that
		  negeps is bounded below by  it-3
      iexp     is the number of bits (decimal places if ibeta = 10)
		  reserved for the representation of the exponent of
		  a floating-point number
      minexp   is the exponent of the smallest positive fl. pt. no.
		  xmin
      maxexp   is the exponent of the largest finite floating-point
		  number  xmax
      eps      is the smallest positive floating-point number such
		  that	1.0+eps <> 1.0. in particular,
		  eps = ibeta**machep
      epsneg   is the smallest positive floating-point number such
		  that	1.0-eps <> 1.0	(except that the exponent
		  negeps is bounded below by it-3).  in particular
		  epsneg = ibeta**negep
      xmin     is the smallest positive floating-point number.	in
		  particular,  xmin = ibeta ** minexp
      xmax     is the largest finite floating-point number.  in
		  particular   xmax = (1.0-epsneg) * ibeta ** maxexp
		  note - on some machines  xmax  will be only the
		  second, or perhaps third, largest number, being
		  too small by 1 or 2 units in the last digit of
		  the significand.

								    }

   i , iz , j , k , mx : integer ;
   a , b , beta , betain , betam1 , one , y , z , zero : real ;
   underflo : boolean;

begin
   irnd := 1 ;
   one := ( irnd );
   a := one + one ;
   b := a ;
   zero := 0.0 ;
{
      determine ibeta,beta ala Malcolm
								    }
   while ( ( ( a + one ) - a ) - one = zero ) do begin
      a := a + a ;
   end ;
   while ( ( a + b ) - a = zero ) do begin
      b := b + b ;
   end ;
   ibeta := trunc ( ( a + b ) - a );
   beta := ( ibeta );
   betam1 := beta - one ;
{
      determine irnd,ngrd,it
								    }
   if ( ( a + betam1 ) - a = zero ) then irnd := 0 ;
   it := 0 ;
   a := one ;
   repeat begin
      it := it + 1 ;
      a := a * beta ;
   end until ( ( ( a + one ) - a ) - one <> zero ) ;
{
      determine negep, epsneg
								    }
   negep := it + 3 ;
   a := one ;

   for i := 1 to negep do begin
      a := a / beta ;
   end ;

   while ( ( one - a ) - one = zero ) do begin
      a := a * beta ;
      negep := negep - 1 ;
   end ;
   negep := - negep ;
   epsneg := a ;
{
      determine machep, eps
								    }
   machep := negep ;
   while ( ( one + a ) - one = zero ) do begin
      a := a * beta ;
      machep := machep + 1 ;
   end ;
   eps := a ;
{
      determine ngrd
								    }
   ngrd := 0 ;
   if(( irnd = 0) and((( one + eps) * one - one) <> zero)) then
   ngrd := 1 ;
{
      determine iexp, minexp, xmin

      loop to determine largest i such that
	  (1/beta) ** (2**(i))
      does not underflow
      exit from loop is signall by an underflow
								    }
   i := 0 ;
   betain := one / beta ;
   z := betain ;
   underflo := false;
   repeat begin
      y := z ;
      z := y * y ;
{
      check for underflow
								    }
      if ( ( z * one = zero ) or ( abs ( z )> y ) ) then begin
	 underflo := true;
      end else begin
	 i := i + 1 ;
      end;
   end until underflo ;
   k := 1 ;
{
      determine k such that (1/beta)**k does not underflow

      first set k = 2 ** i
								    }

   for j := 1 to i do begin
      k := k + k ;
   end ;

   iexp := i + 1 ;
   mx := k + k ;
   if ( ibeta = 10 ) then begin
{
      for decimal machines only 				    }
      iexp := 2 ;
      iz := ibeta ;
      while ( k >= iz ) do begin
	 iz := iz * ibeta ;
	 iexp := iexp + 1 ;
      end ;
      mx := iz + iz - 1 ;
   end;
   underflo := false;
   repeat begin
{
      loop to construct xmin
      exit from loop is signalled by an underflow
								    }
      xmin := y ;
      y := y * betain ;
      if ( ( ( y * one ) = zero ) or ( abs ( y )> xmin ) )
      then begin
	 underflo := true;
      end else begin
	 k := k + 1 ;
      end;
   end until underflo ;
   minexp := - k ;
{  determine maxexp, xmax
								    }
   if ( ( mx <= k + k - 3 ) and ( ibeta <> 10 ) ) then begin
      mx := mx + mx ;
      iexp := iexp + 1 ;
   end;
   maxexp := mx + minexp ;
{  adjust for machines with implicit leading
   bit in binary significand and machines with
   radix point at extreme right of significand
								    }
   i := maxexp + minexp ;
   if ( ( ibeta = 2 ) and ( i = 0 ) ) then maxexp := maxexp - 1 ;
   if ( i > 20 ) then maxexp := maxexp - 3 ;
   xmax := one - epsneg ;
   if ( xmax * one <> xmax ) then xmax := one - beta * epsneg ;
   xmax := ( xmax * betain * betain * betain ) / xmin ;
   i := maxexp + minexp + 3 ;
   if  ( i > 0 ) then begin

      for j := 1 to i do begin
	 xmax := xmax * beta ;
      end ;
   end;

end;


function random : real ;

{     random number generator - based on algorithm 266
       by Pike and Hill (modified by Hansson)
       collected Alg. from CACM.

      This subprogram is intended for use on computers with
       fixed point wordlength of at least 29 bIts.  it is
       best if the floating point significand has at most
       29 bits. }

{     The quality of the random numbers is not important.
      If recoding is needed for small wordlength computers,
      even returning a constant value or zero is possible. }

{     The value iy is global, and is initialized in the driver }

begin
   iy := (iy*125) mod 2796203;
   random := ( iy )/ 2796203.0e0 ;
end;


function randl (x : real ) : real ;

{     returns pseudo random numbers logarithmically distributed
      over (1,exp(x)).	thus a*randl(ln(b/a)) is logarithmically
      distributed in (a,b).

      other subroutines required

	 exp(x) - the exponential routine

	 random - a function program returning random real
		  numbers uniformly distributed over (0,1).
								  }


begin
   randl := exp ( x * random );
end;


procedure printtestrun (n:integer; lb,ub:real;
			big,small : integer;
			mean,maxerror,xmaxerror,rmserror:real);
begin
   writeln(' ':5,n:4,' RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL')
      ;
   writeln(' ':10,'(',lb:15,',',ub:15,')');
   writeln;
   writeln(' ':5,'THE RESULT WAS TOO LARGE',big:5,' TIMES, AND');
   writeln(' ':10,'TOO SMALL',small:5,' TIMES');
   writeln;
   if (mean <> 0.0) then begin
      writeln(' ':5,'MEAN RELATIVE ERROR =',mean:15,'=',
	 IBETA:4,' ** ',LN(ABS(mean))/ALBETA:7:2);
   end;
   if (maxerror<> 0.0) then begin
      writeln(' ':5,'THE MAXIMUM RELATIVE ERROR OF',maxerror:15,'=',
	 IBETA:4,' ** ',LN(ABS(maxerror))/ALBETA:7:2);
      writeln(' ':10,'OCCURRED FOR X =',xmaxerror:15);
   end;
   if (rmserror <> 0.0) then begin
      writeln(' ':5,'ROOT-MEAN-SQUARE RELATIVE ERROR =',rmserror:15,
	 '=',IBETA:4,' ** ',LN(ABS(rmserror))/ALBETA:7:2);
   end;
   writeln;
end;   { OF PRINT TEST RUN }

begin

   machar ( ibeta , it , irnd , ngrd , machep , negep , iexp , minexp ,
      maxexp , eps , epsneg , xmin , xmax );
   beta := ( ibeta );
   sqbeta := sqrt ( beta );
   albeta := ln ( beta );
   a := 1.0 / sqbeta ;
   b := 1.0 ;
   n := 2000 ;
   iy := 100001;
{
      random argument accuracy tests
								      }
   for j := 1 to 2 do begin
      c := ln ( b / a );
      k := 0 ;
      k1 := 0 ;
      x1 := 0.0 ;
      r5 := 0.0 ;
      r6 := 0.0 ;
      r7 := 0.0 ;

      for i := 1 to n do begin
	 x := a * randl ( c ) ;
	 y := x * x ;
	 z := sqrt ( y );
	 w := ( z - x ) / x ;
	 if ( w > 0.0 ) then k := k + 1 ;
	 if ( w < 0.0 ) then k1 := k1 + 1 ;
	 r5 := r5 + w ;
	 w := abs ( w );
	 if ( w > r6 ) then begin
	    r6 := w ;
	    x1 := x ;
	 end;
	 r7 := r7 + w * w ;
      end ;

      xn := ( n );
      r5 := r5 / xn ;
      r7 := sqrt ( r7 / xn );
      writeln(' TEST OF SQRT(X*X) - X');
      writeln;
      printtestrun(n,a,b,k,k1,r5,r6,x1,r7);
      a := 1.0 ;
      b := sqbeta ;
   end ;
{
      special tests
								      }
   writeln(' TEST OF SPECIAL ARGUMENTS');
   writeln;
   x := xmin ;
   y := sqrt ( x );
   writeln(' SQRT(XMIN) = SQRT(',x:15,') = ',y:15);
   writeln;
   x := 1.0 - epsneg ;
   y := sqrt ( x );
   writeln(' SQRT(1-EPSNEG) = SQRT(1-', epsneg:15, ') = ',y:15);
   writeln;
   x := 1.0 ;
   y := sqrt ( x );
   writeln(' SQRT(1.0) = SQRT(', x:15, ') = ', y:15);
   writeln;
   x := 1.0 + eps ;
   y := sqrt ( x );
   writeln(' SQRT(1+EPS) = SQRT(1+',eps:15, ') = ', y:15);
   writeln;
   x := xmax ;
   y := sqrt ( x );
   writeln(' SQRT(XMAX) = SQRT(', x:15, ') = ', y:15);
   writeln;
   x := 0.0 ;
   y := sqrt ( x );
   writeln(' SQRT(0.0) = SQRT(',x:15,') = ', y:15);
   writeln;
{
      No tests for error conditions are made here.
      Test 6.6.6.2-5 calls sqrt with a negative argument.

							      }
   writeln(' THIS CONCLUDES THE TESTS');
end.
{TEST 6.6.6.2-7, CLASS=QUALITY}

{ This test checks the implementation of the function arctan. }

program t6p6p6p2d7(output);

var


{     data required

	 none

      subprograms required from this package

	 machar -  as for sqrtest
	 random -  as for sqrtest

      standard subprograms required

	  abs, ln, arctan,  sqrt			  }

   i , ibeta , iexp ,  irnd , ii , it , i1 , j , k , k1 , machep ,
   iy , maxexp , minexp , n , negep , ngrd : integer ;
   a , albeta , b , beta , betap , del , em , eps , epsneg , expon ,
   half , ob32 , one , r5 , r6 , r7 , sum , w , x , xl , xmax , xmin ,
   xn , xsq , x1 , y , z , zero , zz : real ;

procedure machar (var ibeta , it , irnd , ngrd , machep , negep , iexp,
  minexp , maxexp : integer ; var eps , epsneg , xmin , xmax : real ) ;

var


{     This subroutine is intended to determine the characteristics
      of the floating-point arithmetic system that are specified
      below.  The first three are determined according to an
      algorithm due to M. Malcolm, CACM 15 (1972), pp. 949-951,
      incorporating some, but not all, of the improvements
      suggested by M. Gentleman and S. Marovich, CACM 17 (1974),
      pp. 276-277.  The version given here is for single precision.

      Latest revision - October 1, 1976.

      Author - W. J. Cody
	       Argonne National Laboratory

      Revised for Pascal - R. A. Freak
			   University of Tasmania
			   Hobart
			   Tasmania

      ibeta    is the radix of the floating-point representation
      it       is the number of base ibeta digits in the floating-point
		  significand
      irnd     =  0 if the arithmetic chops,
		  1 if the arithmetic rounds
      ngrd     =  0 if	irnd=1, or if  irnd=0  and only  it  base ibeta
		    digits participate in the post normalization shift
		    of the floating-point significand in multiplication
		  1 if	irnd=0	and more than  it  base  ibeta	digits
		    participate in the post normalization shift of the
		    floating-point significand in multiplication
      machep   is the exponent on the smallest positive floating-point
		  number  eps such that  1.0+eps <> 1.0
      negeps   is the exponent on the smallest positive fl. pt. no.
		  negeps such that  1.0-negeps <> 1.0, except that
		  negeps is bounded below by  it-3
      iexp     is the number of bits (decimal places if ibeta = 10)
		  reserved for the representation of the exponent of
		  a floating-point number
      minexp   is the exponent of the smallest positive fl. pt. no.
		  xmin
      maxexp   is the exponent of the largest finite floating-point
		  number  xmax
      eps      is the smallest positive floating-point number such
		  that	1.0+eps <> 1.0. in particular,
		  eps = ibeta**machep
      epsneg   is the smallest positive floating-point number such
		  that	1.0-eps <> 1.0	(except that the exponent
		  negeps is bounded below by it-3).  in particular
		  epsneg = ibeta**negep
      xmin     is the smallest positive floating-point number.	in
		  particular,  xmin = ibeta ** minexp
      xmax     is the largest finite floating-point number.  in
		  particular   xmax = (1.0-epsneg) * ibeta ** maxexp
		  note - on some machines  xmax  will be only the
		  second, or perhaps third, largest number, being
		  too small by 1 or 2 units in the last digit of
		  the significand.

								    }

   i , iz , j , k , mx : integer ;
   a , b , beta , betain , betam1 , one , y , z , zero : real ;
   underflo : boolean;

begin
   irnd := 1 ;
   one := ( irnd );
   a := one + one ;
   b := a ;
   zero := 0.0 ;
{
      determine ibeta,beta ala Malcolm
								    }
   while ( ( ( a + one ) - a ) - one = zero ) do begin
      a := a + a ;
   end ;
   while ( ( a + b ) - a = zero ) do begin
      b := b + b ;
   end ;
   ibeta := trunc ( ( a + b ) - a );
   beta := ( ibeta );
   betam1 := beta - one ;
{
      determine irnd,ngrd,it
								    }
   if ( ( a + betam1 ) - a = zero ) then irnd := 0 ;
   it := 0 ;
   a := one ;
   repeat begin
      it := it + 1 ;
      a := a * beta ;
   end until ( ( ( a + one ) - a ) - one <> zero ) ;
{
      determine negep, epsneg
								    }
   negep := it + 3 ;
   a := one ;

   for i := 1 to negep do begin
      a := a / beta ;
   end ;

   while ( ( one - a ) - one = zero ) do begin
      a := a * beta ;
      negep := negep - 1 ;
   end ;
   negep := - negep ;
   epsneg := a ;
{
      determine machep, eps
								    }
   machep := negep ;
   while ( ( one + a ) - one = zero ) do begin
      a := a * beta ;
      machep := machep + 1 ;
   end ;
   eps := a ;
{
      determine ngrd
								    }
   ngrd := 0 ;
   if(( irnd = 0) and((( one + eps) * one - one) <> zero)) then
   ngrd := 1 ;
{
      determine iexp, minexp, xmin

      loop to determine largest i such that
	  (1/beta) ** (2**(i))
      does not underflow
      exit from loop is signall by an underflow
								    }
   i := 0 ;
   betain := one / beta ;
   z := betain ;
   underflo := false;
   repeat begin
      y := z ;
      z := y * y ;
{
      check for underflow
								    }
      if ( ( z * one = zero ) or ( abs ( z )> y ) ) then begin
	 underflo := true;
      end else begin
	 i := i + 1 ;
      end;
   end until underflo ;
   k := 1 ;
{
      determine k such that (1/beta)**k does not underflow

      first set k = 2 ** i
								    }

   for j := 1 to i do begin
      k := k + k ;
   end ;

   iexp := i + 1 ;
   mx := k + k ;
   if ( ibeta = 10 ) then begin
{
      for decimal machines only 				    }
      iexp := 2 ;
      iz := ibeta ;
      while ( k >= iz ) do begin
	 iz := iz * ibeta ;
	 iexp := iexp + 1 ;
      end ;
      mx := iz + iz - 1 ;
   end;
   underflo := false;
   repeat begin
{
      loop to construct xmin
      exit from loop is signalled by an underflow
								    }
      xmin := y ;
      y := y * betain ;
      if ( ( ( y * one ) = zero ) or ( abs ( y )> xmin ) )
      then begin
	 underflo := true;
      end else begin
	 k := k + 1 ;
      end;
   end until underflo ;
   minexp := - k ;
{  determine maxexp, xmax
								    }
   if ( ( mx <= k + k - 3 ) and ( ibeta <> 10 ) ) then begin
      mx := mx + mx ;
      iexp := iexp + 1 ;
   end;
   maxexp := mx + minexp ;
{  adjust for machines with implicit leading
   bit in binary significand and machines with
   radix point at extreme right of significand
								    }
   i := maxexp + minexp ;
   if ( ( ibeta = 2 ) and ( i = 0 ) ) then maxexp := maxexp - 1 ;
   if ( i > 20 ) then maxexp := maxexp - 3 ;
   xmax := one - epsneg ;
   if ( xmax * one <> xmax ) then xmax := one - beta * epsneg ;
   xmax := ( xmax * betain * betain * betain ) / xmin ;
   i := maxexp + minexp + 3 ;
   if  ( i > 0 ) then begin

      for j := 1 to i do begin
	 xmax := xmax * beta ;
      end ;
   end;

end;


function random : real ;

{     random number generator - based on algorithm 266
       by Pike and Hill (modified by Hansson)
       collected Alg. from CACM.

      This subprogram is intended for use on computers with
       fixed point wordlength of at least 29 bIts.  it is
       best if the floating point significand has at most
       29 bits. }

{     The quality of the random numbers is not important.
      If recoding is needed for small wordlength computers,
      even returning a constant value or zero is possible. }

{     The value iy is global, and is initialized in the driver }

begin
   iy := (iy*125) mod 2796203;
   random := ( iy )/ 2796203.0e0 ;
end;


procedure printtestrun (n:integer; lb,ub:real;
			big,small : integer;
			mean,maxerror,xmaxerror,rmserror:real);
begin
   writeln(' ':5,n:4,' RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL')
      ;
   writeln(' ':10,'(',lb:15,',',ub:15,')');
   writeln;
   writeln(' ':5,'THE RESULT WAS TOO LARGE',big:5,' TIMES, AND');
   writeln(' ':10,'TOO SMALL',small:5,' TIMES');
   writeln;
   if (mean <> 0.0) then begin
      writeln(' ':5,'MEAN RELATIVE ERROR =',mean:15,'=',
	 IBETA:4,' ** ',LN(ABS(mean))/ALBETA:7:2);
   end;
   if (maxerror<> 0.0) then begin
      writeln(' ':5,'THE MAXIMUM RELATIVE ERROR OF',maxerror:15,'=',
	 IBETA:4,' ** ',LN(ABS(maxerror))/ALBETA:7:2);
      writeln(' ':10,'OCCURRED FOR X =',xmaxerror:15);
   end;
   if (rmserror <> 0.0) then begin
      writeln(' ':5,'ROOT-MEAN-SQUARE RELATIVE ERROR =',rmserror:15,
	 '=',IBETA:4,' ** ',LN(ABS(rmserror))/ALBETA:7:2);
   end;
   writeln;
end;   { OF PRINT TEST RUN }


begin
   iy := 100001;
   machar ( ibeta , it , irnd , ngrd , machep , negep , iexp , minexp ,
      maxexp , eps , epsneg , xmin , xmax );
   beta := ( ibeta );
   albeta := ln ( beta );
   one := 1.0 ;
   half := 0.5 ;
   zero := 0.0 ;
   a := - 0.0625 ;
   b := - a ;
   ob32 := b * half ;
   n := 2000 ;
   xn := ( n );
   i1 := 0 ;
{
      random argument accuracy tests
								      }
   for j := 1 to 4 do begin
      k := 0 ;
      k1 := 0 ;
      x1 := zero ;
      r5 := zero ;
      r6 := zero ;
      r7 := zero ;
      del := ( b - a ) / xn ;
      xl := a ;

      for i := 1 to n do begin
	 x := del * random + xl ;
	 if ( j = 2 ) then x := ( ( 1.0 + x * a ) - one ) * 16.0 ;
	 z := arctan ( x );
	 case j of
	 1:
	    begin
	       xsq := x * x ;
	       em := 17.0 ;
	       sum := xsq / em ;

	       for ii := 1 to 7 do begin
		  em := em - 2.0 ;
		  sum := ( one / em - sum ) * xsq ;
	       end ;

	       zz := x - x * sum ;
	    end;
	 2:
	    begin
	       y := x - 0.0625 ;
	       y := y / ( one + x * a ) ;
	       zz := ( arctan ( y )- 8.1190004042651526021e-5 ) +
		  ob32 ;
	       zz := zz + ob32 ;
	    end;
	 3,4:
	    begin
	       z := z + z ;
	       y := x / ( ( half + x * half ) * ( ( half - x ) + half )
		  ) ;
	       zz := arctan ( y );
	    end;
	 end;
	 w := ( z - zz ) / z ;
	 if ( w > zero ) then k := k + 1 ;
	 if ( w < zero ) then k1 := k1 + 1 ;
	 r5 := r5 + w ;
	 w := abs ( w );
	 if ( w > r6 ) then begin
	    r6 := w ;
	    x1 := x ;
	 end;
	 r7 := r7 + w * w ;
	 xl := xl + del ;
      end ;

      r5 := r5 / xn ;
      r7 := sqrt ( r7 / xn );
      if ( j = 1 ) then begin
	 writeln(' TEST OF ARCTAN(X) VS TRUNCATED TAYLOR SERIES');
	 writeln;
      end;
      if ( j = 2 ) then begin
	 write(' TEST OF ARCTAN(X) VS ARCTAN(1/16) + ');
	 writeln(' ARCTAN((X-1/16)/(1+X/16))');
	 writeln;
      end;
      if ( j > 2 ) then begin
	 writeln(' TEST OF 2*ARCTAN(X) VS ARCTAN(2X/(1-X*X))');
	 writeln;
      end;
      printtestrun(n,a,b,k,k1,r5,r6,x1,r7);
      a := b ;
      if ( j = 1 ) then b := 2.0 - sqrt ( 3.0 );
      if ( j = 2 ) then b := sqrt ( 2.0 )- one ;
      if ( j = 3 ) then b := one ;
   end ;
{
      special tests
								      }
   writeln(' THE IDENTITY ARCTAN(-X) = -ARCTAN(X) WILL BE TESTED');
   writeln(' ':7, 'X', ' ':9, 'F(X) + F(-X)');
   writeln;
   a := 5.0 ;

   for i := 1 to 5 do begin
      x := random * a ;
      z := arctan ( x )+ arctan ( - x );
      writeln(x:14, z:15);
   end ;
   writeln;

   writeln(' THE IDENTITY ARCTAN(X) = X, X SMALL, WILL BE TESTED');
   writeln(' ':7, 'X', ' ':9, 'X - F(X)');
   writeln;
   betap := exp ( it * ln( beta ));
   x := random / betap ;

   for i := 1 to 5 do begin
      z := x - arctan ( x );
      writeln(x:14, z:15);
      x := x / beta ;
   end ;
   writeln;
   writeln;

   writeln(' TEST OF UNDERFLOW FOR A VERY SMALL ARGUMENT');
   writeln;
   expon := ( minexp )* 0.75 ;
   x := exp ( expon * ln( beta ));
   y := arctan ( x );
   writeln(' ':5, ' ARCTAN(', x:13, ') = ', y:13);
   writeln;
   write(' THE FUNCTION WILL BE CALLED WITH THE ARGUMENT');
   writeln(xmax:15);
   z := arctan ( xmax );
   writeln(' ':5, ' ARCTAN(', xmax:13, ') = ', z:13);
   writeln;
   writeln(' THIS CONCLUDES THE TESTS');
end.
{TEST 6.6.6.2-8, CLASS=QUALITY}

{ This test checks the implementation of the exp function. }

program t6p6p6p2d8(output);

var


{     data required

	 none

      other subprograms in this package

	 machar -  as for sqrtest
	 random -  as for sqrtest


      standard subprograms required

	 abs, ln, exp, sqrt
								      }

   i , ibeta , iexp ,  irnd , it , i1 , j , k , k1 , machep ,
   iy , maxexp , minexp , n , negep , ngrd : integer ;
   a , albeta , b , beta , d , del , eps , epsneg , r5 , r6 , r7 , v ,
   w , x , xl , xmax , xmin , xn , x1 , y , z , zz : real ;

procedure machar (var ibeta , it , irnd , ngrd , machep , negep , iexp,
  minexp , maxexp : integer ; var eps , epsneg , xmin , xmax : real ) ;

var


{     This subroutine is intended to determine the characteristics
      of the floating-point arithmetic system that are specified
      below.  The first three are determined according to an
      algorithm due to M. Malcolm, CACM 15 (1972), pp. 949-951,
      incorporating some, but not all, of the improvements
      suggested by M. Gentleman and S. Marovich, CACM 17 (1974),
      pp. 276-277.  The version given here is for single precision.

      Latest revision - October 1, 1976.

      Author - W. J. Cody
	       Argonne National Laboratory

      Revised for Pascal - R. A. Freak
			   University of Tasmania
			   Hobart
			   Tasmania

      ibeta    is the radix of the floating-point representation
      it       is the number of base ibeta digits in the floating-point
		  significand
      irnd     =  0 if the arithmetic chops,
		  1 if the arithmetic rounds
      ngrd     =  0 if	irnd=1, or if  irnd=0  and only  it  base ibeta
		    digits participate in the post normalization shift
		    of the floating-point significand in multiplication
		  1 if	irnd=0	and more than  it  base  ibeta	digits
		    participate in the post normalization shift of the
		    floating-point significand in multiplication
      machep   is the exponent on the smallest positive floating-point
		  number  eps such that  1.0+eps <> 1.0
      negeps   is the exponent on the smallest positive fl. pt. no.
		  negeps such that  1.0-negeps <> 1.0, except that
		  negeps is bounded below by  it-3
      iexp     is the number of bits (decimal places if ibeta = 10)
		  reserved for the representation of the exponent of
		  a floating-point number
      minexp   is the exponent of the smallest positive fl. pt. no.
		  xmin
      maxexp   is the exponent of the largest finite floating-point
		  number  xmax
      eps      is the smallest positive floating-point number such
		  that	1.0+eps <> 1.0. in particular,
		  eps = ibeta**machep
      epsneg   is the smallest positive floating-point number such
		  that	1.0-eps <> 1.0	(except that the exponent
		  negeps is bounded below by it-3).  in particular
		  epsneg = ibeta**negep
      xmin     is the smallest positive floating-point number.	in
		  particular,  xmin = ibeta ** minexp
      xmax     is the largest finite floating-point number.  in
		  particular   xmax = (1.0-epsneg) * ibeta ** maxexp
		  note - on some machines  xmax  will be only the
		  second, or perhaps third, largest number, being
		  too small by 1 or 2 units in the last digit of
		  the significand.

								    }

   i , iz , j , k , mx : integer ;
   a , b , beta , betain , betam1 , one , y , z , zero : real ;
   underflo : boolean;

begin
   irnd := 1 ;
   one := ( irnd );
   a := one + one ;
   b := a ;
   zero := 0.0 ;
{
      determine ibeta,beta ala Malcolm
								    }
   while ( ( ( a + one ) - a ) - one = zero ) do begin
      a := a + a ;
   end ;
   while ( ( a + b ) - a = zero ) do begin
      b := b + b ;
   end ;
   ibeta := trunc ( ( a + b ) - a );
   beta := ( ibeta );
   betam1 := beta - one ;
{
      determine irnd,ngrd,it
								    }
   if ( ( a + betam1 ) - a = zero ) then irnd := 0 ;
   it := 0 ;
   a := one ;
   repeat begin
      it := it + 1 ;
      a := a * beta ;
   end until ( ( ( a + one ) - a ) - one <> zero ) ;
{
      determine negep, epsneg
								    }
   negep := it + 3 ;
   a := one ;

   for i := 1 to negep do begin
      a := a / beta ;
   end ;

   while ( ( one - a ) - one = zero ) do begin
      a := a * beta ;
      negep := negep - 1 ;
   end ;
   negep := - negep ;
   epsneg := a ;
{
      determine machep, eps
								    }
   machep := negep ;
   while ( ( one + a ) - one = zero ) do begin
      a := a * beta ;
      machep := machep + 1 ;
   end ;
   eps := a ;
{
      determine ngrd
								    }
   ngrd := 0 ;
   if(( irnd = 0) and((( one + eps) * one - one) <> zero)) then
   ngrd := 1 ;
{
      determine iexp, minexp, xmin

      loop to determine largest i such that
	  (1/beta) ** (2**(i))
      does not underflow
      exit from loop is signall by an underflow
								    }
   i := 0 ;
   betain := one / beta ;
   z := betain ;
   underflo := false;
   repeat begin
      y := z ;
      z := y * y ;
{
      check for underflow
								    }
      if ( ( z * one = zero ) or ( abs ( z )> y ) ) then begin
	 underflo := true;
      end else begin
	 i := i + 1 ;
      end;
   end until underflo ;
   k := 1 ;
{
      determine k such that (1/beta)**k does not underflow

      first set k = 2 ** i
								    }

   for j := 1 to i do begin
      k := k + k ;
   end ;

   iexp := i + 1 ;
   mx := k + k ;
   if ( ibeta = 10 ) then begin
{
      for decimal machines only 				    }
      iexp := 2 ;
      iz := ibeta ;
      while ( k >= iz ) do begin
	 iz := iz * ibeta ;
	 iexp := iexp + 1 ;
      end ;
      mx := iz + iz - 1 ;
   end;
   underflo := false;
   repeat begin
{
      loop to construct xmin
      exit from loop is signalled by an underflow
								    }
      xmin := y ;
      y := y * betain ;
      if ( ( ( y * one ) = zero ) or ( abs ( y )> xmin ) )
      then begin
	 underflo := true;
      end else begin
	 k := k + 1 ;
      end;
   end until underflo ;
   minexp := - k ;
{  determine maxexp, xmax
								    }
   if ( ( mx <= k + k - 3 ) and ( ibeta <> 10 ) ) then begin
      mx := mx + mx ;
      iexp := iexp + 1 ;
   end;
   maxexp := mx + minexp ;
{  adjust for machines with implicit leading
   bit in binary significand and machines with
   radix point at extreme right of significand
								    }
   i := maxexp + minexp ;
   if ( ( ibeta = 2 ) and ( i = 0 ) ) then maxexp := maxexp - 1 ;
   if ( i > 20 ) then maxexp := maxexp - 3 ;
   xmax := one - epsneg ;
   if ( xmax * one <> xmax ) then xmax := one - beta * epsneg ;
   xmax := ( xmax * betain * betain * betain ) / xmin ;
   i := maxexp + minexp + 3 ;
   if  ( i > 0 ) then begin

      for j := 1 to i do begin
	 xmax := xmax * beta ;
      end ;
   end;

end;


function random : real ;

{     random number generator - based on algorithm 266
       by Pike and Hill (modified by Hansson)
       collected Alg. from CACM.

      This subprogram is intended for use on computers with
       fixed point wordlength of at least 29 bIts.  it is
       best if the floating point significand has at most
       29 bits. }

{     The quality of the random numbers is not important.
      If recoding is needed for small wordlength computers,
      even returning a constant value or zero is possible. }

{     The value iy is global, and is initialized in the driver }

begin
   iy := (iy*125) mod 2796203;
   random := ( iy )/ 2796203.0e0 ;
end;


procedure printtestrun (n:integer; lb,ub:real;
			big,small : integer;
			mean,maxerror,xmaxerror,rmserror:real);
begin
   writeln(' ':5,n:4,' RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL')
      ;
   writeln(' ':10,'(',lb:15,',',ub:15,')');
   writeln;
   writeln(' ':5,'THE RESULT WAS TOO LARGE',big:5,' TIMES, AND');
   writeln(' ':10,'TOO SMALL',small:5,' TIMES');
   writeln;
   if (mean <> 0.0) then begin
      writeln(' ':5,'MEAN RELATIVE ERROR =',mean:15,'=',
	 IBETA:4,' ** ',LN(ABS(mean))/ALBETA:7:2);
   end;
   if (maxerror<> 0.0) then begin
      writeln(' ':5,'THE MAXIMUM RELATIVE ERROR OF',maxerror:15,'=',
	 IBETA:4,' ** ',LN(ABS(maxerror))/ALBETA:7:2);
      writeln(' ':10,'OCCURRED FOR X =',xmaxerror:15);
   end;
   if (rmserror <> 0.0) then begin
      writeln(' ':5,'ROOT-MEAN-SQUARE RELATIVE ERROR =',rmserror:15,
	 '=',IBETA:4,' ** ',LN(ABS(rmserror))/ALBETA:7:2);
   end;
   writeln;
end;   { OF PRINT TEST RUN }


begin
   iy := 100001;
   machar ( ibeta , it , irnd , ngrd , machep , negep , iexp , minexp ,
      maxexp , eps , epsneg , xmin , xmax );
   beta := ( ibeta );
   albeta := ln ( beta );
   v := 0.0625 ;
   a := 2.0 ;
   b := ln ( a )* 0.5 ;
   a := - b + v ;
   d := 0.9 * xmax ;
   d := ln ( d );
   n := 2000 ;
   xn := ( n );
   i1 := 0 ;
{
      random argument accuracy tests
								      }
   for j := 1 to 3 do begin
      k := 0 ;
      k1 := 0 ;
      x1 := 0.0 ;
      r5 := 0.0 ;
      r6 := 0.0 ;
      r7 := 0.0 ;
      del := ( b - a ) / xn ;
      xl := a ;

      for i := 1 to n do begin
	 x := del * random + xl ;
	 y := x - v ;
	 if ( y < 0.0 ) then x := y + v ;
	 z := exp ( x );
	 zz := exp ( y );
	 if ( j = 1 ) then begin
	    z := z - z * 6.058693718652421388e-2 ;
	 end else begin
	    if ( ibeta = 10 ) then z := z * 6.0e-2 + z *
	       5.466789530794296106e-5
	    else z := z * 0.0625 - z *
	       2.4453321046920570389e-3 ;
	 end;
	 w := ( z - zz ) / zz ;
	 if ( w < 0.0 ) then k := k + 1 ;
	 if ( w > 0.0 ) then k1 := k1 + 1 ;
	 r5 := r5 + w ;
	 w := abs ( w );
	 if ( w > r6 ) then begin
	    r6 := w ;
	    x1 := x ;
	 end;
	 r7 := r7 + w * w ;
	 xl := xl + del ;
      end ;

      r5 := r5 / xn ;
      r7 := sqrt ( r7 / xn );
      writeln(' TEST OF EXP(X-', v:7:4, ') VS EXP(X)/EXP(', v:7:4, ')')
      writeln;
      printtestrun(n,a,b,k,k1,r5,r6,x1,r7);
      if ( j = 2 ) then begin
	 a := - 2.0 * a ;
	 b := 10.0 * a ;
	 if ( b < d ) then b := d ;
      end else begin
	 v := 45.0 / 16.0 ;
	 a := - 10.0 * b ;
	 b := 4.0 * xmin * exp ( it * ln( beta ));
	 b := ln ( b );
      end;
   end ;
{
      special tests
								      }
   writeln(' THE IDENTITY EXP(X) * EXP(-X) - 1.0 WILL BE TESTED.');
   writeln(' ':7,'X', ' ':9, 'F(X)*F(-X) - 1');
   writeln;

   for i := 1 to 5 do begin
      x := random * beta ;
      y := - x ;
      z := exp ( x )* exp ( y )- 1.0 ;
      writeln(x:15, z:15);
   end ;
   writeln;
   writeln(' TEST OF SPECIAL ARGUMENTS');
   writeln;
   x := 0.0 ;
   y := exp ( x )- 1.0 ;
   writeln(' EXP(0.0) - 1.0 = ', y:15);
   writeln;
   x := trunc ( ln ( xmin ));
   y := exp ( x );
   writeln(' EXP(', x:13, ') = ', z:15);
   writeln;
   x := trunc ( ln ( xmax ));
   y := exp ( x );
   writeln(' EXP(', x:13, ') = ', y:15);
   writeln;
   x := x / 2.0 ;
   v := x / 2.0 ;
   y := exp ( x );
   z := exp ( v );
   z := z * z ;
   writeln(' IF EXP(', x:13, ') = ', y:15, ' IS NOT ABOUT');
   write(' EXP(', v:13, ')**2 = ', z:15, ' THERE IS AN ARGUMENT');
   writeln(' REDUCTION ERROR');
   writeln;
{
      test of error returns
								      }
   writeln(' TEST OF ERROR RETURNS');
   writeln;
   x := - 1.0 / sqrt ( xmin );
   writeln(' EXP WILL BE CALLED WITH THE ARGUMENT', x:15);
   writeln(' THIS SHOULD UNDERFLOW AND MAYBE PRODUCE ZERO OR AN ERROR')
   ;
   writeln;
   y := exp ( x );
   writeln(' EXP RETURNED THE VALUE', y:15);
   writeln;
   writeln(' THIS CONCLUDES THE TESTS');
end.
{TEST 6.6.6.2-9, CLASS=QUALITY}

{ This test checks the implementation of the sin and cos functions. }

program t6p6p6p2d9(output);

var


{     data required

	 none

      other subprograms in this package

	 machar -  as for sqrtest
	 random -  as for sqrtest


      standard subprograms required

	 abs, ln, exp, cos, sin, sqrt
								      }

   i , ibeta , iexp ,  irnd , it , i1 , j , k , k1 , machep ,
   iy , maxexp , minexp , n , negep , ngrd : integer ;
   a , albeta , b , beta , betap , c , del , eps , epsneg , expon , r5,
   r6 , r7 , w , x , xl , xmax , xmin , xn , x1 , y , z , zz : real ;

procedure machar (var ibeta , it , irnd , ngrd , machep , negep , iexp,
  minexp , maxexp : integer ; var eps , epsneg , xmin , xmax : real ) ;

var


{     This subroutine is intended to determine the characteristics
      of the floating-point arithmetic system that are specified
      below.  The first three are determined according to an
      algorithm due to M. Malcolm, CACM 15 (1972), pp. 949-951,
      incorporating some, but not all, of the improvements
      suggested by M. Gentleman and S. Marovich, CACM 17 (1974),
      pp. 276-277.  The version given here is for single precision.

      Latest revision - October 1, 1976.

      Author - W. J. Cody
	       Argonne National Laboratory

      Revised for Pascal - R. A. Freak
			   University of Tasmania
			   Hobart
			   Tasmania

      ibeta    is the radix of the floating-point representation
      it       is the number of base ibeta digits in the floating-point
		  significand
      irnd     =  0 if the arithmetic chops,
		  1 if the arithmetic rounds
      ngrd     =  0 if	irnd=1, or if  irnd=0  and only  it  base ibeta
		    digits participate in the post normalization shift
		    of the floating-point significand in multiplication
		  1 if	irnd=0	and more than  it  base  ibeta	digits
		    participate in the post normalization shift of the
		    floating-point significand in multiplication
      machep   is the exponent on the smallest positive floating-point
		  number  eps such that  1.0+eps <> 1.0
      negeps   is the exponent on the smallest positive fl. pt. no.
		  negeps such that  1.0-negeps <> 1.0, except that
		  negeps is bounded below by  it-3
      iexp     is the number of bits (decimal places if ibeta = 10)
		  reserved for the representation of the exponent of
		  a floating-point number
      minexp   is the exponent of the smallest positive fl. pt. no.
		  xmin
      maxexp   is the exponent of the largest finite floating-point
		  number  xmax
      eps      is the smallest positive floating-point number such
		  that	1.0+eps <> 1.0. in particular,
		  eps = ibeta**machep
      epsneg   is the smallest positive floating-point number such
		  that	1.0-eps <> 1.0	(except that the exponent
		  negeps is bounded below by it-3).  in particular
		  epsneg = ibeta**negep
      xmin     is the smallest positive floating-point number.	in
		  particular,  xmin = ibeta ** minexp
      xmax     is the largest finite floating-point number.  in
		  particular   xmax = (1.0-epsneg) * ibeta ** maxexp
		  note - on some machines  xmax  will be only the
		  second, or perhaps third, largest number, being
		  too small by 1 or 2 units in the last digit of
		  the significand.

								    }

   i , iz , j , k , mx : integer ;
   a , b , beta , betain , betam1 , one , y , z , zero : real ;
   underflo : boolean;

begin
   irnd := 1 ;
   one := ( irnd );
   a := one + one ;
   b := a ;
   zero := 0.0 ;
{
      determine ibeta,beta ala Malcolm
								    }
   while ( ( ( a + one ) - a ) - one = zero ) do begin
      a := a + a ;
   end ;
   while ( ( a + b ) - a = zero ) do begin
      b := b + b ;
   end ;
   ibeta := trunc ( ( a + b ) - a );
   beta := ( ibeta );
   betam1 := beta - one ;
{
      determine irnd,ngrd,it
								    }
   if ( ( a + betam1 ) - a = zero ) then irnd := 0 ;
   it := 0 ;
   a := one ;
   repeat begin
      it := it + 1 ;
      a := a * beta ;
   end until ( ( ( a + one ) - a ) - one <> zero ) ;
{
      determine negep, epsneg
								    }
   negep := it + 3 ;
   a := one ;

   for i := 1 to negep do begin
      a := a / beta ;
   end ;

   while ( ( one - a ) - one = zero ) do begin
      a := a * beta ;
      negep := negep - 1 ;
   end ;
   negep := - negep ;
   epsneg := a ;
{
      determine machep, eps
								    }
   machep := negep ;
   while ( ( one + a ) - one = zero ) do begin
      a := a * beta ;
      machep := machep + 1 ;
   end ;
   eps := a ;
{
      determine ngrd
								    }
   ngrd := 0 ;
   if(( irnd = 0) and((( one + eps) * one - one) <> zero)) then
   ngrd := 1 ;
{
      determine iexp, minexp, xmin

      loop to determine largest i such that
	  (1/beta) ** (2**(i))
      does not underflow
      exit from loop is signall by an underflow
								    }
   i := 0 ;
   betain := one / beta ;
   z := betain ;
   underflo := false;
   repeat begin
      y := z ;
      z := y * y ;
{
      check for underflow
								    }
      if ( ( z * one = zero ) or ( abs ( z )> y ) ) then begin
	 underflo := true;
      end else begin
	 i := i + 1 ;
      end;
   end until underflo ;
   k := 1 ;
{
      determine k such that (1/beta)**k does not underflow

      first set k = 2 ** i
								    }

   for j := 1 to i do begin
      k := k + k ;
   end ;

   iexp := i + 1 ;
   mx := k + k ;
   if ( ibeta = 10 ) then begin
{
      for decimal machines only 				    }
      iexp := 2 ;
      iz := ibeta ;
      while ( k >= iz ) do begin
	 iz := iz * ibeta ;
	 iexp := iexp + 1 ;
      end ;
      mx := iz + iz - 1 ;
   end;
   underflo := false;
   repeat begin
{
      loop to construct xmin
      exit from loop is signalled by an underflow
								    }
      xmin := y ;
      y := y * betain ;
      if ( ( ( y * one ) = zero ) or ( abs ( y )> xmin ) )
      then begin
	 underflo := true;
      end else begin
	 k := k + 1 ;
      end;
   end until underflo ;
   minexp := - k ;
{  determine maxexp, xmax
								    }
   if ( ( mx <= k + k - 3 ) and ( ibeta <> 10 ) ) then begin
      mx := mx + mx ;
      iexp := iexp + 1 ;
   end;
   maxexp := mx + minexp ;
{  adjust for machines with implicit leading
   bit in binary significand and machines with
   radix point at extreme right of significand
								    }
   i := maxexp + minexp ;
   if ( ( ibeta = 2 ) and ( i = 0 ) ) then maxexp := maxexp - 1 ;
   if ( i > 20 ) then maxexp := maxexp - 3 ;
   xmax := one - epsneg ;
   if ( xmax * one <> xmax ) then xmax := one - beta * epsneg ;
   xmax := ( xmax * betain * betain * betain ) / xmin ;
   i := maxexp + minexp + 3 ;
   if  ( i > 0 ) then begin

      for j := 1 to i do begin
	 xmax := xmax * beta ;
      end ;
   end;

end;


function random : real ;

{     random number generator - based on algorithm 266
       by Pike and Hill (modified by Hansson)
       collected Alg. from CACM.

      This subprogram is intended for use on computers with
       fixed point wordlength of at least 29 bIts.  it is
       best if the floating point significand has at most
       29 bits. }

{     The quality of the random numbers is not important.
      If recoding is needed for small wordlength computers,
      even returning a constant value or zero is possible. }

{     The value iy is global, and is initialized in the driver }

begin
   iy := (iy*125) mod 2796203;
   random := ( iy )/ 2796203.0e0 ;
end;


procedure printtestrun (n:integer; lb,ub:real;
			big,small : integer;
			mean,maxerror,xmaxerror,rmserror:real);
begin
   writeln(' ':5,n:4,' RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL')
      ;
   writeln(' ':10,'(',lb:15,',',ub:15,')');
   writeln;
   writeln(' ':5,'THE RESULT WAS TOO LARGE',big:5,' TIMES, AND');
   writeln(' ':10,'TOO SMALL',small:5,' TIMES');
   writeln;
   if (mean <> 0.0) then begin
      writeln(' ':5,'MEAN RELATIVE ERROR =',mean:15,'=',
	 IBETA:4,' ** ',LN(ABS(mean))/ALBETA:7:2);
   end;
   if (maxerror<> 0.0) then begin
      writeln(' ':5,'THE MAXIMUM RELATIVE ERROR OF',maxerror:15,'=',
	 IBETA:4,' ** ',LN(ABS(maxerror))/ALBETA:7:2);
      writeln(' ':10,'OCCURRED FOR X =',xmaxerror:15);
   end;
   if (rmserror <> 0.0) then begin
      writeln(' ':5,'ROOT-MEAN-SQUARE RELATIVE ERROR =',rmserror:15,
	 '=',IBETA:4,' ** ',LN(ABS(rmserror))/ALBETA:7:2);
   end;
   writeln;
end;   { OF PRINT TEST RUN }


begin
   iy := 100001;
   machar ( ibeta , it , irnd , ngrd , machep , negep , iexp , minexp ,
      maxexp , eps , epsneg , xmin , xmax );
   beta := ( ibeta );
   albeta := ln ( beta );
   a := 0.0 ;
   b := 1.570796327 ;
   c := b ;
   n := 2000 ;
   xn := ( n );
   i1 := 0 ;
{
      random argument accuracy tests
								      }
   for j := 1 to 3 do begin
      k := 0 ;
      k1 := 0 ;
      x1 := 0.0 ;
      r5 := 0.0 ;
      r6 := 0.0 ;
      r7 := 0.0 ;
      del := ( b - a ) / xn ;
      xl := a ;

      for i := 1 to n do begin
	 x := del * random + xl ;
	 y := x / 3.0 ;
	 y := ( x + y ) - x ;
	 x := 3.0 * y ;
	 if ( j = 3 ) then begin
	    z := cos ( x );
	    zz := cos ( y );
	    w := ( z + zz * ( 3.0 - 4.0 * zz * zz ) ) / z ;
	 end else begin
	    z := sin ( x );
	    zz := sin ( y );
	    w := ( z - zz * ( 3.0 - 4.0 * zz * zz ) ) / z ;
	 end;
	 if ( w > 0.0 ) then k := k + 1 ;
	 if ( w < 0.0 ) then k1 := k1 + 1 ;
	 r5 := r5 + w ;
	 w := abs ( w );
	 if ( w > r6 ) then begin
	    r6 := w ;
	    x1 := x ;
	 end;
	 r7 := r7 + w * w ;
	 xl := xl + del ;
      end ;

      r5 := r5 / xn ;
      r7 := sqrt ( r7 / xn );
      if ( j = 3 ) then begin
	 writeln(' TEST OF COS(X) VS 4*COS(X/3)**3-3*COS(X/3)');
	 writeln;
      end else begin
	 writeln(' TEST OF SIN(X) VS 3*SIN(X/3)-4*SIN(X/3)**3');
	 writeln;
      end;
      printtestrun(n,a,b,k,k1,r5,r6,x1,r7);
      a := 18.84955592 ;
      if ( j = 2 ) then a := b + c ;
      b := a + c ;
   end ;
{
      special tests
								      }
   c := 1.0 / exp ( ( it div 2 ) * ln( beta ));
   z := ( sin ( a + c )- sin ( a - c )) / ( c + c ) ;
   write(' IF ', z:15,' IS NOT ALMOST 1.0 THEN SIN HAS THE WRONG ');
   writeln('PERIOD');
   writeln;

   writeln(' THE IDENTITY -SIN(X) = -SIN(X) WILL BE TESTED');
   writeln(' ':7, 'X',' ':9,'F(X) + F(-X)');
   writeln;

   for i := 1 to 5 do begin
      x := random * a ;
      z := sin ( x )+ sin ( - x );
      writeln(x:14,z:15);
   end ;

   writeln;
   writeln(' THE IDENTITY SIN(X) = X, X SMALL, WILL BE TESTED.');
   writeln(' ':7, 'X',' ':9,'X - F(X)');
   writeln;
   betap := exp ( it * ln( beta ));
   x := random / betap ;

   for i := 1 to 5 do begin
      z := x - sin ( x );
      writeln(x:14, z:15);
      x := x / beta ;
   end ;
   writeln;

   writeln(' THE IDENTITY COS(-X) = COS(X) WILL BE TESTED.');
   writeln(' ':7,'X',' ':9,'F(X) - F(-X)');
   writeln;

   for i := 1 to 5 do begin
      x := random * a ;
      z := cos ( x )- cos ( - x );
      writeln(x:14, z:15);
   end ;
   writeln;

   writeln(' TEST OF UNDERFLOW FOR VERY SMALL ARGUMENTS');
   writeln;
   expon := ( minexp )* 0.75 ;
   x := exp ( expon * ln( beta ));
   y := sin ( x );
   writeln(' ':5, 'SIN(', x:15, ') = ', y:15);
   writeln;
   writeln(' THE FOLLOWING THREE LINES ILLUSTRATE THE LOSS IN');
   writeln(' SIGNIFICANCE FOR LARGE ARGUMENTS. THE ARGUMENTS');
   writeln(' USED ARE CONSECUTIVE.');
   writeln;
   z := sqrt ( betap );
   x := z * ( 1.0 - epsneg ) ;
   y := sin ( x );
   writeln(' ':5, 'SIN(', x:15, ') = ', y:15);
   writeln;
   y := sin ( z );
   writeln(' ':5, 'SIN(', z:15, ') = ', y:15);
   writeln;
   x := z * ( 1.0 + eps ) ;
   y := sin ( x );
   writeln(' ':5, 'SIN(', x:15, ') = ', y:15);
   writeln;
   x := betap ;
   writeln(' SIN(X) WILL BE CALLED WITH THE ARGUMENT ', x:15);
   y := sin ( x );
   writeln(' SIN RETURNED THE VALUE ', y:15);
   writeln(' THIS CONCLUDES THE TESTS.');
end.
{TEST 6.6.6.2-10, CLASS=QUALITY}

{ This test checks the implementation of the ln function. }

program t6p6p6p2d10(output);

var


{     data required

	 none

      other subprograms in this package

	 machar -  as for sqrtest
	 ran(k) - as for sqrtest


      standard subprograms required

	 abs, ln, sqrt
								      }

   i , ibeta , iexp ,  irnd , it , i1 , j , k , k1 , machep ,
      iy , maxexp , minexp , n , negep , ngrd : integer ;
   a , albeta , b , beta , d , del , eight , eps , epsneg , half , r5 ,
      r6 , r7 , tenth , w , x , xl , xmax , xmin , xn , x1 , y , z ,zz:
      real ;

procedure machar (var ibeta , it , irnd , ngrd , machep , negep , iexp,
  minexp , maxexp : integer ; var eps , epsneg , xmin , xmax : real ) ;

var


{     This subroutine is intended to determine the characteristics
      of the floating-point arithmetic system that are specified
      below.  The first three are determined according to an
      algorithm due to M. Malcolm, CACM 15 (1972), pp. 949-951,
      incorporating some, but not all, of the improvements
      suggested by M. Gentleman and S. Marovich, CACM 17 (1974),
      pp. 276-277.  The version given here is for single precision.

      Latest revision - October 1, 1976.

      Author - W. J. Cody
	       Argonne National Laboratory

      Revised for Pascal - R. A. Freak
			   University of Tasmania
			   Hobart
			   Tasmania

      ibeta    is the radix of the floating-point representation
      it       is the number of base ibeta digits in the floating-point
		  significand
      irnd     =  0 if the arithmetic chops,
		  1 if the arithmetic rounds
      ngrd     =  0 if	irnd=1, or if  irnd=0  and only  it  base ibeta
		    digits participate in the post normalization shift
		    of the floating-point significand in multiplication
		  1 if	irnd=0	and more than  it  base  ibeta	digits
		    participate in the post normalization shift of the
		    floating-point significand in multiplication
      machep   is the exponent on the smallest positive floating-point
		  number  eps such that  1.0+eps <> 1.0
      negeps   is the exponent on the smallest positive fl. pt. no.
		  negeps such that  1.0-negeps <> 1.0, except that
		  negeps is bounded below by  it-3
      iexp     is the number of bits (decimal places if ibeta = 10)
		  reserved for the representation of the exponent of
		  a floating-point number
      minexp   is the exponent of the smallest positive fl. pt. no.
		  xmin
      maxexp   is the exponent of the largest finite floating-point
		  number  xmax
      eps      is the smallest positive floating-point number such
		  that	1.0+eps <> 1.0. in particular,
		  eps = ibeta**machep
      epsneg   is the smallest positive floating-point number such
		  that	1.0-eps <> 1.0	(except that the exponent
		  negeps is bounded below by it-3).  in particular
		  epsneg = ibeta**negep
      xmin     is the smallest positive floating-point number.	in
		  particular,  xmin = ibeta ** minexp
      xmax     is the largest finite floating-point number.  in
		  particular   xmax = (1.0-epsneg) * ibeta ** maxexp
		  note - on some machines  xmax  will be only the
		  second, or perhaps third, largest number, being
		  too small by 1 or 2 units in the last digit of
		  the significand.

								    }

   i , iz , j , k , mx : integer ;
   a , b , beta , betain , betam1 , one , y , z , zero : real ;
   underflo : boolean;

begin
   irnd := 1 ;
   one := ( irnd );
   a := one + one ;
   b := a ;
   zero := 0.0 ;
{
      determine ibeta,beta ala Malcolm
								    }
   while ( ( ( a + one ) - a ) - one = zero ) do begin
      a := a + a ;
   end ;
   while ( ( a + b ) - a = zero ) do begin
      b := b + b ;
   end ;
   ibeta := trunc ( ( a + b ) - a );
   beta := ( ibeta );
   betam1 := beta - one ;
{
      determine irnd,ngrd,it
								    }
   if ( ( a + betam1 ) - a = zero ) then irnd := 0 ;
   it := 0 ;
   a := one ;
   repeat begin
      it := it + 1 ;
      a := a * beta ;
   end until ( ( ( a + one ) - a ) - one <> zero ) ;
{
      determine negep, epsneg
								    }
   negep := it + 3 ;
   a := one ;

   for i := 1 to negep do begin
      a := a / beta ;
   end ;

   while ( ( one - a ) - one = zero ) do begin
      a := a * beta ;
      negep := negep - 1 ;
   end ;
   negep := - negep ;
   epsneg := a ;
{
      determine machep, eps
								    }
   machep := negep ;
   while ( ( one + a ) - one = zero ) do begin
      a := a * beta ;
      machep := machep + 1 ;
   end ;
   eps := a ;
{
      determine ngrd
								    }
   ngrd := 0 ;
   if(( irnd = 0) and((( one + eps) * one - one) <> zero)) then
   ngrd := 1 ;
{
      determine iexp, minexp, xmin

      loop to determine largest i such that
	  (1/beta) ** (2**(i))
      does not underflow
      exit from loop is signall by an underflow
								    }
   i := 0 ;
   betain := one / beta ;
   z := betain ;
   underflo := false;
   repeat begin
      y := z ;
      z := y * y ;
{
      check for underflow
								    }
      if ( ( z * one = zero ) or ( abs ( z )> y ) ) then begin
	 underflo := true;
      end else begin
	 i := i + 1 ;
      end;
   end until underflo ;
   k := 1 ;
{
      determine k such that (1/beta)**k does not underflow

      first set k = 2 ** i
								    }

   for j := 1 to i do begin
      k := k + k ;
   end ;

   iexp := i + 1 ;
   mx := k + k ;
   if ( ibeta = 10 ) then begin
{
      for decimal machines only 				    }
      iexp := 2 ;
      iz := ibeta ;
      while ( k >= iz ) do begin
	 iz := iz * ibeta ;
	 iexp := iexp + 1 ;
      end ;
      mx := iz + iz - 1 ;
   end;
   underflo := false;
   repeat begin
{
      loop to construct xmin
      exit from loop is signalled by an underflow
								    }
      xmin := y ;
      y := y * betain ;
      if ( ( ( y * one ) = zero ) or ( abs ( y )> xmin ) )
      then begin
	 underflo := true;
      end else begin
	 k := k + 1 ;
      end;
   end until underflo ;
   minexp := - k ;
{  determine maxexp, xmax
								    }
   if ( ( mx <= k + k - 3 ) and ( ibeta <> 10 ) ) then begin
      mx := mx + mx ;
      iexp := iexp + 1 ;
   end;
   maxexp := mx + minexp ;
{  adjust for machines with implicit leading
   bit in binary significand and machines with
   radix point at extreme right of significand
								    }
   i := maxexp + minexp ;
   if ( ( ibeta = 2 ) and ( i = 0 ) ) then maxexp := maxexp - 1 ;
   if ( i > 20 ) then maxexp := maxexp - 3 ;
   xmax := one - epsneg ;
   if ( xmax * one <> xmax ) then xmax := one - beta * epsneg ;
   xmax := ( xmax * betain * betain * betain ) / xmin ;
   i := maxexp + minexp + 3 ;
   if  ( i > 0 ) then begin

      for j := 1 to i do begin
	 xmax := xmax * beta ;
      end ;
   end;

end;


function random : real ;

{     random number generator - based on algorithm 266
       by Pike and Hill (modified by Hansson)
       collected Alg. from CACM.

      This subprogram is intended for use on computers with
       fixed point wordlength of at least 29 bIts.  it is
       best if the floating point significand has at most
       29 bits. }

{     The quality of the random numbers is not important.
      If recoding is needed for small wordlength computers,
      even returning a constant value or zero is possible. }

{     The value iy is global, and is initialized in the driver }

begin
   iy := (iy*125) mod 2796203;
   random := ( iy )/ 2796203.0e0 ;
end;


procedure printtestrun (n:integer; lb,ub:real;
			big,small : integer;
			mean,maxerror,xmaxerror,rmserror:real);
begin
   writeln(' ':5,n:4,' RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL')
      ;
   writeln(' ':10,'(',lb:15,',',ub:15,')');
   writeln;
   writeln(' ':5,'THE RESULT WAS TOO LARGE',big:5,' TIMES, AND');
   writeln(' ':10,'TOO SMALL',small:5,' TIMES');
   writeln;
   if (mean <> 0.0) then begin
      writeln(' ':5,'MEAN RELATIVE ERROR =',mean:15,'=',
	 IBETA:4,' ** ',LN(ABS(mean))/ALBETA:7:2);
   end;
   if (maxerror<> 0.0) then begin
      writeln(' ':5,'THE MAXIMUM RELATIVE ERROR OF',maxerror:15,'=',
	 IBETA:4,' ** ',LN(ABS(maxerror))/ALBETA:7:2);
      writeln(' ':10,'OCCURRED FOR X =',xmaxerror:15);
   end;
   if (rmserror <> 0.0) then begin
      writeln(' ':5,'ROOT-MEAN-SQUARE RELATIVE ERROR =',rmserror:15,
	 '=',IBETA:4,' ** ',LN(ABS(rmserror))/ALBETA:7:2);
   end;
   writeln;
end;   { OF PRINT TEST RUN }

function sign(a1 , a2 : real) : real;
begin
  if (a2 < 0) then
    sign := -abs(a1)
  else
    sign := abs(a1)
end;


begin
   iy := 100001;
   machar ( ibeta , it , irnd , ngrd , machep , negep , iexp , minexp ,
     maxexp , eps , epsneg , xmin , xmax );
   beta := ( ibeta );
   albeta := ln ( beta );
   j := it div 3 ;
   a := 1.0 ;

   for i := 1 to j do begin
      a := a / beta ;
   end ;

   n := 2000 ;
   xn := ( n );
   b := 1.0 + a ;
   a := 1.0 - a ;
   d := 1.0 + sqrt ( eps );
   half := 0.5 ;
   eight := 8.0 ;
   tenth := 0.1 ;
   i1 := 0 ;
{
      random argument accuracy tests
								      }
   for j := 1 to 4 do begin
      case j of
      1:
	 begin
	    write(' TEST OF LN(X) VS TAYLOR SERIES EXPANSION');
	    writeln(' OF LN(1+Y)');
	 end;
      2:
	 begin
	    writeln(' TEST OF LN(X) VS LN(17X/16)-LN(17/16)');
	    writeln;
	    a := sqrt ( half );
	    b := 15.0 / 16.0 ;
	    end;
      3:
	 begin
	    writeln(' TEST OF LN(X) VS LN(11X/10)-LN(11/10)');
	    writeln;
	    a := sqrt ( tenth );
	    b := 0.9;
	 end;
      4:
	 begin
	    writeln(' TEST OF LN(X*X) VS 2 * LN(X)');
	    writeln;
	    a := 16.0 ;
	    b := 240.0 ;
	 end;
      end;
      del := ( b - a ) / xn ;
      k := 0 ;
      k1 := 0 ;
      x1 := 0.0 ;
      r5 := 0.0 ;
      r6 := 0.0 ;
      r7 := 0.0 ;
      xl := a ;

      for i := 1 to n do begin
	 x := del * random * d + xl ;
	 case j of
	 1:
	    begin
	       y := ( x - 0.5 ) - half ;
	       z := ln ( x );
	       zz := 1.0 / 3.0 ;
	       zz := y * ( zz - y / 4.0 ) ;
	       zz := ( zz - half ) * y * y + y ;
	    end;
	 2:
	    begin
	       x := ( x + 8.0 ) - eight ;
	       y := x + x / 16.0 ;
	       z := ln ( x );
	       zz := ln ( y )- 7.7746816434842581e-5 ;
	       zz := zz - 31.0 / 512.0 ;
	    end;
	 3:
	    begin
	       x := ( x + 8.0 ) - eight ;
	       y := x + x * tenth ;
	       z := ln ( x )/ ln(10) ;
	       zz := ln ( y )/ ln(10) - 3.7706015822504075e-4 ;
	       zz := zz - 21.0 / 512.0 ;
	    end;
	 4:
	    begin
	       z := ln ( x * x );
	       zz := ln ( x );
	       zz := zz + zz ;
	    end;
	 end;
	 w := ( z - zz ) / z ;
	 z := sign ( w , z );
	 if ( z > 0.0 ) then k := k + 1 ;
	 if ( z < 0.0 ) then k1 := k1 + 1 ;
	 r5 := r5 + w ;
	 w := abs ( w );
	 if ( w > r6 ) then begin
	    r6 := w ;
	    x1 := x ;
	 end;
	 r7 := r7 + w * w ;
	 xl := xl + del ;
      end ;

      r5 := r5 / xn ;
      r7 := sqrt ( r7 / xn );
      printtestrun(n,a,b,k,k1,r5,r6,x1,r7);
   end ;
{
      special tests
								      }
   writeln(' THE IDENTITY LN(X) = - LN(1/X) WILL BE TESTED');
   writeln;
   writeln('	    X	     F(X) + F(1/X)');
   writeln;

   for i := 1 to 5 do begin
      x := random ;
      x := x + x + 15.0 ;
      y := 1.0 / x ;
      z := ln ( x )+ ln ( y );
      writeln(x:15,z:15);
   end ;

   writeln;
   writeln(' TEST OF SPECIAL ARGUMENTS');
   writeln;
   x := 1.0 ;
   y := ln ( x );
   writeln(' LN(1.0) = ', y:15);
   writeln;
   x := xmin ;
   y := ln ( x );
   writeln(' LN(XMIN) = LN(', x:15, ') = ', y:15);
   writeln;
   x := xmax ;
   y := ln ( x );
   writeln(' LN(XMAX) = LN(', x:15, ') = ', y:15);
   writeln;
{
      Test 6.6.6.2-4 checks that an error is produced
      when  ln is called with a negative argument.
								 }
   writeln(' THIS CONCLUDES THE TESTS');
end.
{TEST 6.6.6.2-11, CLASS=IMPLEMENTATIONDEFINED}

{ This program determines some of the characteristics of the
  floating-point arithmetic system of the host machine.
  If the program fails or the printed results do not agree
  with the known data for the machine then the program
  should be checked because some of the assumptions made
  about floating-point arithmetic may be invalid for that
  machine. }

program t6p6p6p2d11(output);

{ If the results from this test are not in conformity with
  the known data for the implementation,  then all copies of
  MACHAR should be replaced by an equivalent that assigns
  the appropriate values to the parameters. }

var

   eps , epsneg , xmax , xmin : real;

   ibeta , iexp , irnd , it , machep , maxexp , minexp , negep , ngrd :
   integer;

procedure machar (var ibeta , it , irnd , ngrd , machep , negep , iexp,
  minexp , maxexp : integer ; var eps , epsneg , xmin , xmax : real ) ;

var


{     This subroutine is intended to determine the characteristics
      of the floating-point arithmetic system that are specified
      below.  The first three are determined according to an
      algorithm due to M. Malcolm, CACM 15 (1972), pp. 949-951,
      incorporating some, but not all, of the improvements
      suggested by M. Gentleman and S. Marovich, CACM 17 (1974),
      pp. 276-277.  The version given here is for single precision.

      Latest revision - October 1, 1976.

      Author - W. J. Cody
	       Argonne National Laboratory

      Revised for Pascal - R. A. Freak
			   University of Tasmania
			   Hobart
			   Tasmania

      ibeta    is the radix of the floating-point representation
      it       is the number of base ibeta digits in the floating-point
		  significand
      irnd     =  0 if the arithmetic chops,
		  1 if the arithmetic rounds
      ngrd     =  0 if	irnd=1, or if  irnd=0  and only  it  base ibeta
		    digits participate in the post normalization shift
		    of the floating-point significand in multiplication
		  1 if	irnd=0	and more than  it  base  ibeta	digits
		    participate in the post normalization shift of the
		    floating-point significand in multiplication
      machep   is the exponent on the smallest positive floating-point
		  number  eps such that  1.0+eps <> 1.0
      negeps   is the exponent on the smallest positive fl. pt. no.
		  negeps such that  1.0-negeps <> 1.0, except that
		  negeps is bounded below by  it-3
      iexp     is the number of bits (decimal places if ibeta = 10)
		  reserved for the representation of the exponent of
		  a floating-point number
      minexp   is the exponent of the smallest positive fl. pt. no.
		  xmin
      maxexp   is the exponent of the largest finite floating-point
		  number  xmax
      eps      is the smallest positive floating-point number such
		  that	1.0+eps <> 1.0. in particular,
		  eps = ibeta**machep
      epsneg   is the smallest positive floating-point number such
		  that	1.0-eps <> 1.0	(except that the exponent
		  negeps is bounded below by it-3).  in particular
		  epsneg = ibeta**negep
      xmin     is the smallest positive floating-point number.	in
		  particular,  xmin = ibeta ** minexp
      xmax     is the largest finite floating-point number.  in
		  particular   xmax = (1.0-epsneg) * ibeta ** maxexp
		  note - on some machines  xmax  will be only the
		  second, or perhaps third, largest number, being
		  too small by 1 or 2 units in the last digit of
		  the significand.

								    }

   i , iz , j , k , mx : integer ;
   a , b , beta , betain , betam1 , one , y , z , zero : real ;
   underflo : boolean;

begin
   irnd := 1 ;
   one := ( irnd );
   a := one + one ;
   b := a ;
   zero := 0.0 ;
{
      determine ibeta,beta ala Malcolm
								    }
   while ( ( ( a + one ) - a ) - one = zero ) do begin
      a := a + a ;
   end ;
   while ( ( a + b ) - a = zero ) do begin
      b := b + b ;
   end ;
   ibeta := trunc ( ( a + b ) - a );
   beta := ( ibeta );
   betam1 := beta - one ;
{
      determine irnd,ngrd,it
								    }
   if ( ( a + betam1 ) - a = zero ) then irnd := 0 ;
   it := 0 ;
   a := one ;
   repeat begin
      it := it + 1 ;
      a := a * beta ;
   end until ( ( ( a + one ) - a ) - one <> zero ) ;
{
      determine negep, epsneg
								    }
   negep := it + 3 ;
   a := one ;

   for i := 1 to negep do begin
      a := a / beta ;
   end ;

   while ( ( one - a ) - one = zero ) do begin
      a := a * beta ;
      negep := negep - 1 ;
   end ;
   negep := - negep ;
   epsneg := a ;
{
      determine machep, eps
								    }
   machep := negep ;
   while ( ( one + a ) - one = zero ) do begin
      a := a * beta ;
      machep := machep + 1 ;
   end ;
   eps := a ;
{
      determine ngrd
								    }
   ngrd := 0 ;
   if(( irnd = 0) and((( one + eps) * one - one) <> zero)) then
   ngrd := 1 ;
{
      determine iexp, minexp, xmin

      loop to determine largest i such that
	  (1/beta) ** (2**(i))
      does not underflow
      exit from loop is signall by an underflow
								    }
   i := 0 ;
   betain := one / beta ;
   z := betain ;
   underflo := false;
   repeat begin
      y := z ;
      z := y * y ;
{
      check for underflow
								    }
      if ( ( z * one = zero ) or ( abs ( z )> y ) ) then begin
	 underflo := true;
      end else begin
	 i := i + 1 ;
      end;
   end until underflo ;
   k := 1 ;
{
      determine k such that (1/beta)**k does not underflow

      first set k = 2 ** i
								    }

   for j := 1 to i do begin
      k := k + k ;
   end ;

   iexp := i + 1 ;
   mx := k + k ;
   if ( ibeta = 10 ) then begin
{
      for decimal machines only 				    }
      iexp := 2 ;
      iz := ibeta ;
      while ( k >= iz ) do begin
	 iz := iz * ibeta ;
	 iexp := iexp + 1 ;
      end ;
      mx := iz + iz - 1 ;
   end;
   underflo := false;
   repeat begin
{
      loop to construct xmin
      exit from loop is signalled by an underflow
								    }
      xmin := y ;
      y := y * betain ;
      if ( ( ( y * one ) = zero ) or ( abs ( y )> xmin ) )
      then begin
	 underflo := true;
      end else begin
	 k := k + 1 ;
      end;
   end until underflo ;
   minexp := - k ;
{  determine maxexp, xmax
								    }
   if ( ( mx <= k + k - 3 ) and ( ibeta <> 10 ) ) then begin
      mx := mx + mx ;
      iexp := iexp + 1 ;
   end;
   maxexp := mx + minexp ;
{  adjust for machines with implicit leading
   bit in binary significand and machines with
   radix point at extreme right of significand
								    }
   i := maxexp + minexp ;
   if ( ( ibeta = 2 ) and ( i = 0 ) ) then maxexp := maxexp - 1 ;
   if ( i > 20 ) then maxexp := maxexp - 3 ;
   xmax := one - epsneg ;
   if ( xmax * one <> xmax ) then xmax := one - beta * epsneg ;
   xmax := ( xmax * betain * betain * betain ) / xmin ;
   i := maxexp + minexp + 3 ;
   if  ( i > 0 ) then begin

      for j := 1 to i do begin
	 xmax := xmax * beta ;
      end ;
   end;

end;



begin
   machar ( ibeta , it , irnd , ngrd , machep , negep , iexp , minexp ,
      maxexp , eps , epsneg , xmin , xmax );
   writeln(' OUTPUT FROM MACHAR');
   writeln;
   writeln;
   writeln(' BETA =',ibeta:5);
   writeln;
   writeln('	T =',it:5);
   writeln;
   writeln('  RND =',irnd:5);
   writeln;
   writeln(' NGRD =',ngrd:5);
   writeln;
   writeln(' MACHEP =',machep:5);
   writeln;
   writeln(' NEGEP =',negep:5);
   writeln;
   writeln(' IEXP =',iexp:5);
   writeln;
   writeln(' MINEXP =',minexp:5);
   writeln;
   writeln(' MAXEXP =',maxexp:5);
   writeln;
   writeln(' EPS =',eps:15);
   writeln;
   writeln(' EPSNEG =',epsneg:15);
   writeln;
   writeln(' XMIN =',xmin:15);
   writeln;
   writeln(' XMAX =',xmax:15);
end.
{TEST 6.6.6.3-1, CLASS=CONFORMANCE}

{ This program checks the implementation of the transfer
  functions trunc and round.
  The compiler fails if the program does not compile and run. }

program t6p6p6p3d1(output);
var
   i,
   truncstatus,
   roundstatus : integer;
   j : real;
begin
   truncstatus:=0;
   roundstatus:=0;
   if (trunc(3.7)=3) and (trunc(-3.7)=-3) then
      truncstatus:=truncstatus+1
   else
      writeln(' FAIL...6.6.6.3-1 : TRUNC');

   if (round(3.7)=4) and (round(-3.7)=-4) then
      roundstatus:=roundstatus+1
   else
      writeln(' FAIL...6.6.6.3-1 : ROUND');

   j:=0;
   for i:=-333 to 333 do
   begin
      j:=j+i div 100;
      if j<0 then
	 if (trunc(j-0.5)=round(j)) then
	    begin
	       truncstatus:=truncstatus+1;
	       roundstatus:=roundstatus+1
	    end
	 else
	    writeln(' FAIL...6.6.6.3-1 : TRUNC ROUND')
      else
	 if (trunc(j+0.5)=round(j)) then
	    begin
	       truncstatus:=truncstatus+1;
	       roundstatus:=roundstatus+1
	    end
	 else
	    writeln(' FAIL...6.6.6.3-1 : TRUNC ROUND')
   end;

   if (truncstatus=668) and (roundstatus=668) then
      writeln(' PASS...6.6.6.3-1')
end.
{TEST 6.6.6.3-2, CLASS=ERRORHANDLING}

{ This program causes an error to occur as the result
  returned by the trunc function is not a value of the
  type integer.
  The error should be detected at run-time. }

program t6p6p6p3d2(output);
var
   reel : real;
   i	: integer;
   ok	: boolean;
begin
   reel:=11111.11111;
   ok:=true;
   while ok do
   begin
      i:=trunc(reel);
      if (i<0) then
	 ok:=false
      else
	 reel:=reel*2
   end;
   writeln(' ERROR NOT DETECTED...6.6.6.3-2')
end.
{TEST 6.6.6.3-3, CLASS=ERRORHANDLING}

{ This program causes an error to occur as the result
  returned by the round function is not a value of the
  type integer.
  The error should be detected at run-time. }

program t6p6p6p3d3(output);
var
   reel : real;
   i	: integer;
   ok	: boolean;
begin
   reel:=11111.11111;
   ok:=true;
   while ok do
   begin
      i:=round(reel);
      if (i<0) then
	 ok:=false
      else
	 reel:=reel*2
   end;
   writeln(' ERROR NOT DETECTED...6.6.6.3-3')
end.
{TEST 6.6.6.3-4, CLASS=DEVIANCE}

{ This test checks that neither trunc nor round are permitted
  to have integer parameters. The Standard requires these to be
  real. The compiler deviates if the program compiles and prints
  DEVIATES. }

program t6p6p6p3d4(output);
var
   i:integer;
   x:real;
begin
   i:=1979;
   x:=trunc(i)+round(i+1);
   writeln(' DEVIATES...6.6.6.3-4, TRUNC/ROUND')
end.
{TEST 6.6.6.4-1, CLASS=CONFORMANCE}

{ This program checks that the implementation of the ord
  function is as described by the Standard.
  The compiler fails if the program does not compile and run. }

program t6p6p6p4d1(output);
type
   colourtype = (red,orange,yellow,green,blue);
var
   colour   : colourtype;
   some     : orange..green;
   i	    : integer;
   counter  : integer;
   ok	    : boolean;
begin
   counter:=0;
   if (ord(false)=0) and (ord(true)=1) then
      counter:=counter+1
   else
      writeln(' FAIL...6.6.6.4-1 : FALSE/TRUE');

   if (ord(red)=0) and (ord(orange)=1) and
      (ord(yellow)=2) and (ord(green)=3) and
      (ord(blue)=4) then
      counter:=counter+1
   else
      writeln(' FAIL...6.6.6.4-1 : COLOURTYPE');

   i:=-11;
   ok:=true;
   while ok do
   begin
      i:=i+1;
      if i>10 then
	 ok:=false
      else
	 if ord(i)=i then
	    counter:=counter+1
	 else
	 begin
	    ok:=false;
	    writeln(' FAIL...6.6.6.4-1 : I')
	 end
   end;

   colour:=blue;
   some:=orange;
   if ord(colour)=4 then
      counter:=counter+1
   else
      writeln(' FAIL...6.6.6.4-1 : COLOUR');

   if ord(some)=1 then
      counter:=counter+1
   else
      writeln(' FAIL...6.6.6.4-1 : SOME');

   if counter=25 then
      writeln(' PASS...6.6.6.4-1')
end.
{TEST 6.6.6.4-2, CLASS=CONFORMANCE}

{ This program checks the implementation of chr.
  The compiler fails if the program does not compile and run. }

program t6p6p6p4d2(output);
var
   letter : char;
   counter : integer;
begin
   counter:=0;

   for letter:='0' to '9' do
      if chr(ord(letter))=letter then
	 counter:=counter+1;

   if counter=10 then
      writeln(' PASS...6.6.6.4-2')
   else
      writeln(' FAIL...6.6.6.4-2')
end.
{TEST 6.6.6.4-3, CLASS=CONFORMANCE}

{ This program tests the function pred only. The user is
  refered to tests 6.4.2.2-4 and 6.4.2.3-2 for tests of
  succ.
  The compiler fails if the program does not compile and run. }

program t6p6p6p4d3(output);
type
   colourtype = (red,orange,yellow,green,blue);
var
   colour : colourtype;
   counter: integer;
begin
   counter:=0;
   colour:=blue;
   colour:=pred(colour);
   colour:=pred(colour);
   colour:=pred(succ(colour));
   if colour=yellow then
      counter:=1
   else
      writeln(' FAIL...6.6.6.4-3 : COLOUR');

   if pred(-10)=-11 then
      counter:=counter+1
   else
      writeln(' FAIL...6.6.6.4-3 : -VE NUMBERS');

   if counter=2 then
      writeln(' PASS...6.6.6.4-3')
end.
{TEST 6.6.6.4-4, CLASS=ERRORHANDLING}

{ This program causes an error to occur as the
  function succ is applied to the last value
  of an ordinal type.
  The error should be detected by the compiler
  or at run-time. }

program t6p6p6p4d4(output);
type
   enumerated = (first,second,third,last);
var
   ordinal : enumerated;
begin
   ordinal:=succ(last);
   writeln(' ERROR NOT DETECTED...6.6.6.4-4')
end.
{TEST 6.6.6.4-5, CLASS=ERRORHANDLING}

{ This program causes an error to occur as the function PRED
  is applied to the first value of an ordinal type.
  The error should be detected by the compiler or at run-time. }

program t6p6p6p4d5(output);
type
   enumerated = (first,second,third,fourth,last);
var
   ordinal : enumerated;
begin
   ordinal:=first;
   ordinal:=pred(ordinal);
   writeln(' ERROR NOT DETECTED...6.6.6.4-5, PRED')
end.
{TEST 6.6.6.4-6, CLASS=DEVIANCE}

{ This test checks that succ and pred cannot be applied to
  real values. The compiler deviates if the program compiler
  and prints DEVIATES. }

program t6p6p6p4d6(output);
var
   x:real;
begin
   x:=0.3;
   if (succ(x)>x) and (pred(x)<x) then
      writeln(' DEVIATES...6.6.6.4-6, REAL SUCC/PRED')
   else
      writeln(' DEVIATES...6.6.6.4-6, MESS')
end.
{TEST 6.6.6.4-7, CLASS=ERRORHANDLING}

{ This test evokes an error by pushing chr past the
  limits of the char type. It assumes that no char type has more
  than 10000+ord('0') values. }

program t6p6p6p4d7(output);
var
   i:0..10000;
   c:char;
begin
   for i:=0 to 10000 do
      c:=chr(i+ord('0'));
   writeln(' ERROR NOT DETECTED...6.6.6.4-7, CHR')
end.
{TEST 6.6.6.5-1, CLASS=CONFORMANCE}

{ This program would have tested the function of the eof and eoln
  predicates. However, the test is carried out elsewhere, and
  the user is refered to tests 6.4.3.5-2 and 6.4.3.5-3. }

program t6p6p6p5d1;
begin
end.
{TEST 6.6.6.5-2, CLASS=CONFORMANCE}

{ This program tests the predicate odd.
  The compiler fails if the program does not compile or
  the program states that this is so. }

program t6p6p6p5d2(output);
var
   i,counter : integer;
function myodd(i:integer):boolean;
   begin
      myodd := (abs(i mod 2) = 1);
   end;
begin
   counter:=0;
   for i:=-10 to 10 do
      if odd(i) then
      begin
	 if myodd(i) then counter := counter+1
      end else begin
	 if not myodd(i) then counter := counter+1
      end;
   if counter=21 then
      writeln(' PASS...6.6.6.5-2')
   else
      writeln(' FAIL...6.6.6.5-2')
end.
{TEST 6.6.6.5-3, CLASS=DEVIANCE}

{ This test checks that the function odd is restricted to
  integer parameters. Ths compiler deviates if the program compiles
  and prints DEVIATES. }

program t6p6p6p5d3(output);
var
   x:real;
begin
   x:=1.0;
   if odd(x) then
      writeln(' DEVIATES...6.6.6.5-3, REAL ODD')
   else
      writeln(' DEVIATES...6.6.6.5-3, MESS')
end.
{TEST 6.7.1-1, CLASS=CONFORMANCE}

{ This program tests that the precedence of the boolean operators
  is as described in the Pascal Standard.
  The compiler fails if the program does not compile, or the
  program states that this is so. }

program t6p7p1d1(output);
var
   a, b, c, w, x : boolean;
   counter:integer;
begin
  counter := 0;
   for a := false to true do
      for b:= false to true do
	 for c := false to true do
	 begin
	    w := (a and b) < c;
	    x := c > b and a;
	    if (w=x) then counter := counter+1;
	 end;
   if (counter=8) then
      writeln(' PASS...6.7.1-1')
   else
      writeln(' FAIL...6.7.1-1')
end.
{TEST 6.7.1-2, CLASS=CONFORMANCE}

{ This program tests that the precedence of the arithmetic
  operators is as described by the Pascal Standard.
  The compiler fails if the program does not compile, or
  the program states that this is so. }

program t6p7p1d2(output);
var
   a,b,c,d,e,f,g : integer;
   h,i,j,k,l,m,n : real;
begin
   a:=1;
   b:=2;
   c:=3;
   d:=4;
   e:=5;
   f:=a-b+c-d;
   g:=e-d div b*c;
   h:=1;
   i:=2;
   j:=3;
   k:=4;
   l:=5;
   m:=h/i*j/k;
   n:=l+k/i-3*j;
   if (f=-2) and (g=-1) and (n=-2) and
      ((m<0.38) and (m>0.37)) then
      writeln(' PASS...6.7.1-2')
   else
      writeln(' FAIL...6.7.1-2')
end.
{TEST 6.7.2.2-1, CLASS=CONFORMANCE}

{ This program checks the operation of the operators + - and *.
  The compiler fails if the program does not compile, or the
  program states that this is so. }

program t6p7p2p2d1(output);
var
   i, x, y , counter : integer;
begin
   counter := 0;
   for x := -10 to 10 do
   begin
      if (succ(x)=x+1) then
	 counter := counter+1;
      if (pred(x) = x-1) then
	 counter := counter+1;
      if (x*x=sqr(x)) then
	 counter:= counter+1;
   end;
   if (counter=63) then
      writeln(' PASS...6.7.2.2-1')
   else
      writeln(' FAIL...6.7.2.2-1')
end.
{TEST 6.7.2.2-2, CLASS=CONFORMANCE}

{ This program checks that DIV and MOD are implemented by the
  rule specified by the Pascal Standard.
  The compiler fails if the program does not compile, or the
  program states that this is so. }

program t6p7p2p2d2(output);
var
   i, j, counter : integer;
begin
   counter:=0;
   for i:=0 to 6 do
      for j:=1 to 4 do
	 if ((i-j)<((i div j)*j)) and (((i div j)*j)<=i) then
	    counter:=counter+1;
   for i:=0 to 6 do
      for j:=1 to 4 do
	 if (i mod j)=(i-(i div j)*j) then
	    counter:=counter+1;
   if counter=56 then
      writeln(' PASS...6.7.2.2-2')
   else
      writeln(' FAIL...6.7.2.2-2: DIV MOD')
end.
{TEST 6.7.2.2-3, CLASS=ERRORHANDLING}

{ This program causes an error to occur as the second operand
  of the DIV operator is 0.
  The error should be detected at run-time. }

program t6p7p2p2d3(output);
var
   i, j, k : integer;
begin
   i:=6;
   j:=0;
   k:=i div j;	     { an error as j=0 }
   writeln(' ERROR NOT DETECTED...6.7.2.2-3: ZERO DIVIDE (DIV)')
end.
{TEST 6.7.2.2-4, CLASS=QUALITY}

{ This program checks that constant and variable operands for DIV
  produce the same result, and if negative operands are permitted. }

program t6p7p2p2d4(output);
var
   i, j, k, l, m,counter : integer;
begin
   { The next few statements may cause a run-time error. }

   writeln(' THIS PROGRAM ATTEMPTS DIVISION WITH NEGATIVE OPERANDS');
   counter := 0;
   j:=2;
   for i:= -10 to 10 do
   begin
      l:=i div j;
      m:= i div 2;
      if (l=m) then counter := counter+1;
      l:=i mod j;
      m:= i mod 2;
      if (l=m) then counter := counter+1;
      if (i-i div 2 * 2 = i mod 2) then counter := counter+1;
   end;
   if counter = 63 then
   begin
      write(' DIVISION INTO NEGATIVE OPERANDS IMPLEMENTED AND ');
      writeln('CONSISTENT');
   end else
      writeln(' INCONSISTENT DIVISION INTO NEGATIVE OPERANDS');
   counter := 0;
   j:=-2;
   for i:= -10 to 10 do
   begin
      l:=i div j;
      m:= i div (-2);
      if (l=m) then counter := counter+1;
      l:=i mod j;
      m:= i mod (-2);
      if (l=m) then counter := counter+1;
   end;
   if counter = 42 then
   begin
      write(' DIVISION BY NEGATIVE OPERANDS IMPLEMENTED AND ');
      writeln('CONSISTENT');
   end else
      writeln(' INCONSISTENT DIVISION BY NEGATIVE OPERANDS');
   i:=-3;
   if (i div 2 = -1) then
      writeln(' QUOTIENT = TRUNC(A/B) FOR NEGATIVE OPERANDS')
   else
      writeln(' QUOTIENT = TRUNC(A/B-1) FOR NEGATIVE OPERANDS');
   if (i mod 2 = 1) then
      writeln(' MOD(A,B) LIES IN (0,B-1)')
   else
      writeln(' MOD RETURNS REMAINDER OF DIV');
end.
{TEST 6.7.2.2-5, CLASS=CONFORMANCE}

{ This program checks that maxint satisfies the conditions laid
  down in the Pascal Standard.
  The compiler fails if the program does not compile, or does
  not print pass. }

program t6p7p2p2d5(output);
var
   i : integer;
begin
   i:=-(-maxint);
   i:=-maxint;
   if odd(maxint) then
      i:=(maxint-((maxint div 2)+1))*2
   else
      i:=(maxint-(maxint div 2))*2;
   if i<=maxint then
      writeln(' PASS...6.7.2.2-5')
   else
      writeln(' FAIL...6.7.2.2-5: MAXINT')
end.
{TEST 6.7.2.2-6, CLASS=ERRORHANDLING}

{ This program causes an error to occur as the result of a binary
  integer operation is not in the interval 0 -> +maxint. }

program t6p7p2p2d6(output);
var
   i : integer;
begin
   i:=(maxint-(maxint div 2))*2+2;
   writeln(' ERROR NOT DETECTED...6.7.2.2-6')
end.
{TEST 6.7.2.2-7, CLASS=ERRORHANDLING}

{ This program causes an error to occur as the result of a binary
  integer operation is not in the interval 0 -> -maxint. }

program t6p7p2p2d7(output);
var
   i : integer;
begin
   i:=(-maxint+(maxint div 2))*2-2;
   writeln(' ERROR NOT DETECTED...6.7.2.2-7')
end.
{TEST 6.7.2.2-8, CLASS=ERRORHANDLING}

{ This program causes an error to occur as the second operand
  of the MOD operator is 0.
  The error should be detected at run-time. }

program t6p7p2p2d8(output);
var
   i, j, k : integer;
begin
   i:=6;
   j:=0;
   k:=i mod j;	     { an error as j=0 }
   writeln(' ERROR NOT DETECTED...6.7.2.2-8: MOD ZERO')
end.
{TEST 6.7.2.2-9, CLASS=DEVIANCE}

{ The unary operator plus can clearly only be applied to numeric
  operands. Hence this program should fail to compile.
  The compiler deviates if the program compiles and prints
  DEVIATES. }

program t6p7p2p2d9(output);
const
   capa = 'A';
begin
   writeln(+capa);
   writeln(' DEVIATES...6.7.2.2-9, UNARY OPERATOR')
end.
{TEST 6.7.2.3-1, CLASS=CONFORMANCE}

{ This test checks the operation of the boolean operators.
  The compiler fails if the program does not compile, or the
  program states that this is so. }

program t6p7p2p3d1(output);
var
   a,b,c : boolean;
   counter : integer;
begin
   counter:=0;
   a:=false;
   b:=false;
   { OR truth table }

   if a or b then
      writeln(' FAIL...6.7.2.3-1: OR')
   else
   begin
      b:=true;
      if a or b then
      begin
	 a:=true;
	 b:=false;
	 if a or b then
	 begin
	    b:=true;
	    if a or b then
	       counter:=counter+1
	    else
	       writeln(' FAIL...6.7.2.3-1: OR')
	 end
	 else
	    writeln(' FAIL...6.7.2.3-1: OR')
      end
      else
	 writeln(' FAIL...6.7.2.3-1: OR')
   end;

   { AND truth table }
   a:=false;
   b:=false;
   if a and b then
      writeln(' FAIL...6.7.2.3-1: AND')
   else
   begin
      b:=true;
      if a and b then
	 writeln(' FAIL...6.7.2.3-1: AND')
      else
      begin
	 a:=true;
	 b:=false;
	 if a and b then
	    writeln(' FAIL...6.7.2.3-1: AND')
	 else
	 begin
	    b:=true;
	    if a and b then
	       counter:=counter+1
	    else
	       writeln(' FAIL...6.7.2.3-1: AND')
	 end
      end
   end;

   { NOTE: NOT is sometimes badly implemented by wordwise
	   complementation, and for this reason the following
	   two tests may fail. }

   if (not false)=true then
      counter:=counter+1
   else
      writeln(' FAIL...6.7.2.3-1: NOT FALSE');

   if (not true)=false then
      counter:=counter+1
   else
      writeln(' FAIL...6.7.2.3-1: NOT TRUE');

   c:=false;
   a:=true;
   b:=false;
   if (a or b)=(b or a) then
      counter:=counter+1
   else
      writeln(' FAIL...6.7.2.3-1: COMMUTATION');

   if ((a or b)or c)=(a or(b or c)) then
      counter:=counter+1
   else
      writeln(' FAIL...6.7.2.3-1: ASSOCIATIVITY');

   if (a and(b or c))=((a and b)or(a and c)) then
      counter:=counter+1
   else
      writeln(' FAIL...6.7.2.3-1: DISTRIBUTION');

   if not(a or b)=((not a) and(not b)) then
      counter:=counter+1
   else
      writeln(' FAIL...6.7.2.3-1: DEMORGAN1');

   if not(a and b)=((not a) or (not b)) then
      counter:=counter+1
   else
      writeln(' FAIL...6.7.2.3-1: DEMORGAN2');

   if not(not a)= a then
      counter:=counter+1
   else
      writeln(' FAIL...6.7.2.3-1: INVERSION');

   if counter=10 then
      writeln(' PASS...6.7.2.3-1')
end.
{TEST 6.7.2.3-2, CLASS=IMPLEMENTATIONDEFINED}

{ This program determines if a boolean expression is partially
  evaluated if the value of the expression is determined before
  the expression is fully evaluated }

program t6p7p2p3d2(output);
var
   a:boolean;
   k,l:integer;
function sideeffect(var i:integer; b:boolean):boolean;
begin
   i:=i+1;
   sideeffect:=b;
end;

begin
   writeln(' TEST OF SHORT CIRCUIT EVALUATION OF (A AND B)');
   k:=0;
   l:=0;
   a:=sideeffect(k,false) and sideeffect(l,false);
   if (k=0) and (l=1) then
      writeln(' SECOND EXPRESSION EVALUATED...6.7.2.3-2')
   else
      if (k=1) and (l=0) then
	 writeln(' FIRST EXPRESSION EVALUATED...6.7.2.3-2')
      else
	 if(k=1) and (l=1) then
	    writeln(' BOTH EXPRESSIONS EVALUATED...6.7.2.3-2')
	 else
	    writeln(' FAIL...6.7.2.3-2');
end.
{TEST 6.7.2.3-3, CLASS=IMPLEMENTATIONDEFINED}

{ This program determines if a boolean expression is partially
  evaluated if the value of the expression is determined before
  the expression is fully evaluated }

program t6p7p2p3d3(output);
var
   a:boolean;
   k,l:integer;

function sideeffect(var i:integer; b:boolean):boolean;
begin
   i:=i+1;
   sideeffect:=b;
end;

begin
   writeln(' TEST OF SHORT CIRCUIT EVALUATION OF (A OR B)');
   k:=0;
   l:=0;
   a:=sideeffect(k,true) or sideeffect(l,true);
   if (k=0) and (l=1) then
      writeln(' SECOND EXPRESSION EVALUATED...6.7.2.3-3')
   else
      if (k=1) and (l=0) then
	 writeln(' FIRST EXPRESSION EVALUATED...6.7.2.3-3')
      else
	 if(k=1) and (l=1) then
	    writeln(' BOTH EXPRESSIONS EVALUATED...6.7.2.3-3')
	 else
	    writeln(' FAIL...6.7.2.3-3');
end.
{TEST 6.7.2.3-4, CLASS=DEVIANCE}

{ Are logical operators allowed  to be performed on integers?
  The compiler deviates if the program compiles and prints
  DEVIATES. }

program t6p7p2p3d4(output);
var
  i,j:integer;
begin
   i:=1; j:=2;
   i:=i and j;
   i:=i and 1;
   i:= i or j;
   i:=i or j;
   i:= not j;
   writeln(' DEVIATES...6.7.2.3-4, LOGICAL OPS.')
end.
{TEST 6.7.2.4-1, CLASS=ERRORHANDLING}

{ This test checks that operations on overlapping sets are detected.
  An error should be detected by the compiler or produced
  at run time. }

program t6p7p2p4d1(output);
var
   a,d : set of 0..10;
   b,c : set of 5..15;
begin
   b:=[5,10];
   a:=[0,5,10];
   d:=a+b;   {ok}
   b:=[5,10,15];
   c:=a+b;   {should be an error}
   writeln(' ERROR NOT DETECTED...6.7.2.4-1: OVERLAPPING SETS');
end.
{TEST 6.7.2.4-2, CLASS=CONFORMANCE}

{ This test checks the operation of set operators.
   The compiler fails if the program does not compile, or the
  program states that this is so. }

program t6p7p2p4d2(output);
var
   a,b,c,d:set of 0..10;
   counter:integer;
begin
   counter :=0;
   a:=[0,2,4,6,8,10];
   b:=[1,3,5,7,9];
   c:=[];
   d:=[0,1,2,3,4,5,6,7,8,9,10];
   if (a+b=d) then
      counter:=counter+1;
   if (d-b=a) then
      counter := counter+1;
   if (d*b=b) then
      counter:=counter+1;
   if(d*b-b=c) then
      counter:=counter+1;
   if (a+b+c=d) then
      counter:=counter+1;
   if(counter=5) then
      writeln(' PASS...6.7.2.4-2, SET OPERATORS')
   else
      writeln(' FAIL...6.7.2.4-2, SET OPERATORS');
end.
{TEST 6.7.2.4-3, CLASS=CONFORMANCE}

{ This program checks the operations of set operators on sets
  of constants and variables. The compiler fails if the program
  does not compile or the program states that this is so. }

program t6p7p2p4d3(output);
var
   a,b,c:set of 0..10;
   counter:integer;
begin
   counter:=0;
   a:=[0,2,4,6,8,10];
   b:=[1,3,5,7,9];
   c:=[0,1,2,3,4,5,6,7,8,9,10];
   if(a+[]=a) then
      counter:=counter+1;
   if(a+b=c) then
      counter:=counter+1;
   if(a+[1,3,5,7,9]=c) then
      counter:=counter+1;
   if(a-[]=a) then
      counter:=counter+1;
   if(c-a=b) then
      counter:=counter+1;
   if(c-[0,2,4,6,8,10]=b) then
      counter:=counter+1;
   if(a*a=a) then
      counter:=counter+1;
   if(a*[]=[]) then
      counter:=counter+1;
   if(a*b=[]) then
      counter:=counter+1;
   if(a*c=a) then
      counter:=counter+1;
   if(counter=10) then
      writeln(' PASS...6.7.2.4-3 SET OPERATORS')
   else
      writeln('FAIL...6.7.2.4-3 SET OPERATORS');
end.
{TEST 6.7.2.5-1, CLASS=CONFORMANCE}

{ This program tests the use of relational operators on strings.
  The operators denote lexicographic ordering according to the
  ordering of the character set.
  The compiler fails if the program does not compile, or the
  program states that this is so. }

program t6p7p2p5d1(output);
type
   string=packed array[1..7] of char;
var
   string1,
   string2 : string;
begin
   string1:='STRING1';
   string2:='STRING2';
   if (string1<>string2) and (string1<string2) then
   begin
      string1:='STRINGS';
      string2:='STRINGZ';
      if (string1<>string2) and (string1<string2) then
	 writeln(' PASS...6.7.2.5-1')
      else
	 writeln(' FAIL...6.7.2.5-1')
   end
   else
      writeln(' FAIL...6.7.2.5-1')
end.
{TEST 6.7.2.5-2, CLASS=CONFORMANCE}

{ This test checks the use of relational operators on sets.
  Thc compiler fails if the program does not compile, or the
  program states that this is so. }

program t6p7p2p5d2(output);
var
   a,b:set of 0..10;
  c,counter:integer;
begin
   counter:=0;
   a:=[0,1,2,3,4,5];
   b:=[2,3,4];
   c:=3;
   if(a=[0,1,2,3,4,5]) then
     counter:=counter+1;
   if(a<>b) then
      counter:=counter+1;
   if(b<>[1,2,3,4,5]) then
      counter:=counter+1;
   if(b<=a) then
      counter:=counter+1;
   if(a>=b) then
      counter:=counter+1;
   if([0,1]<=a) then
      counter:=counter+1;
   if([1,2,3,4,5,6,10]>=b) then
      counter:=counter+1;
   if (1 in a) then
      counter:=counter+1;
   if(c in b) then
      counter:=counter+1;
   if(counter=9) then
      writeln(' PASS...6.7.2.5-2 SET RELATIONAL OPERATORS')
   else
      writeln(' FAIL...6.7.2.5-2 SET RELATIONAL OPERATORS');
end.
{TEST 6.7.2.5-3, CLASS=DEVIANCE}

{ This test checks that file comparisons are not allowed.
  The semantics of this situation are particularly ill-defined,
  and not within standard Pascal. The compiler deviates if the
  program compiles and prints DEVIATES. }

program t6p7p2p5d3(output);
var
   f:text;
begin
   rewrite(f);
   if f=output then
      writeln(' FAIL1...6.7.2.5-3, CONTENTS COMPARED')
   else
      writeln(' FAIL2...6.7.2.5-3, DESCRIPTORS COMPARED')
end.
{TEST 6.7.2.5-4, CLASS=DEVIANCE}

{ Are relational operators permitted to concatenate?
  The compiler deviates if the program compiles and
  prints DEVIATES. }

program t6p7p2p5d4(output);
var
   x,y,z:integer;
  b:boolean;
begin
   x:=1;
   y:=2;
   z:=3;
   b:=(x<y<z);
   writeln(' DEVIATES...6.7.2.5-4, REL. OPS. ')
end.
{TEST 6.8.2.1-1, CLASS=CONFORMANCE}

{ Does the compiler allow all the possible empty clauses?
  The compiler fails if the program does not compile and print
  PASS. }

program t6p8p2p1d1(output);
var
   b:boolean;
   r1:record
       x:real;
       a:integer;   {1}
       end;
   r2:record
       case b:boolean of
       true:(
	     c:real;
	     d:char;   {2}
	    );
       false:
	     (e:integer);   {3}
       end;
begin
   b:=true;
  if b then;   {4}
   if b then else;   {5}
   repeat
      b:= not b;   {6}
   until b;
   while b do
   begin
      b:=not b;   {7}
   end;
   with r1 do;	 {8}
  r1.a:=1;
   case r1.a of
   0:  b:=false;
   1:  ;   {9}
   2:  b:=true;   {10}
   end;
   writeln(' PASS...6.8.2.1-1, EMPTY STATEMENT');   {11}
end.
{TEST 6.8.2.2-1, CLASS=IMPLEMENTATIONDEFINED}

{ This program determines whether selection of a variable involving
  the indexing of an array occurs before or after the evaluation
  of the expression in an assignment statement. }

program t6p8p2p2d1(output);
var
   i : integer;
   a : array[1..3] of integer;
function sideeffect(var i:integer) : integer;
begin
   i:=i+1;
   sideeffect:=i
end;

begin
   writeln(' TEST OF BINDING ORDER (A[I] := EXP)');
   i:=1;
   a[1]:=0;
   a[2]:=0;
   a[i]:=sideeffect(i);
   if a[1]=2 then
      writeln(' SELECTION THEN EVALUATION...6.8.2.2-1')
   else
      if a[2]=2 then
	 writeln(' EVALUATION THEN SELECTION...6.8.2.2-1')
end.
{TEST 6.8.2.2-2, CLASS=IMPLEMENTATIONDEFINED}

{ This program is similar to 6.8.2.2-1, except that the
  selection of the variable involves the dereferencing of
  a pointer. }

program t6p8p2p2d2(output);
type
   rekord=record
	    a : integer;
	    b : boolean;
	    link : ^rekord
	 end;
   poynter=^rekord;
var
   temp, ptr : poynter;
function sideeffect(var p : poynter) : integer;
begin
   p:=p^.link;
   sideeffect:=2;
end;

begin
   writeln(' TEST OF BINDING ORDER (P^ := EXP)');
   new(ptr);
   ptr^.a:=1;
   ptr^.b:=true;
   new(temp);
   ptr^.link:=temp;
   temp^.a:=0;
   temp^.b:=false;
   temp:=ptr;
   ptr^.a:=sideeffect(ptr);
   if temp^.a=2 then
      writeln(' SELECTION THEN EVALUATION...6.8.2.2-2')
   else
      if temp^.link^.a=2 then
	 writeln(' EVALUATION THEN SELECTION...6.8.2.2-2')
end.
{TEST 6.8.2.4-1, CLASS=CONFORMANCE}

{ This test checks that non-local goto statements are allowed }

program t6p8p2p4d1(output);
label 1;
var
   b:boolean;
procedure q;
begin
   b:=true;
   goto 1;
end;   {of q}

begin	{main}
   q;
   b:=false;
1: if b then
      writeln(' PASS...6.8.2.4-1 NON-LOCAL GOTO')
   else
      writeln(' FAIL...6.8.2.4-1 NON-LOCAL GOTO');
end.
{TEST 6.8.2.4-2, CLASS=DEVIANCE}

{ This test checks whether jumps between branches of an if
  statement are allowed.
  The compiler deviates if the program compiles and the
  program prints DEVIATES. }

program t6p8p2p4d2(output);
label
   1,2;
var
   i:integer;
begin
   i:=5;
   if (i<10) then
      goto 1
   else
      1:writeln(' DEVIATES...6.8.2.4-2');
   if (i>10) then
      2: writeln(' DEVIATES...6.8.2.4-2')
   else
     goto 2;
end.
{TEST 6.8.2.4-3, CLASS=DEVIATES}

{ This test checks whether jumps between branches of a
  case statement are allowed. The compiler deviates if the
  program compiles and the program prints DEVIATES. }

program t6p8p2p4d3(output);
label
   4;
var
   i:1..3;
begin
   for i:=1 to 2 do
      case i of
      1:  ;
      2: goto 4;
      3:4:
	 writeln(' DEVIATES...6.8.2.4-3');
      end;
end.
{TEST 6.8.2.4-4,CLASS=DEVIANCE}

{ This test checks that a goto statement causes an error
  when the statement(S) to which control is transferred is
  not activated either by S or a statement in the statement
  sequence of which S is an immediate constituent.
  The compiler deviates if the compiler prints DEVIATES. }

program t6p8p2p4d4(output);
var
   flag:boolean;

procedure a(i:integer;b:boolean);
label 99;
   procedure r;
   begin
      goto 99;
   end;
begin
   case i of
   0:99: if (b) then
	 writeln(' DEVIATES...6.8.2.4-4')
      else
	 if flag then
	    writeln(' PASS...6.8.2.4-4')
	 else begin
	    flag := true;
	    a(1,false);
	 end;
   1:
      a(2,true);
   2:
      r;
   end;
end;

begin
   flag := false;
   a(0,false);
end.
{TEST 6.8.3.4-1 CLASS=CONFORMANCE}

{ This test checks a nested if statement whose syntax is apparently
  ambiguous. The compiler fails if the program does not compile
  or the program states this by writing FAIL. }

program t6p8p3p4d1(output);
const
   off=false;
var
   b:boolean;
begin
   for b:=false to true do
      begin
      if b then
	 if off then
	    writeln(' FAIL...6.8.3.4-1')
	 else
	    begin
	    if not b then
		writeln(' FAIL...6.8.3.4-1')
	    else
	       writeln(' PASS...6.8.3.4-1');
	    end;
      end;
end.
{TEST 6.8.3.5-1, CLASS=CONFORMANCE}

{ This test checks that a minimal case statement will compile.
  The compiler fails if the program does not compile. }

program t6p8p3p5d1(output);
var
   i:integer;
begin
   i:=1;
   case i of
   1:
   end;
   writeln(' PASS...6.8.3.5-1, CASE');
end.
{TEST 6.8.3.5-2, CLASS=QUALITY}

{ This test checks that the case constants are of the same type
  as the case index. A compiler of good quality will detect that
  one path of the case statement cannot be taken and issue a
  warning message.
  The case-index in this test is a subrange and the case-constants
  are of the base type of the subrange. }

program t6p8p3p5d2(output);
type
   day=(mon,tue,wed);
var
   a:integer;
   d:mon..tue;
begin
   for d:=mon to tue do
      case d of
      mon: a:=1;
      tue: a:=2;
      wed: a:=3;   { could give a warning }
      end;
   writeln(' QUALITY TEST - WARNINGS FOR IMPOSSIBLE CASES');
   writeln(' PASS...6.8.3.5-2, CASE CONSTANTS');
end.
{TEST 6.8.3.5-3, CLASS=DEVIANCE}

{ This test checks that the constants of a case statement
  cannot be strings. The compiler deviates if the program
  compiles and prints DEVIATES. }

program t6p8p3p5d3(output);
var
   a:char;
   i:integer;
begin
   for a:= 'a' to 'd' do
      case a of
      'a': i:=1;
      'b': i:=i+1;
      'c': i:=i+1;
      'de': i:=i+1;
      end;
   writeln(' DEVIATES...6.8.3.5-3, CASE');
end.
{TEST 6.8.3.5-4, CLASS=CONFORMANCE}

{ This test checks that a compiler handles a sparse case adequately
  Most compilers issue a jump table for a case, regardless
  of its structure. It is easy to optimise case statements
  to generate conditional statements if this is more compact.
  The compiler fails if the program does not compile
  or the program fails in execution. }

program t6p8p3p5d4(output);
var
   i,j:integer;
begin
   i:=-1000;
   for j:=1 to 2 do
      case i of
      -1000: i:=-i;
      1000: writeln(' PASS...6.8.3.5-4, SPARSE CASE');
      end;
end.
{TEST 6.8.3.5-5, CLASS=ERRORHANDLING}

{ This test checks the type of error produced when the case
  statement does not contain a constant of the selected value.
  An execution error should be produced. }

program t6p8p3p5d5(output);
var
   i:integer;
begin
   i:=0;
   case i of
   -3,3: writeln(' FAIL...6.8.3.5-5, CASE');
   end;
   writeln(' ERROR NOT DETECTED...6.8.3.5-5, CASE CONSTANT');
end.
{TEST 6.8.3.5-6, CLASS=ERRORHANDLING}

{ This test is similar to the previous one - a case statement
  is given without a case-constant of the selected value. This
  time the value is a long way outside the case. An error should
  be produced at execution time. }

program t6p8p3p5d6(output);
var
   i:integer;
begin
   i:=1000;
   case i of
   -3,3: writeln(' FAIL...6.8.3.5-6, CASE');
   end;
   writeln(' ERROR NOT DETECTED...6.8.3.5-6, CASE CONSTANT');
end.
{TEST 6.8.3.5-7,CLASS=ERRORHANDLING}

{ This test contains an invalid real case-constant with an integer
  case expression. If the program compiles the effect at run-time
  could be curious. }

program t6p8p3p5d7(output);
var
   a,i:integer;
begin
   for i:=1 to 4 do
      case i of
      1,2: a:=1;
      2.5: writeln(' DEVIATES...6.8.3.5-7. CASE');
      3:   a:=2;
      4e0: writeln(' DEVIATES...6.8.3.5-7, CASE');
      end;
   writeln(' DEVIATES...6.8.3.5-7, CASE');
end.
{TEST 6.8.3.5-8, CLASS=QUALITY}

{ This test checks a large populated case statement to check the
  limit on the size of code is not a serious one.
  The compiler has a small limit on the size of the case
  statement if the program does not compile and print PASS. }

program t6p8p3p5d8(output);
var
   sum:integer;
   i:0..255;
begin
   sum :=0;
   for i:=0 to 255 do
      case i of
       0 : sum := sum + i;
       1 : sum := sum + i;
       2 : sum := sum + i;
       3 : sum := sum + i;
       4 : sum := sum + i;
       5 : sum := sum + i;
       6 : sum := sum + i;
       7 : sum := sum + i;
       8 : sum := sum + i;
       9 : sum := sum + i;
      10 : sum := sum + i;
      11 : sum := sum + i;
      12 : sum := sum + i;
      13 : sum := sum + i;
      14 : sum := sum + i;
      15 : sum := sum + i;
      16 : sum := sum + i;
      17 : sum := sum + i;
      18 : sum := sum + i;
      19 : sum := sum + i;
      20 : sum := sum + i;
      21 : sum := sum + i;
      22 : sum := sum + i;
      23 : sum := sum + i;
      24 : sum := sum + i;
      25 : sum := sum + i;
      26 : sum := sum + i;
      27 : sum := sum + i;
      28 : sum := sum + i;
      29 : sum := sum + i;
      30 : sum := sum + i;
      31 : sum := sum + i;
      32 : sum := sum + i;
      33 : sum := sum + i;
      34 : sum := sum + i;
      35 : sum := sum + i;
      36 : sum := sum + i;
      37 : sum := sum + i;
      38 : sum := sum + i;
      39 : sum := sum + i;
      40 : sum := sum + i;
      41 : sum := sum + i;
      42 : sum := sum + i;
      43 : sum := sum + i;
      44 : sum := sum + i;
      45 : sum := sum + i;
      46 : sum := sum + i;
      47 : sum := sum + i;
      48 : sum := sum + i;
      49 : sum := sum + i;
      50 : sum := sum + i;
      51 : sum := sum + i;
      52 : sum := sum + i;
      53 : sum := sum + i;
      54 : sum := sum + i;
      55 : sum := sum + i;
      56 : sum := sum + i;
      57 : sum := sum + i;
      58 : sum := sum + i;
      59 : sum := sum + i;
      60 : sum := sum + i;
      61 : sum := sum + i;
      62 : sum := sum + i;
      63 : sum := sum + i;
      64 : sum := sum + i;
      65 : sum := sum + i;
      66 : sum := sum + i;
      67 : sum := sum + i;
      68 : sum := sum + i;
      69 : sum := sum + i;
      70 : sum := sum + i;
      71 : sum := sum + i;
      72 : sum := sum + i;
      73 : sum := sum + i;
      74 : sum := sum + i;
      75 : sum := sum + i;
      76 : sum := sum + i;
      77 : sum := sum + i;
      78 : sum := sum + i;
      79 : sum := sum + i;
      80 : sum := sum + i;
      81 : sum := sum + i;
      82 : sum := sum + i;
      83 : sum := sum + i;
      84 : sum := sum + i;
      85 : sum := sum + i;
      86 : sum := sum + i;
      87 : sum := sum + i;
      88 : sum := sum + i;
      89 : sum := sum + i;
      90 : sum := sum + i;
      91 : sum := sum + i;
      92 : sum := sum + i;
      93 : sum := sum + i;
      94 : sum := sum + i;
      95 : sum := sum + i;
      96 : sum := sum + i;
      97 : sum := sum + i;
      98 : sum := sum + i;
      99 : sum := sum + i;
      100 : sum := sum + i;
      101 : sum := sum + i;
      102 : sum := sum + i;
      103 : sum := sum + i;
      104 : sum := sum + i;
      105 : sum := sum + i;
      106 : sum := sum + i;
      107 : sum := sum + i;
      108 : sum := sum + i;
      109 : sum := sum + i;
      110 : sum := sum + i;
      111 : sum := sum + i;
      112 : sum := sum + i;
      113 : sum := sum + i;
      114 : sum := sum + i;
      115 : sum := sum + i;
      116 : sum := sum + i;
      117 : sum := sum + i;
      118 : sum := sum + i;
      119 : sum := sum + i;
      120 : sum := sum + i;
      121 : sum := sum + i;
      122 : sum := sum + i;
      123 : sum := sum + i;
      124 : sum := sum + i;
      125 : sum := sum + i;
      126 : sum := sum + i;
      127 : sum := sum + i;
      128 : sum := sum + i;
      129 : sum := sum + i;
      130 : sum := sum + i;
      131 : sum := sum + i;
      132 : sum := sum + i;
      133 : sum := sum + i;
      134 : sum := sum + i;
      135 : sum := sum + i;
      136 : sum := sum + i;
      137 : sum := sum + i;
      138 : sum := sum + i;
      139 : sum := sum + i;
      140 : sum := sum + i;
      141 : sum := sum + i;
      142 : sum := sum + i;
      143 : sum := sum + i;
      144 : sum := sum + i;
      145 : sum := sum + i;
      146 : sum := sum + i;
      147 : sum := sum + i;
      148 : sum := sum + i;
      149 : sum := sum + i;
      150 : sum := sum + i;
      151 : sum := sum + i;
      152 : sum := sum + i;
      153 : sum := sum + i;
      154 : sum := sum + i;
      155 : sum := sum + i;
      156 : sum := sum + i;
      157 : sum := sum + i;
      158 : sum := sum + i;
      159 : sum := sum + i;
      160 : sum := sum + i;
      161 : sum := sum + i;
      162 : sum := sum + i;
      163 : sum := sum + i;
      164 : sum := sum + i;
      165 : sum := sum + i;
      166 : sum := sum + i;
      167 : sum := sum + i;
      168 : sum := sum + i;
      169 : sum := sum + i;
      170 : sum := sum + i;
      171 : sum := sum + i;
      172 : sum := sum + i;
      173 : sum := sum + i;
      174 : sum := sum + i;
      175 : sum := sum + i;
      176 : sum := sum + i;
      177 : sum := sum + i;
      178 : sum := sum + i;
      179 : sum := sum + i;
      180 : sum := sum + i;
      181 : sum := sum + i;
      182 : sum := sum + i;
      183 : sum := sum + i;
      184 : sum := sum + i;
      185 : sum := sum + i;
      186 : sum := sum + i;
      187 : sum := sum + i;
      188 : sum := sum + i;
      189 : sum := sum + i;
      190 : sum := sum + i;
      191 : sum := sum + i;
      192 : sum := sum + i;
      193 : sum := sum + i;
      194 : sum := sum + i;
      195 : sum := sum + i;
      196 : sum := sum + i;
      197 : sum := sum + i;
      198 : sum := sum + i;
      199 : sum := sum + i;
      200 : sum := sum + i;
      201 : sum := sum + i;
      202 : sum := sum + i;
      203 : sum := sum + i;
      204 : sum := sum + i;
      205 : sum := sum + i;
      206 : sum := sum + i;
      207 : sum := sum + i;
      208 : sum := sum + i;
      209 : sum := sum + i;
      210 : sum := sum + i;
      211 : sum := sum + i;
      212 : sum := sum + i;
      213 : sum := sum + i;
      214 : sum := sum + i;
      215 : sum := sum + i;
      216 : sum := sum + i;
      217 : sum := sum + i;
      218 : sum := sum + i;
      219 : sum := sum + i;
      220 : sum := sum + i;
      221 : sum := sum + i;
      222 : sum := sum + i;
      223 : sum := sum + i;
      224 : sum := sum + i;
      225 : sum := sum + i;
      226 : sum := sum + i;
      227 : sum := sum + i;
      228 : sum := sum + i;
      229 : sum := sum + i;
      230 : sum := sum + i;
      231 : sum := sum + i;
      232 : sum := sum + i;
      233 : sum := sum + i;
      234 : sum := sum + i;
      235 : sum := sum + i;
      236 : sum := sum + i;
      237 : sum := sum + i;
      238 : sum := sum + i;
      239 : sum := sum + i;
      240 : sum := sum + i;
      241 : sum := sum + i;
      242 : sum := sum + i;
      243 : sum := sum + i;
      244 : sum := sum + i;
      245 : sum := sum + i;
      246 : sum := sum + i;
      247 : sum := sum + i;
      248 : sum := sum + i;
      249 : sum := sum + i;
      250 : sum := sum + i;
      251 : sum := sum + i;
      252 : sum := sum + i;
      253 : sum := sum + i;
      254 : sum := sum + i;
      255 : sum := sum + i;
      end;
   writeln(' QUALITY TEST - SIZE OF CASE STATEMENT');
   if sum = 32640 then
      writeln(' PASS...6.8.3.5-8')
   else
      writeln(' FAIL...6.8.3.5-8');
end.
{TEST 6.8.3.5-9, CLASS=DEVIANCE}

{ This test checks that the compiler detects that case-constants
  and the case-index are of different types.
  The compiler deviates if the program compiles and the program
  prints deviates. }

program t6p8p3p5d9(output);
var
   i,counter:integer;
begin
   counter:= 0;
   for i:= 1 to 4 do
      case i of
      1: counter:=counter+1;
      2.0: counter:=counter+1;
      3: counter:=counter+1;
      4e0: counter:=counter+1;
      end;
   if counter=4 then
      writeln(' DEVIATES...6.8.3.5-9, CASE CONSTANTS')
   else
      writeln(' FAILS...6.8.3.5-9, CASE CONSTANTS');
end.
{TEST 6.8.3.5-10, CLASS=DEVIANCE}

{ This test checks that the compiler detects real case constants
  and a real case index, even when the values are integers.
  The compiler fails if the program compiles and the program
  prints FAILS. }

program t6p8p3p5d10(output);
var
   i,counter:integer;
   r:real;
begin
   counter:= 0;
   for i:= 1 to 4 do
   begin
      r:=i;
      case r of
      1.0: counter:=counter+1;
      2.0: counter:=counter+1;
      3.0: counter:=counter+1;
      4e0: counter:=counter+1;
      end;
   end;
   if counter=4 then
      writeln(' DEVIANCE...6.8.3.5-10, CASE CONSTANTS')
   else
      writeln(' FAILS...6.8.3.5-10, CASE CONSTANTS');
end.
{TEST 6.8.3.5-11, CLASS=DEVIANCE}

{ This test checks that the compiler detects that a case index
  and the case constants are of different types.
  The compiler deviates if the program compiles and the program
  prints DEVIATES. }

program t6p8p3p5d11(output);
var
   i,counter:integer;
   r:real;
begin
   counter:= 0;
   for i:= 1 to 4 do
   begin
      r:=i;
      case r of
      1: counter:=counter+1;
      2: counter:=counter+1;
      3: counter:=counter+1;
      4: counter:=counter+1;
      end;
   end;
   if counter=4 then
      writeln(' DEVIATES...6.8.3.5-11, CASE CONSTANTS')
   else
      writeln(' PASS...6.8.3.5-11, CASE CONSTANTS');
end.
{TEST 6.8.3.5-12, CLASS=DEVIANCE}

{ Some processors allow subrange-like lists to be used as case-constant
  elements. This test checks to see if this is allowed. It is
  not standard Pascal. The compiler deviates if the program
  compiles and prints DEVIATES. }

program t6p8p3p5d12(output);
var
   thing:(a,b,c,d,e,f);
begin
   thing:=a;
   while thing<>f do begin
      case thing of
      a..d: thing := succ(thing);
      e:    thing:=f
      end
   end;
   writeln(' DEVIATES...6.8.3.5-12, CASE CONSTANTS')
end.
{TEST 6.8.3.5-13, CLASS=DEVIANCE}

{ Similar to test 6.8.3.5-12, this test checks the subrange
  case extension, which may not be safely implemented. This program
  is utter confused garbage and indicates the kinds of checks
  needed. The compiler deviates if the program compiles and
  prints DEVIATES. }

program t6p8p3p5d13(output);
var
   t,thing:(a,b,c,d,e,f,g,h);
begin
   for thing:=a to g do begin
      case thing of
      a..e: t:=thing;
      d..g: t:=succ(thing);
      b:    t:=pred(thing)
      end
   end;
   writeln(' DEVIATES...6.8.3.5-13, CASE CONSTANTS')
end.
{TEST 6.8.3.5-14, CLASS=EXTENSION, SUBCLASS=CONFORMANCE}

{ This test checks whether an otherwise clause in a case statement
  is accepted. The convention is that adopted at the UCSD Pascal
  workshop in July 1978. The extension is accepted if the program
  compiles and prints EXTENSION - PASS }

program t6p8p3p5d14(output);
var
   i,j,k,counter:integer;
begin
   counter:=0;
   for i:=0 to 10 do
      case i of
      1,3,5,7,9:
	 counter:=counter+1;
      otherwise
	 j:=counter;
	 k:=j;
      end;
   if (counter = 5) then
      writeln(' EXTENSION - PASS...6.8.3.5-14, OTHERWISE')
   else
      writeln(' EXTENSION - FAIL...6.8.3.5-14, OTHERWISE');
end.
{TEST 6.8.3.7-1, CLASS=CONFORMANCE}

{ This test checks that a repeat loop is executed at least once.
  The compiler fails if the program prints FAILS. }

program t6p8p3p7d1(output);
var
   counter:integer;
   bool:boolean;
begin
   bool:=true;
   counter:=0;
   repeat
      counter:=counter+1
   until bool;
   if(counter=1) then
      writeln(' PASS...6.8.3.7-1, REPEAT')
   else
      writeln(' FAIL...6.8.3.7-1, REPEAT');
end.
{TEST 6.8.3.7-2, CLASS=CONFORMANCE}

{ This test checks that a loop containing no statements
  is executed until the expression is true.
  The compiler fails if the program does not compile or the
  program prints FAIL. }

program t6p8p3p7d2(output);
var
  a:integer;

function bool : boolean;
begin
   a:=a+1;
   bool := a>=5;
end;

begin
   a:=0;
   repeat
   until bool;
   if (a=5) then
      writeln(' PASS...6.8.3.7-2, EMPTY REPEAT')
   else
      writeln(' FAIL...6.8.3.7-2, EMPTY REPEAT');
end.
{TEST 6.8.3.7-3, CLASS=CONFORMANCE}

{ This test clecks that an apparently infinite loop is allowed
  by the compiler. Some compilers may detect the loop as being
  infinite. The compiler fails if the program does not compile. }

program t6p8p3p7d3(output);
label
   100;
const
   eternity = false;
var
   i:integer;
begin
   i:=0;
   repeat
      i:=i+1;
      if (i>50) then
	 goto 100;
   until eternity;
100:
   writeln(' PASS...6.8.3.7-3, REPEAT');
end.
{TEST 6.8.3.8-1, CLASS=CONFORMANCE}

{ This test checks that a while loop is not entered
  if the initial value of the boolean expression is false.
  The compiler fails if the program prints FAIL. }

program t6p8p3p8d1(output);
var
   bool:boolean;
   counter:integer;
begin
   counter:=0;
   bool:=false;
   while bool do
   begin
      counter:=counter+1;
      bool:=false;
   end;
   if (counter=0) then
      writeln(' PASS...6.8.3.8-1, WHILE')
   else
      writeln(' FAIL...6.8.3.8-1, WHILE');
end.
{TEST 6.8.3.8-2, CLASS=CONFORMANCE}

{ This test checks that the compiler will accept a while
  loop containing no statements. The compiler fails if the
  program does not compile or the program prints FAIL. }

program t6p8p3p8d2(output);
var
   a:integer;

function bool:boolean;
begin
   a:=a+1;
   bool:= (a>=5);
end;

begin
   a:=0;
   while not bool do ;
   if (a=5) then
      writeln(' PASS...6.8.3.8-2, EMPTY WHILE')
   else
      writeln(' FAIL...6.8.3.8-2, EMPTY WHILE');
end.
{TEST 6.8.3.9-1, CLASS=CONFORMANCE}

{ This program checks that assignment follows the  evaluation of
  both expressions  in a for statement.
  The compiler fails if the program prints FAIL. }

program t6p8p3p9d1(output);
var
   i,j:integer;
begin
   i:=1;
   j:=0;
   for i:= (i+1) to (i+10) do
   begin
      j:=j+1;
      writeln(i);
   end;
   if (j=10) then
      writeln(' PASS...6.8.3.9-1, FOR')
   else
      writeln(' FAIL...6.8.3.9-1, FOR');
end.
{TEST 6.8.3.9-2, CLASS=DEVIANCE}

{ This program checks that an assignment cannot be made to a
  for statement control variable.
  The compiler deviates if the program compiles and prints
  DEVIATES. }

program t6p8p3p9d2(output);
var
  i,j:integer;
begin
   j:=0;
   for i:=1 to 10 do
   begin
      j:=j+1;
      i:=i+1;
      writeln(j,i);
   end;
   writeln(' DEVIATES...6.8.3.9-2, FOR');
end.
{TEST 6.8.3.9-3, CLASS=DEVIANCE}

{ This test checks that an error is produced when an
  assignment is made to a for statement control variable.
  The compiler deviates if the program compiles and prints
  DEVIATES. }

program t6p8p3p9d3(output);
var
   i,j:integer;

procedure nasty (var n:integer);
begin
   n:=n+1;
end;

begin
   j:=0;
   for i:=1 to 10 do
   begin
      j:=j+1;
      nasty(i);
   end;
   writeln(' DEVIATES...6.8.3.9-3, FOR');
end.
{TEST 6.8.3.9-4, CLASS=DEVIANCE}

{ This program tests that an error is produced when an assignment
  is made to a for statement control variable.
  The compiler deviates if the program compiles and prints
  DEVIATES. }

program t6p8p3p9d4(output);
var
   i,j:integer;

procedure verynasty;
begin
   i:=i+1;
end;

begin
   j:=0;
   for i:= 1 to 10 do
   begin
      j:=j+1;
      verynasty;
   end;
   writeln(' DEVIATES...6.8.3.9-4, FOR');
end.
{TEST 6.8.3.9-5, CLASS=ERRORHANDLING}

{ This test checks that the use of a for statement control
  variable after the completion of the for statement, and
  without an intervening assignment is detected. }

program t6p8p3p9d5(output);
var
   i,j,k,m:integer;
begin
   i:=100;
   j:=1;
   k:=10;
   m:=0;
   for i:=j to k do
   begin
      m:=m+1;
   end;
   writeln('  THE VALUE OF I =',i);
   writeln(' ERROR NOT DETECTED...6.8.3.9-5, FOR');
end.
{TEST 6.8.3.9-6, CLASS=ERRORHANDLING}

{ This program uses a for statement control variable after a
  for loop which is not entered. The control variable should be
  undefined after the for statement. }

program t6p8p3p9d6(output);
var
   i,j,k,m:integer;
begin
   i:=100;
   k:=1;
   m:=0;
   j:=10;
   for i:=j to k do
   begin
      m:=m+1;
   end;
   writeln(' THE VALUE OF I =',i);
   writeln(' ERROR NOT DETECTED...6.8.3.9-6, FOR');
end.
{TEST 6.8.3.9-7, CLASS=CONFORMANCE}

{ This test checks that extreme values may be used in a for
  loop. This will break a simply implemented for loop.
  In some compilers the succ test may fail at the last increment
  and cause wraparound(overflow) - leading to an infinite loop. }

program t6p8p3p9d7(output);
var
   i,j:integer;
begin
   j:=0;
   for i:= (maxint-10) to maxint do
     j:=j+1;
   for i:= (-maxint+10) downto -maxint do
      j:=j+1;
   if j = 22 then
      writeln(' PASS...6.8.3.9-7, FOR LOOP')
   else
      writeln(' FAIL...6.8.3.9-7, FOR LOOP');
end.
{TEST 6.8.3.9-8, CLASS=CONFORMANCE}

{ This program checks that a control variable of a for statement
  is not undefined if the for statement is left via a goto
  statement. The compiler fails if the program does not compile
  or the program prints FAIL. }

program t6p8p3p9d8(output);
label 100;
var
   i,j:integer;
begin
   j:=1;
   for i:=1 to 10 do
   begin
      if (j=5) then
	 goto 100;
      j:=j+1;
   end;
100:
   if i=j then
      writeln(' PASS...6.8.3.9-8, FOR')
   else
      writeln(' FAIL...6.8.3.9-8, FOR');
end.
{TEST 6.8.3.9-9, CLASS=DEVIANCE}

{ This program tests whether a non local variable at an intermediate
  level can be used as a for statement control variable.
  The program deviates if the program compiles and prints
  DEVIATES. }

program t6p8p3p9d9(output);

procedure p;
var
   i:integer;

   procedure loop;
   var
      j:integer;
   begin
      j:=0;
      for i:=1 to 10 do
	 j:=j+1;
   end;
begin
   loop
end;

begin
   p;
   writeln(' DEVIATES...6.8.3.9-9, FOR');
end.
{TEST 6.8.3.9-10, CLASS=DEVIANCE}

{ This program tests whether a real number can be assigned to
  a for statement control variable. The compiler deviates
  if the program compiles and prints DEVIATES. }

program t6p8p3p9d10(output);
var
   i:integer;
   counter:integer;
begin
   counter:=0;
   for i:=0.0 to 3.5 do
      counter:=counter+1;
   if(counter=4) then
      writeln(' DEVIATES...6.8.3.9-10, FOR EXPRESSION ROUNDED')
   else
      writeln(' DEVIATES...6.8.3.9-10, FOR EXPRESSION TRUNCATED');
end.
{TEST 6.8.3.9-11, CLASS=DEVIANCE}

{ This test checks whether a for statement control variable
  can be a component variable.
  The compiler deviates if the program compiles and prints
  DEVIATES. }

program t6p8p3p9d11(output);
var
   rec:record
	 i,j:integer;
       end;
begin
   for rec.i:=0 to 10 do
      rec.j := rec.i;
   with rec do
      for i := 0 to 10 do
	 j:=i;
   writeln(' DEVIATES...6.8.3.9-11, FOR');
end.
{TEST 6.8.3.9-12, CLASS=DEVIATES}

{ This test checks whether a for statement control variable
  can be a pointer variable.
  The compiler deviates if the program compiles and prints
  DEVIATES. }

program t6p8p3p9d12(output);
type
   int = ^integer;
var
   ptr:int;
   j:integer;
begin
   j:=0;
   new(ptr);
   for ptr^ := 0 to 10 do
      j:=j+1;
   writeln(' DEVIATES...6.8.3.9-12, FOR');
end.
{TEST 6.8.3.9-13, CLASS=DEVIANCE}

{ This program tests whether a formal parameter  can be used
  as a for statement control variable.
  The program deviates if the program compiles and prints
  DEVIATES. }

program t6p8p3p9d13(output);

procedure p;
var
   i:integer;

   procedure loop(var i:integer);
   var
      j:integer;
   begin
      j:=0;
      for i:=1 to 10 do
	 j:=j+1;
   end;
begin
   i:=10;
   loop(i)
end;

begin
   p;
   writeln(' DEVIATES...6.8.3.9-13, FOR');
end.
{TEST 6.8.3.9-14, CLASS=DEVIANCE}

{ This program tests whether a global variable (at program level)
  can be used as a for statement control variable.
  The program deviates if the program compiles and prints
  DEVIATES. }

program t6p8p3p9d14(output);
var
   i:integer;

procedure p;

   procedure loop;
   var
      j:integer;
   begin
      j:=0;
      for i:=1 to 10 do
	 j:=j+1;
   end;
begin
   loop
end;

begin
   p;
   writeln(' DEVIATES...6.8.3.9-14, FOR');
end.
{TEST 6.8.3.9-15, CLASS=CONFORMANCE}

{ This program checks the order of evaluation of the limit expressions
  in a for statement.
  The compiler fails if the program prints FAIL. }

program t6p8p3p9d15(output);
var
   i,j,k:integer;

function f(var k:integer) : integer;
begin
   k:=k+1;
   f:=k;
end;

begin
   k:=0;
   j:=0;
   for i:=f(k) to f(k)+10 do
   begin
      j:=j+1;
      writeln(i);
   end;
   if (j=12) then
      writeln(' PASS...6.8.3.9-15, FOR')
   else
      writeln(' FAIL...6.8.3.9-15, FOR');
end.
{TEST 6.8.3.9-16, CLASS=DEVIANCE}

{ This test checks the type of error produced when a for statement
  control variable value is read during the execution of the for
  statement. The compiler deviates if the program compiles and
  prints DEVIATES. }

program t6p8p3p9d16(output,f);
var
   f:text;
   i,j:integer;
begin
   j:=0;
   rewrite(f);
   writeln(f,5,5,5,5,5);
   reset(f);
   for i := 1 to 10 do
   begin
      if (i<5) then
	 read(f,i);
      j:=j+1;
   end;
   writeln(' DEVIATES...6.8.3.9-16, FOR');
end.
{TEST 6.8.3.9-17, CLASS=ERRORHANDLING}

{ This test checks the type of error produced when two nested
  for statements use the same control variable. }

program t6p8p3p9d17(output);
var
   i,j:integer;
begin
   j:=0;
   for i:=1 to 10 do
      for i:=1 to 10 do
	 j:=j+1;
   writeln(' ERROR NOT DETECTED...6.8.3.9-17, FOR');
end.
{TEST 6.8.3.9-18, CLASS=QUALITY}

{ This test checks that the undefined state of a for-statement
  controlled variable when the loop is left has one or both of
  the following properties:
    (a) Range checks are not omitted on these variables in the
	supposition that its value is permissible, or
    (b) the value of the variable is in range of its type (in
	this specific implementation).
  This test is not relevant if the use of the variable is
  prohibited. }

program t6p8p3p9d18(output);
type
   t=(red,green,blue,pink);
var
   i,j,k:t;
   m:integer;
begin
   { i is a finite scalar. }
   i:=green;
   j:=red;
   k:=pink;
   m:=0;
   for i:=j to k do
   begin
      m:=m+1;
   end;
   writeln(' THE UNDEFINED ORDINAL VALUE OF I IS ',ord(i));
   writeln(' ERROR NOT DETECTED');
   write(' ITS SYMBOLIC VALUE IS ');

   { A possible omission of the range check on the case statement
     may be disastrous if a wild jump occurs. }

   case i of
   red: writeln('RED');
   green: writeln('GREEN');
   blue: writeln('BLUE');
   pink: writeln('PINK');
   end;
   writeln(' JUST IN CASE THE RANGE ISNT CHECKED');
end.
{TEST 6.8.3.9-19, CLASS=DEVIANCE}

{ This test checks that compilers that permit the deviation
  (extension?) of allowing non-local control variables do so
  responsibly and do not introduce new insecurities.
  This test checks that a nested for statement using the same control
  variable is detected. It is similar to test 6.8.3.9-14 but
  requires a degree of sophistication to detect this condition.
  The compiler deviates if the program prints DEVIATES.
  The program may loop endlessly under some compilers. }

program t6p8p3p9d19(output);
var
   i:integer;

procedure p;
   procedure q;
      procedure r;
	 procedure s(var i:integer);
	 begin
	    writeln(i);
	 end;
      begin
	 for i:= 5 downto 2 do
	    s(i);
      end;
   begin
      r
   end;
begin
   q
end;

begin
   for i:= 1 to 6 do
      p;
   writeln(' DEVIATES...6.8.3.9-19, FOR')
end.
{TEST 6.8.3.9-20, CLASS=QUALITY}

{ This test checks that for statements may be nested to 15 levels
  The test may detect a small compiler limit, particularly
  those compilers that use a register for a control variable. }

program t6p8p3p9d20(output);
var
   i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12,i13,i14,i15:integer;
   j:integer;
begin
   for i1:=1 to 2 do
     for i2:=1 to 2 do
	for i3:=1 to 2 do
	   for i4:=1 to 2 do
	      for i5:=1 to 2 do
		 for i6:=1 to 2 do
		    for i7:=1 to 2 do
		       for i8:=1 to 2 do
			  for i9:=1 to 2 do
			     for i10:=1 to 2 do
				for i11:=1 to 2 do
				   for i12:=1 to 2 do
				      for i13:=1 to 2 do
					 for i14:=1 to 2 do
					    for i15:=1 to 2 do
						j:=10;
   writeln(' FOR STATEMENT NESTED TO > 15 LEVELS...6.8.3.9-20')
end.
{TEST 6.8.3.10-1, CLASS=CONFORMANCE}

{ This program checks the implementation of the with statement.
  The compiler fails if the program does not compile or it
  compiles and prints FAILS. }

program t6p8p3p10d1(output);
var
   r1:record
	a,b:integer
      end;
   r2:record
	c,d:integer
      end;
   r3:record
	e,f:integer
      end;
   counter:integer;
begin
   counter:=0;
   with r1 do
      a:=5;
   with r1,r2,r3 do
   begin
      e:=a;
      c:=a
   end;
   with r2 do
      if c=5 then
	 counter:=counter+1;
   if r2.c=5 then
      counter:=counter+1;
   if counter=2 then
      writeln(' PASS 6.8.3.10-1, WITH')
   else
      writeln(' FAIL 6.8.3.10-1, WITH');
end.
{TEST 6.8.3.10-2, CLASS=CONFORMANCE}

{ This test checks that a field identifier is correctly
  identified when a with statement is invoked.
  The compiler fails if the program does not compile or the
  program prints FAILS. }

program t6p8p3p10d2(output);
var
   r:record
       i,j:integer
     end;
   i:integer;
begin
   i:=10;
   with r do
      i:=5;
   if (i=10) and (r.i=5) then
      writeln(' PASS 6.8.3.10-2, WITH')
   else
      writeln(' FAIL 6.8.3.10-2, WITH');
end.
{TEST 6.8.3.10-3, CLASS=CONFORMANCE}

{ This test checks that the record-variable-list is evaluated
  in the correct order. The compiler fails if the program does
  not compile or the program prints FAILS. }

program t6p8p3p10d3(output);
var
   r1:record
	i,j,k:integer
      end;
   r2:record
	i,j:integer
      end;
   r3:record
	i:integer
      end;
begin
   with r1 do
   begin
      i:=0;
      j:=0;
      k:=0
   end;
   with r2 do
   begin
      i:=0;
      j:=0
   end;
   with r3 do
      i:=0;
   with r1,r2,r3 do
   begin
      i:=5;
      j:=6;
      k:=7
   end;
   if(r1.i=0) and (r1.j=0) and (r2.i=0) and (r1.k=7)
      and (r2.j=6) and (r3.i=5) then
      writeln(' PASS 6.8.3.10-3, WITH EVALUATION')
   else
      writeln(' FAIL 6.8.3.10-3, WITH EVALUATION');
end.
{TEST 6.8.3.10-4, CLASS=CONFORMANCE}

{ This test checks that the selection of a variable in the
  record-variable-list is performed before the component
  statement is executed. The compiler fails if the program
  does not compile or the program prints FAIL. }

program t6p8p3p10d4(output);
var
   a:array[1..2] of record
		      i,j:integer
		    end;
   k:integer;
begin
   a[2].i:=5;
   k:=1;
   with a[k] do
   begin
      j:=1;
      k:=2;
      i:=2
   end;
   if (a[2].i=5) and (a[1].i=2) then
      writeln(' PASS...6.8.3.10-4, WITH')
   else
      writeln(' FAIL...6.8.3.10-4, WITH');
end.
{TEST 6.8.3.10-5, CLASS=CONFORMANCE}

{ This test checks that the selection of a variable in the
  record-variable-list is performed before the component
  statement is executed. The compiler fails if the program
  does not compile or the program prints FAIL. }

program t6p8p3p10d5(output);
type
   pointer = ^recordtype;
   recordtype = record
		  data:integer;
		  link:pointer
		end;
var
   counter:integer;
   p,q:pointer;
begin
   counter:=0;
   new(p);
   p^.data:=0;
   new(q);
   q^.data:=1;
   q^.link:=nil;
   p^.link:=q;
   q:=p;
   with q^ do
   begin
      q:=link;
      if (data=0) and (q^.data=1) then
	 counter:=counter+1;
   end;
   with p^ do
   begin
      p:=link;
      { The first record now has no reference, so it could
	be deleted prematurely. }
      if (data=0) and (p^.data=1) then
	 counter:=counter+1;
   end;
   if counter=2 then
	 writeln(' PASS...6.8.3.10-5, WITH')
      else
	  writeln(' FAIL...6.8.3.10-5, WITH');
end.
{TEST 6.8.3.10-6, CLASS=CONFORMANCE}

{ This test checks that the order of evaluation of the
  record-variable-list in a with statement is correctly
  implemented. The compiler fails if the program prints FAIL. }

program t6p8p3p10d6(output);
type
   pp = ^ptr;
   ptr = record
	   i:integer;
	   link:pp;
	 end;
var
   p,q,r : pp;
begin
   new(p);
   p^.i := 0;
   new(q);
   q^.i := 0;
   p^.link := q;
   new(r);
   r^.i := 0;
   r^.link := nil;
   q^.link := r;
   with p^, link^, link^ do
   begin
      i:=5;
   end;
   if ((r^.i=5) and (q^.i=0) and (p^.i=0)) then
      writeln('PASS...6.8.3.10-6, WITH')
   else
      writeln(' FAIL...6.8.3.10-6, WITH');
end.
{TEST 6.8.3.10-7, CLASS=QUALITY}

{ This test checks that with statements may be nested to 15
  levels. The test may break a compiler limit in some compilers,
  particularly if a register is allocated for every selected
  variable. }

program t6p8p3p10d7(output);
type
   rec1 = record
	     i:integer
	   end;
   rec2 = record
	     i:integer
	   end;
   rec3 = record
	     i:integer
	   end;
   rec4 = record
	     i:integer
	   end;
   rec5 = record
	     i:integer
	   end;
   rec6 = record
	     i:integer
	   end;
   rec7 = record
	     i:integer
	   end;
   rec8 = record
	     i:integer
	   end;
   rec9 = record
	     i:integer
	   end;
   rec10 = record
	     i:integer
	   end;
   rec11 = record
	     i:integer
	   end;
   rec12 = record
	     i:integer
	   end;
   rec13 = record
	     i:integer
	   end;
   rec14 = record
	     i:integer
	   end;
   rec15 = record
	     i:integer
	   end;
   p1 = ^rec1;
   p2 = ^rec2;
   p3 = ^rec3;
   p4 = ^rec4;
   p5 = ^rec5;
   p6 = ^rec6;
   p7 = ^rec7;
   p8 = ^rec8;
   p9 = ^rec9;
   p10 = ^rec10;
   p11 = ^rec11;
   p12 = ^rec12;
   p13 = ^rec13;
   p14 = ^rec14;
   p15 = ^rec15;
var
   ptr1 : p1;
   ptr2 : p2;
   ptr3 : p3;
   ptr4 : p4;
   ptr5 : p5;
   ptr6 : p6;
   ptr7 : p7;
   ptr8 : p8;
   ptr9 : p9;
   ptr10 : p10;
   ptr11 : p11;
   ptr12 : p12;
   ptr13 : p13;
   ptr14 : p14;
   ptr15 : p15;
begin
   new(ptr1); ptr1^.i:=0;
   new(ptr2); ptr2^.i:=0;
   new(ptr3); ptr3^.i:=0;
   new(ptr4); ptr4^.i:=0;
   new(ptr5); ptr5^.i:=0;
   new(ptr6); ptr6^.i:=0;
   new(ptr7); ptr7^.i:=0;
   new(ptr8); ptr8^.i:=0;
   new(ptr9); ptr9^.i:=0;
   new(ptr10); ptr10^.i:=0;
   new(ptr11); ptr11^.i:=0;
   new(ptr12); ptr12^.i:=0;
   new(ptr13); ptr13^.i:=0;
   new(ptr14); ptr14^.i:=0;
   new(ptr15); ptr15^.i:=0;
   with ptr1^ do
      with ptr2^ do
	 with ptr3^ do
	    with ptr4^ do
	       with ptr5^ do
		  with ptr6^ do
		     with ptr7^ do
			with ptr8^ do
			   with ptr9^ do
			      with ptr10^ do
				 with ptr11^ do
				    with ptr12^ do
				       with ptr13^ do
					  with ptr14^ do
					     with ptr15^ do
						  i:=5;
   writeln(' >15 LEVELS OF WITH STATEMENTS ALLOWED...6.8.3.10-7');
end.
{TEST 6.9.1-1, CLASS=CONFORMANCE}

{ This program checks that the functions eoln and eof are
  correctly implemented. The compiler fails if the program does
  not compile or the program prints FAIL. }

program t6p9p1d1(f,output);
var
   f:text;
   counter:integer;
   c:char;
begin
   rewrite(f);
   counter:=0;
   writeln(f,1);
   writeln(f,'A');
   reset(f);
   while not eoln(f) do
      read(f,c);
   read(f,c);
   if (c=' ') then
      counter:=counter+1;
   read(f,c);
   if (c='A') then
      counter:=counter+1;
   if eoln(f) then
     counter:=counter+1;
   read(f,c);
   if eof(f) then
      counter:=counter+1;
   if (counter=4) then
      writeln(' PASS...6.9.1-1, EOLN AND EOF')
   else
      writeln('FAIL...6.9.1-1, EOLN AND EOF');
end.
{TEST 6.9.2-1, CLASS=CONFORMANCE}

{ This test checks that a single read statement with many
  variables is equivalent to many read statements containing
  one variable each. The compiler fails if the program does not
  compile or the program prints FAIL. }

program t6p9p2d1(f,output);
var
   f:text;
   a,b,c,d,e:integer;
   a1,b1,c1,d1,e1:integer;
begin
   rewrite(f);
   writeln(f,' 1 2 3 4 5 ');
   reset(f);
   read(f,a,b,c,d,e);
   reset(f);
   read(f,a1);
   read(f,b1);
   read(f,c1);
   read(f,d1);
   read(f,e1);
   if(a=a1) and (b=b1) and (c=c1) and (d=d1) and (e=e1) then
      writeln(' PASS...6.9.2-1, READ')
   else
      writeln(' FAIL...6.9.2-1, READ');
end.
{TEST 6.9.2-2, CLASS=CONFORMANCE}

{ This test checks that a read of a character variable is
  equivalent to correctly positioning the buffer variable.
  The compiler fails if the program does not compile or the program
  prints FAIL. }

program t6p9p2d2(f,output);
var
   f:text;
   a,b,a1,b1:char;
begin
   rewrite(f);
   writeln(f,'ABC');
   reset(f);
   read(f,a);
   read(f,b);
   reset(f);
   a1:=f^; get(f);
   b1:=f^; get(f);
   if(a=a1) and (b=b1) then
      writeln(' PASS...6.9.2-2, READ')
   else
      writeln(' FAIL...6.9.2-2, READ');
end.
{TEST 6.9.2-3, CLASS=CONFORMANCE}

{ This test checks that integers and reals are read correctly
  from a file. The compiler fails if the program does not
  compile or the program prints FAIL. }

program t6p9p2d3(f,output);
var
   f:text;
   i,j:integer;
   r,s:real;
begin

   { Internal (compile-time conversions) and run-time conversions
     should result in the same value, hence justifying the
     equality tests on real numbers. }

   rewrite(f);
   writeln(f,' 123 123.456 5 123E6 ');
   reset(f);
   read(f,i,r,j,s);
   if(i=123)and(r=123.456) and (j=5) and (s=123E6) then
      writeln(' PASS...6.9.2-3, READ')
   else
   begin
      if (i=123) and (j=5) then
	 writeln(' FAIL...6.9.2-3, READ REAL CONVERSIONS')
      else
	 writeln(' FAIL...6.9.2-3, READ')
   end;
end.
{TEST 6.9.2-4, CLASS=ERRORHANDLING}

{ This test checks that an error is produced when an attempt
  is made to read an integer but the sequence of characters
  on the input file does not form a valid signed integer. }

program t6p9p2d4(f,output);
var
   f:text;

   i:integer;
begin
   rewrite(f);
   writeln(f,'ABC123');
   reset(f);
   read(f,i);	   {should cause an error}
   writeln(' ERROR NOT DETECTED...6.9.2-4');
end.
{TEST 6.9.2-5, CLASS=ERRORHANDLING}

{ This test checks that an error is produced when an attempt
  is made to read a real but the sequence of characters
  on the input file does not form a valid real. }

program t6p9p2d5(f,output);
var
   f:text;
   r:real;
begin
   rewrite(f);
   writeln(f,'ABC123.456');
   reset(f);
   read(f,r);	   {should cause an error}
   writeln(' ERROR NOT DETECTED...6.9.2-5');
end.
{TEST 6.9.3-1, CLASS=CONFORMANCE}

{ This test checks that readln is correctly implemented.
  The compiler fails if the program does not compile or the
  program prints FAIL. }

program t6p9p3d1(output);
var
   f:text;
   a,b,c:char;
   counter:integer;
begin
   counter:=0;
   rewrite(f);
   writeln(f,'ABC');
   writeln(f,'DE');
   reset(f);
   readln(f,a,b,c);
   read(f,a);
   if (a='D') then counter:=counter+1;
   reset(f);
   read(f,a,b,c);
   readln(f);
   read(f,a);
   if(a='D') then counter:=counter+1;
   reset(f);
   read(f,a);
   while not eoln(f) do get(f);
   get(f);
   if (f^='D') then counter:=counter+1;
   if (counter=3) then
      writeln(' PASS...6.9.3-1, READLN')
   else
      writeln(' FAIL...6.9.3-1, READLN');
end.
{TEST 6.9.4-1, CLASS=CONFORMANCE}

{ This test checks that a write procedure with many parameters
  is equivalent to many write procedures with one parameter each.
  The compiler fails if the program does not compile or the program
  prints FAIL. }

program t6p9p4d1(f,output);
var
   f:text;
   a,b,c,d,e:char;
   a1,b1,c1,d1,e1:char;
   counter:integer;
begin
   counter:=0;
   rewrite(f);
   a:='A';
   b:='B';
   c:='C';
   d:='D';
   e:='E';
   write(f,a,b,c,d,e);
   writeln(f);
   reset(f);
   read(f,a1,b1,c1,d1,e1);
   if (a=a1) and (b=b1) and (c=c1) and (d=d1) and (e=e1) then
      counter:=counter+1;
   rewrite(f);
   write(f,a);
   write(f,b);
   write(f,c);
   write(f,d);
   write(f,e);
   writeln(f);
   reset(f);
   read(f,a1,b1,c1,d1,e1);
   if(a1=a) and (b1=b) and (c1=c) and (d1=d) and (e1=e) then
      counter:=counter+1;
   if (counter=2) then
      writeln(' PASS...6.9.4-1, WRITE')
   else
      writeln(' FAIL...6.9.4-1, WRITE');
end.
{TEST 6.9.4-2, CLASS=CONFORMANCE}

{ This test checks that the default value for the field width of a
  character type is one. The compiler fails if the program does not
  compile or the program prints FAIL. }


program t6p9p4d2(f,output);
var
   f:text;
   a,b:char;
begin
   rewrite(f);
   a:='A';
   b:='B';
   writeln(f,a,b);
   reset(f);
   read(f,a,b);
   if (a='A') and (b='B') then
      writeln(' PASS...6.9.4-2, WRITE')
   else
      write(' FAIL...6.9.4-2, WRITE');
end.
{TEST 6.9.4-3, CLASS=CONFORMANCE}

{ This test checks the implementation of integer output.
  The compiler fails if the program does not compile or the program
  prints FAIL. }

program t6p9p4d3(f,output);
var
   f:text;
   a:char;
   b:packed array [1..26] of char;
   i:integer;
begin
   rewrite(f);
   writeln(f,0:3,1:3,-1:3,10:3,99:3,100:3,-100:3,1111:3);
   reset(f);
   for i:=1 to 26 do
      read(f,b[i]);
   if (b='  0  1 -1 10 99100-1001111') then
      writeln(' PASS...6.9.4-3, WRITE INTEGERS')
   else
      writeln(' FAIL...6.9.4-3, WRITE INTEGERS');
end.
{TEST 6.9.4-4, CLASS=CONFORMANCE}

{ This program checks that real numbers are correctly written to
  text files. The compiler fails if the program does not compile
  or the program prints FAIL. }

program t6p9p4d4(f,output);
var
   f:text;
   a:packed array [1..26] of char;
   b:packed array [1..24] of char;
   i:integer;
   counter:integer;
begin
   rewrite(f);
   counter:=0;
   writeln(f,0.0:6,1.0:6,1.0:10);
   reset(f);
   for i:=1 to 26 do
      read(f,a[i]);
   if (a='     0.0     1.0 1.000E+00') then
      counter:=counter+1;
   rewrite(f);
   writeln(f,0.0:4:1,1.0:6:1,-1.0:6:1,123.456:7:3);
   reset(f);
   for i:=1 to 24 do
      read(f,b[i]);
   if (b=' 0.0	 1.0  -1.0 123.456') then
      counter:=counter+1;
   if (counter=2) then
      writeln(' PASS...6.9.4-4, WRITE REALS')
   else
      writeln(' FAIL...6.9.4-4, WRITE REALS');
end.
{TEST 6.9.4-5, CLASS=IMPLEMENTATIONDEFINED}

{ This program determines the implementation defines value which
  represents the number of digit characters written in an exponent. }

program t6p9p4d5(f,output);
var
   f:text;
   c:char;
   i:integer;
begin
   rewrite(f);
   writeln(f,1.0:10,'ABC');
   reset(f);
   repeat
      read(f,c);
   until (c='E');
   read(f,c);
   i:=-1;
   repeat
      read(f,c);
      i:=i+1;
   until (c='A');
   writeln(' THE NUMBER OF DIGITS WRITTEN IN AN EXPONENT IS',i:5);
end.
{TEST 6.9.4-6, CLASS=CONFORMANCE}

{ This test checks that strings are correctly written onto a text
  file. The compiler fails if the program does not compile or
  the program prints FAIL. }

program t6p9p4d6(f,output);
var
f:text;
i,j,k,counter:integer;
c:char;
begin
   rewrite(f);
   counter:=0;
   for i := 1 to 10 do
      writeln(f,'AAAAA':i,'B':1);
   writeln(f,'BBBBB','C':1);
   reset(f);
   for i:=1 to 10 do
   begin
      for j:=6 to i do begin
	 read(f,c);
	 if (c=' ') then
	    counter:=counter+1;
      end;
      if (i>5) then k:=5 else k:=i;
      for j:=1 to k do
      begin
	 read(f,c);
	 if(c='A') then
	    counter:=counter+1;
      end;
      read(f,c);
      if (c='B') then
	 counter:=counter+1;
      readln(f);
   end;
   for i:=1 to 5 do
   begin
      read(f,c);
      if (c='B') then
	 counter:=counter+1;
   end;
   read(f,c);
   if (c='C') then
      counter:=counter+1;
   if(counter=71) then
      writeln(' PASS...6.9.4-6, WRITE STRINGS')
   else
      writeln(' FAIL...6.9.4-6, WRITE STRINGS');
end.
{TEST 6.9.4-7, CLASS=CONFORMANCE}

{ This test checks that boolean variables are correctly written
  to text files. The compiler fails if the program does not compile
  or the program prints FAIL. }

program t6p9p4d7(f,output);
var
   f:text;
   b,c:boolean;
   a:packed array[1..10] of char;
   i:integer;
begin
   { This treatement is believed to be very dubious and may be
     altered in the future versions of the standard:
     A.H.J. Sale 1979 June 1 }
   rewrite(f);
   b:=true;
   c:=not b;
   writeln(f,b:5,c:5);
   reset(f);
   for i:=1 to 10 do
      read(f,a[i]);
   if (a='TRUE FALSE') then
      writeln(' PASS...6.9.4-7, WRITE BOOLEAN')
   else
      writeln(' FAIL...6.9.4-7, WRITE BOOLEAN');
end.
{TEST 6.9.4-8, CLASS=DEVIANCE}

{ This program attempts to output an integer number using a real
  format. The compiler deviates if the program prints DEVIATES. }

program t6p9p4d8(output);
var
   i:integer;
begin
   i:=123;
   writeln(i:6:1);
   writeln(' DEVIATES...6.9.4-8, WRITE');
end.
{TEST 6.9.4-9, CLASS=DEVIANCE}

{ This test attempts to output integers whose field width parameter
  are zero or negative. The compiles deviates if the program prints
  DEVIATES. }

program t6p9p4d9(output);
var
   i:integer;
begin
   for i:=10 downto -1 do
      writeln(' ','.':i, 'REP=',i);
   writeln(' DEVIATES...6.9.4-9, WRITE');
end.
{TEST 6.9.4-10, CLASS=QUALITY}

{ This program checks that data written appears on the output
  file regardless of the omission of a line marker. The common
  error is to buffer output and fail to flush the buffers at
  end of job. }

program t6p9p4d10(output);
begin
   write(' OUTPUT IS FLUSHED AT END_OF_JOB...6.9.4-10')
end.
{TEST 6.9.4-11, CLASS=IMPLEMENTATIONDEFINED}

{ This program determines the implementation defined default
  field width for writing integer, boolean and real types. }

program t6p9p4d11(f,output);
var
   f:text;
   c:char;
   i,j:integer;

   function readfield:integer;
   var
      i:integer;
   begin
   i:=0;
   repeat
      read(f,c);
      i:=i+1;
   until (c='Z');
   readfield:=i-1;
end;

begin
   rewrite(f);
   writeln(f,1,'Z',100,'Z');
   writeln(f,false,'Z',true,'Z');
   writeln(f,1.0,'Z',1000.0,'Z');
   reset(f);
   writeln(' IMPLEMENTATION DEFINED DEFAULT FIELD WIDTH VALUES');
   i:=readfield;
   j:=readfield;
   if (i=j) then
      writeln(' INTEGERS:',i:5,' CHARACTERS')
   else
   writeln(' THE VALUE VARIES ACCORDING TO THE SIZE OF THE INTEGER');
   readln(f);
   i:=readfield;
   j:=readfield;
   if (i=j) then
      writeln(' BOOLEAN:',i:5,' CHARACTERS')
   else
      writeln(' THE VALUE VARIES ACCORDING TO THE BOOLEAN VALUE');
   readln(f);
   i:=readfield;
   j:=readfield;
   if (i=j) then
      writeln(' REAL:',i:5,' CHARACTERS')
   else
      writeln(' THE VALUE VARIES ACCORDING TO THE SIZE OF THE REAL');
end.
{TEST 6.9.4-12, CLASS=DEVIANCE}

{This program checks whether an unpacked array of characters
  can be output. The compiler deviates if the program prints
  DEVIATES. }

program t6p9p4d12(output);
var
   s:array[1..3] of char;
begin
   s[1]:='R'; s[2]:='A'; s[3]:='N';
   writeln(' RAN=',s);
   writeln(' DEVIATES...6.9.4-12, WRITE');
end.
{TEST 6.9.4-13, CLASS=CONFORMANCE}

{ This program attempts to perform recursive I/O using a
  different file for the second I/O action. }

program t6p9p4d13(f,output);
var
   f:text;

function a(i:integer):integer;
begin
   writeln(f,i);
   a:=i;
end;

begin
   rewrite(f);
   writeln(a(1));
   writeln(' RECURSIVE I/O ALLOWED USING DIFFERENT FILES');
   writeln(' PASS...6.9.4-13, RECURSIVE I/O');
end.
{TEST 6.9.4-14, CLASS=QUALITY}

{ This program attempts to perform recursive I/O using the
  same file for the second I/O action.
  The semantics of write are not sufficiently well-defined to
  establish what should occur. It depends on evaluation orders,
  etc., which is why this test is in the quality section. }

program t6p9p4d14(f,output);

function a(i:integer):integer;
begin
   writeln(i);
   a:=i;
end;

begin
   writeln(a(1));
   writeln('RECURSIVE I/O ALLOWED USING THE SAME FILE...6.9.4-14');
end.
{TEST 6.9.4-15, CLASS=CONFORMANCE}

{ This test checks that a write that does not specify the file
  always writes on the default file at the program level, not
  any local variable with the same name. }

program t6p9p4d15(output);
   procedure p;
   var
      output:text;
   begin
      rewrite(output);
      writeln(output,' FAIL...6.9.4-15');
      writeln(' PASS...6.9.4-15')
   end;
begin
   p
end.
{TEST 6.9.5-1, CLASS=CONFORMANCE}

{ This program checks the implementation of procedure writeln.
  The compiler fails if the program prints FAIL or the program
  does not compile. }

program t6p9p5d1(f,output);
var
   f:text;
   a,b:packed array[1..10] of char;
   i:integer;
begin
   rewrite(f);
   writeln(f,1:5,'ABCDE');
   write(f,1:5,'ABCDE');
   writeln(f);
   reset(f);
   for i:=1 to 10 do
      read(f,a[i]);
   reset(f);
   for i:=1 to 10 do
      read(f,b[i]);
   if (a=b) then
      writeln(' PASS...6.9.5-1, WRITELN')
   else
      writeln(' FAIL...6.9.5-1, WRITELN');
end.
{TEST 6.9.6-1, CLASS=CONFORMANCE}

{ This program checks that the procedure page is implemented.
  This conformance test is unable to determine whether the compiler
  passes or fails - the user must check that a page has been
  generated. }

program t6p9p6d1(output);
begin
   writeln(' PAGE GENERATION TEST');
   page(output);
   writeln(' IF THIS LINE IS PRINTED ON THE TOP OF A NEW PAGE');
   writeln(' THEN PASS...6.9.6-1, PAGE');
   writeln(' ELSE FAIL...6.9.6-1, PAGE');
end.
{TEST 6.10-1, CLASS=DEVIANCE}

{ This test checks the effect of using a default file not declared in
  the program heading. The compiler deviates if the program
  prints DEVIATES. }

program t6p10d1(input);
begin
   writeln(' DEVIATES...6.10-1, FILE DECLARATION');
end.
{TEST 6.10-2, CLASS=IMPLEMENTATIONDEFINED}

{ This program checks the effect of doing a rewrite on the
  standard file output. The effect is implementation dependent. }

program t6p10d2(output);
begin
   rewrite(output);
   writeln(' IMPLEMENTATION DEPENDENT...6.10-2');
   writeln(' A REWRITE HAS BEEN PERFORMED ON FILE OUTPUT');
end.
{TEST 6.10-3, CLASS=DEVIANCE}

{ This program checks that the default file output is
  implicitly declared at the program level by attempting to
  redefine it. The file input should be identical, of course.
  The test should not compile. }

program t6p10d3(output);
var
   output:integer;
begin
   output:=1;
   writeln(' DEVIATES...6.10-3, OUTPUT REDEFINED')
end.
{TEST 6.10-4, CLASS=DEVIANCE}

{ This program has no program statement. Some compilers may
  assume the existence of such a statement if none is present.
  The compiler deviates if the program compiles and prints
  DEVIATES. }

var
   i:integer;
begin
   i:=5;
   writeln(' DEVIATES...6.10-4, PROGRAM')
end.
{TEST 6.11-1, CLASS=IMPLEMENTATIONDEFINED}

{ This program checks whether equivalent symbols can be used for
  the standard reference representation. The equivalent symbols
  for comment delimiters are tested. They are implemented if
  the program prints ALTERNATE COMMENT DELIMITERS IMPLEMENTED. }

program t6p11d1(output);
(* Test of alternate comment delimiters *)
begin
 (* test of alternate comment delimiters. If these delimiters
   are not implemented the compiler will give a syntax error. *)
   writeln(' ALTERNATE COMMENT DELIMITERS IMPLEMENTED...6.11-1');
end.
{TEST 6.11-2, CLASS=IMPLEMENTATIONDEFINED}

{ This program checks whether equivalent symbols can be used for
  the standard reference representation. The equivalent symbols
  for the up-arrow, :, ;, :=, and [ ] are tested. The equivalent
  symbols are implemented if the program prints
  EQUIVALENT SYMBOLS ARE IMPLEMENTED. }

program t6p11d2(output);
type
   rec = record
	   a,b:integer
	 end;
   ptr1=@rec;
   ptr2=^rec;

   { The above two statements use the equivalent symbols for the
      up-arrow }

var
   arr:array (. 1..10 .) of integer;
   i % integer;
   r:real;
   s:real;
   j,k,l : integer;
begin
   j .= 5;
   k %= 6;
   s:=1.0;
   l := 7  .,
   s:=1.0;
   writeln(' EQUIVALENT SYMBOLS ARE IMPLEMENTED...6.11-2');
end.
{TEST 6.11-3, CLASS=IMPLEMENTATIONDEFINED}

{ This program checks whether equivalent symbols can be used for
  the standard reference representation. The equivalent symbols
  for the arithmetic operators <,>,<=,>=,<> are checked. They
  are implemented if the program prints EQUIVALENT SYMBOLS ARE
  IMPLEMENTED. }

program t6p11d3(output);
var
   j,k,l : integer;
   b : boolean;
begin
   j:=1;
   k:=2;
   b := j GT k;
   b := j LT k;
   b := j GE k;
   b := j LE k;
   b := j NE k;
   writeln(' EQUIVALENT SYMBOLS ARE IMPLEMENTED...6.11-3');
end.
{T999     \