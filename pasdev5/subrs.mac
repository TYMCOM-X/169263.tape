	TITLE	UUOD    - PASCAL LIBRARY FUNCTION FOR UUO CALLS WITH DEVICES
;	version 1  njb  5/20/76   creation
;		PASCAL LIBRARY FUNCTION: UUOD
;			OPNUUO FOR OPEN UUO EXECUTION
;			LKPUUO FOR LOOKUP UUO EXECUTION
;		ALLOWS USER TO EXECUTE UUOS FROM A PASCAL PROGRAM
 
;		CALLING SEQUENCE:
;
;		RETURNTYPE := OPNUUO(DEVICE (* DEVICE FIELD OF UUO)*,
;		        	      ADDRESS (* ADDRESS FIELD OF UUO*))
;			SAME FOR LKPUUO
; 
;	DECLARATION
;		FUNCTION OPNUUO
;			(DEV:INTEGER,
;			 ADDR:^OPNTBL)
;		:BOOLEAN;
;
;		FUNCTION LKPUUO
;			(DEV:INTEGER,
;			 ADDR:^LKPTBL)
;		:BOOLEAN
;			RETURNTYPE IS A BOOLEAN; SET TRUE IF RETURN SKIPS.
 
	SEARCH 	PASSYM

	HISEG			;THIS CODE IS ENTIRELY REENTRANT
	ENTRY	OPNUUO		;OPEN UUO CALL
	ENTRY	LKPUUO		;LOOKUP UUO CALL
 
OPNUUO:
	HLL	2,[OPEN]		;GET OPEN UUO
	JRST	UUOD		;GET REST FROM PARAMS
;
;
LKPUUO:
	HLL	2,[LOOKUP]	;GET LOOKUP OPCODE
	JRST	UUOD		;GET REST FROM PARAM LIST;
;
;
UUOD:
 	DPB	2,[POINT 4,2,12]	;MOVE AC FIELD TO RIGHT PLACE
	HRR	2,3		;REGISTER 3 HAS ACTUAL ADDRESS FIELD
	MOVEI	1,1	;SET DEFAULT RETURN TO TRUE
	XCT	2	;EXECUTE THE UUO INSTRUCTION
	MOVEI	1,0	;SET NON SKIP RETURN TO FALSE
	MOVEM	1,FV(17)	;STORE RETURN
	POPJ	17,	;RETURN TO PASCAL PROGRAM
 
	PRGEND
	TITLE	SPYUUO    - PASCAL LIBRARY FUNCTION FOR UUO CALLS

;		PASCAL LIBRARY FUNCTION: SPYUUO, UUO

;		ALLOWS USER TO EXECUTE UUOS FROM A PASCAL PROGRAM
;		AND WILL SIMULATE GETTAB'S WITH SPY UUO IF FUNCTION
;		SPYUUO CALLED FIRST.
 
;		CALLING SEQUENCE:
;			RETURNTYPE := UUO(OPCODE (* OPERATION CODE TO USE *),
;					  ADDRESS (* ADDRESS FIELD OF UUO *),
;					  ACVALUE (* VALUE TO PUT IN AC, RETURN *));;
;			RETURNTYPE IS A BOOLEAN; SET TRUE IF RETURN SKIPS.
;			THE VALUE OF 'ACVALUE' IS LOADED INTO THE AC BEFORE THE
;			UUO IS EXECUTED. THE VALUE LEFT IN THAT REGISTER AFTER
;			THE UUO IS STORED BACK IN THAT PARAMETER (WHICH BETTER BE
;			A 'VAR' PARAMETER IF YOU WANT TO USE IT).
 
;		THERE IS ONE ADDITIONAL KLUDGE: IF THE LEFT HALF OF THE
;		'OPCODE' PARAMTER IS NON-ZERO, IT IS TAKEN AS A REGISTER
;		FIELD SPECIFICATION AND PUT IN THE AC FIELD OF THE INST.

;		CALLING SEQUENCE FOR SPYUUO:
;			BOOLEAN := SPYUUO;
;
;	GETTAB	CALLING SEQUENCE:
;
;		VALUE := GETTAB(GETTAB AC PARAMETER);
;
;		THERE IS NO ERROR RETURN.


	SEARCH	C(C[1020,5])
 
	RELOC	0		;ONE SEGMENT, CODE AND DATA
	ENTRY	SPYUUO		;LOAD THIS MODULE ONLY IF SPYUUO CALLED FOR
 
	T1=1
	T2=2		;FIRST ARGUMENT
	T3=3		;SECOND ARGUMENT
	T4=4		;THIRD ARGUMENT
	P=17

	GTTAB==41		;SO WE CAN REDEFINE GETTAB

SPYUUO:
	MOVEM	T1,1(P)		;SAVE T1
	SKIPE	.JBHRL##	;HIGH SEGMENT ALREADY?
	JRST	NOSPY		;YES, NO SPYING
	PJOB	T1,		;GET OUR JOB NUMBER
	MOVEM	T1,MYJOB#	;REMEMBER IT
	MOVE	T1,[%CNSIZ]	;GET MONITOR SIZE GETTAB PTR
	CALLI	T1,GTTAB	;GET MONITOR SIZE
	  JRST	NOSPY		;DONT TRY TO SPY
	SUBI	T1,1		;SPY ON ALL OF MONITOR
	SPY	T1,		;REQUEST MONITOR AS HIGH SEGMENT
	  JRST	NOSPY		;NOT TODAY, MUST DO GETTABS
	MOVE	T1,[%SLSLF]	;GET PTR TO GETTAB TABLE
	CALLI	T1,GTTAB	;GET IT
	  JRST	NOSPY		;CANT, THEN CANT SIMULATE GETTABS
	HRRZM	T1,OFSGTB#	;STORE MONITOR ADDR OF GETTAB TABLE OF TABLES
	LSH	T1,-^D9		;POSITION LENGTH OF TABLE
	HLRZM	T1,MAXGTB#	;STORE FOR SIMULATOR
	MOVE	T1,[%CNPDB]	;POINTER TO JBTPDB TABLE
	CALLI	T1,GTTAB	;GET MONITOR ADDR OF JBTPDB TABLE
	  SETZ	T1,		;CANT?
	JUMPE	T1,NOSPY	;JUMP IF DONT KNOW OR DONT HAVE PDB'S
	TDO	T1,[T1,,400000]	;SET UP FOR INDIRECTING AND INDEXING
	MOVEM	T1,PDBPTR#	;STORE FOR LATER
	SKIPA	T1,[1]		;"TRUE"
NOSPY:	SETZ	T1,		;"FALSE"
	SKIPN	T1		;IF "FALSE" RETURNED
	SETZM	MAXGTB		;USE THIS TO FLAG NOT SPYING
	EXCH	T1,1(P)		;RETURN SUCCESS AND RESTORE T1
	POPJ	P,		;RETURN
UUO::
	MOVEM	T1,1(P)		;PRESERVE T1
	MOVEI	T1,(<CALLI>_-11)	;CHECK FOR GETTABS
	CAIN	T3,41		;...
	CAIE	T1,(T2)		;...
	JRST	NORMAL		;NOT GETTAB, DO NORMAL THING
	TLNE	T2,-1		;DON'T DO SPY IF SPECIAL AC SET IN CALL
	JRST	NORMAL		;DO NORMAL THING
	HRRE	T3,(T4)		;T3=GETTAB TABLE DESIRED
	SKIPE	T2,MAXGTB	;SKIP IF CANT SIMULATE
	CAILE	T3,(T2)		;SKIP IF LEGAL TABLE NUMBER
	JRST	GETGET		;JUMP IF CANT SIMULATE, TRY REAL GETTAB
	ADD	T3,OFSGTB	;GET MONITOR ADDR OF DESIRED TABLE
	MOVE	T2,400000(T3)	;T2=PTR TO DESIRED TABLE IN MONITOR
	HLRZ	T1,(T4)		;GET INDEX INTO TABLE
	TRNE	T1,1B18		;SKIP IF NOT OUR JOB FLAG
	MOVE	T1,MYJOB	;YES, GET OUR JOB NUMBER
	LDB	T3,[POINT 9,T2,8] ;GET SIZE OF TABLE
	CAILE	T1,(T3)		;SKIP IF LEGAL REQUEST
	JRST	GETGET		;NO, TRY REAL GETTAB
	TLNN	T2,(17B17)	;SKIP IF INDEXING
	SETZ	T1,		;NO, CLEAR REQUEST
	TLNN	T2,(GT.PRC)	;PDB DATUM?
	JRST	FGET1		;NO
	ADD	T2,@PDBPTR	;YES, GET ADDR OF JOBS PDB ENTRY
	SETZ	T1,		;ALREADY ADDED IN TABLE INDEX
FGET1:	ADDI	T1,(T2)		;ADD TABLE LOCATION TO OFFSET
	MOVE	T1,400000(T1)	;GET DESIRED WORD
	MOVEM	T1,0(T4)	;RETURN TO CALLER
	MOVEI	T1,1		;RETURN "TRUE"
	EXCH	T1,1(P)		;...
	POPJ	P,		;AND RETURN

GETGET:	MOVE	T2,[CALLI T3,GTTAB]
	JRST	NORML1

NORMAL:	HLRZ	T1,T2		;COPY POSSIBLE REGISTER FIELD TO AC 1
	SKIPN	T1		;SEE IF IT IS ZERO (MEANS NONE GIVEN)
	MOVEI	T1,T3		;IF SO, USE AC 3
	LSH	T2,^D4		;SHIFT OP CODE, LEAVE ROOM FOR AC FIELD
	ANDI	T1,17		;MASK AC FIELD
	IOR	T2,T1		;PUT IN REGISTER FIELD
	LSH	T2,^D5		;NOW PUT IN RIGHT PLACE IN INSTRUCTION
	HRL	T2,T2		;POSITION OPCODE,AC IN LEFT HALF
	HRR	T2,T3		;REGISTER 3 HAS ACTUAL ADDRESS FIELD
NORML1:
	MOVE	T3,0(T4)	;PUT GIVEN VALUE IN ACCUMULATOR
	XCT	T2		;EXECUTE THE UUO INSTRUCTION
	TDZA	T1,T1		;NON-SKIP RETURN FROM MONITOR
	MOVEI	T1,1		;SKIP RETURN, VALUE = 1
	MOVEM	T3,0(T4)	;STORE RESULT IN PARAMETER
	EXCH	T1,1(P)		;STORE RETURN FLAG AND RECOVER T1
	POPJ	P,		;RETURN TO PASCAL PROGRAM
GETTAB::
	MOVEM	T1,1(P)		;PRESERVE T1
	HRRE	T3,T2		;T3=GETTAB TABLE DESIRED
	SKIPE	T4,MAXGTB	;SKIP IF CANT SIMULATE
	CAILE	T3,(T4)		;SKIP IF LEGAL TABLE NUMBER
	JRST	GTNOR		;JUMP IF CANT SIMULATE, TRY REAL GETTAB
	ADD	T3,OFSGTB	;GET MONITOR ADDR OF DESIRED TABLE
	MOVE	T4,400000(T3)	;T4=PTR TO DESIRED TABLE IN MONITOR
	HLRZ	T1,T2		;GET INDEX INTO TABLE
	TRNE	T1,1B18		;SKIP IF NOT OUR JOB FLAG
	MOVE	T1,MYJOB	;YES, GET OUR JOB NUMBER
	LDB	T3,[POINT 9,T4,8] ;GET SIZE OF TABLE
	CAILE	T1,(T3)		;SKIP IF LEGAL REQUEST
	JRST	GTNOR		;NO, TRY REAL GETTAB
	TLNN	T4,(17B17)	;SKIP IF INDEXING
	SETZ	T1,		;NO, CLEAR REQUEST
	TLNN	T4,(GT.PRC)	;PDB DATUM?
	JRST	GGET1		;NO
	ADD	T4,@PDBPTR	;YES, GET ADDR OF JOBS PDB ENTRY
	SETZ	T1,		;ALREADY ADDED IN TABLE INDEX
GGET1:	ADDI	T1,(T4)		;ADD TABLE LOCATION TO OFFSET
	MOVE	T1,400000(T1)	;GET DESIRED WORD
	EXCH	T1,1(P)		;RETURN FUNCTION VALUE
	POPJ	P,		;RETURN TO CALLER

GTNOR:
	CALLI	T2,41
	SETZ	T2,
	MOVEM	T2,1(P)
	POPJ	P,
 
GT.PRC==1B9			;BIT SET IN GETTAB PTR IF PDB DATA
%SLSLF==23,,23			;GETTAB IMMEDIATE - GET PTR TO GETTAB TABLE

	VAR

	PRGEND
	TITLE	XITPRG - ROUTINE SETXIT AND ASSOCIATED CODE
 
;	THE SUBROUTINE 'SETXIT' WHEN CALLED ALLOWS A PASCAL PROGRAM TO
;	BE INFORMED OF ONE OR MORE 'SPECIAL' CONDITIONS THAT HAS OCCURED.
;	THE MECHANISM USED IS THAT THE PASCAL PROGRAM CALLS THE ROUTINE
;	SETXIT WITH TWO PARAMETERS:THE FIRST PARAMATER INDICATES WHAT CONDITIONS
;	THE USER IS INTERESTED IN FINDING OUT ABOUT; THE SECOND
;	PARAMETER GIVES THE NAME OF AN INTEGER VARIABLE INTO WHICH
;	A VALUE WILL BE STORED WHEN THE FIRST CONDITIONS
;	OCCURS. THE VALUE OF THIS VARIABLE IS SET TO -1 WHEN SETXIT IS
;	CALLED: IT WILL BE SET TO A NON-NEGATIVE VALUE AS SOON AS
;	ONE OF THE SELECTED CONDITIONS OCCURS. NOTE THAT IS UP TO THE
;	PASCAL PROGRAM TO CHECK THE VALUE OF THIS VARIABLE REGULARLY.
;	EACH CALL TO SETXIT ENABLES THE TRAPPING OF EXACTLY ONE SPECIAL
;	CONDITION - IT MUST BE CALLED AFTER HANDLING EACH SUCH CONDITION
;	IF YOU WANT TO FIND OUT ABOUT MORE THAN ONE. 
 
;	EXAMPLE:
;		VAR XITCODE: INTEGER;	(* SPECIAL CONDITION CODE STORED HERE *)
;			...
;		SETXIT(202B,XITCODE);	(* GET BREAKS & REENTER *)
;			...
;		(* THE FOLLOWING STATEMENTS SHOULD BE PUT IN A PLACE
;		    WHERE THEY WILL BE GUARANTEED TO BE REGULARLY EXECUTED *)
;		IF XITCODE>0 THEN (* SOMETHING SPECIAL HAS HAPPENED *)
;			BEGIN	(* BEGIN 'SPECIAL CONDITIONS' SECTION *)
;			IF XITCODE=2 THEN BEGIN (* HANDLE A BREAK *) END;
;				... (* ETC, FOR OTHER CONDITIONS *)
;			SETXIT(202B,XITCODE);  (* OPTIONAL, TO CATCH
;							NEXT CONDITION *)
;			END;
 
;	DEFINITIONS OF THE BITS SELECTING THE VARIOUS CONDITIONS 
;		THESE BITS ARE USED AS ARGUMENTS IN THE FIRST PARAMETER
;		ON THE CALL TO SETXIT; AND ARE RETURNED AS RESULTS IN
;		THE SECOND PARAMATER ( WHEN THE SPECIAL CONDITION OCCURS )
 
;	001B,BIT 35: DEVICE ERRORS
;	002B,BIT 34: CONTROL C (BREAK) INTERCEPT
;	004B,BIT 33: OFF LINE DISK
;	010B,BIT 32: FULL FILE STRUCTURE
;	020B,BIT 31: DISK QUOTA EXCEEDED
;	040B,BIT 30: TIME LIMIT EXCEEDED
;	100B,BIT 29: ERROR IN JOB (ILLEGAL UUO, MEM REF, ETC.)
;	200B,BIT 28: REENTER COMMAND AT MONITOR LEVEL
 
	ENTRY	SETXIT
	EXTERN	.JBINT,.JBOPC,.JBREN

	T1=1
	T2=2
	T3=3
	P=17

 
SETXIT:	MOVEM	T1,SAV1
	TRZN	T2,200		;CHECK FOR REENTER INTERCEPT
	JRST	NORENT		;IF BIT 28 IS ZERO, NON WANTED
	HRRI	T1,RENLOC	;SET ADDRESS IN JOB DATA ARE
	HRRM	T1,.JBREN	;SO MONITOR WILL SEE IT
NORENT:	MOVEM	T2,XITFLG	;SET CONDITION FOR SPECIAL EXIT
	MOVEM	T3,VALADR
	SETOM	0(T3)		;AND CLEAR IT, IN CASE USER FORGOT
	SETZM	XITPC		;CLEAR AND SET PARAMETER BLOCK
	SETZM	XITCOD
	HRLI	T1,4
	HRRI	T1,INTLOC	;BLOCK LENGTH; ENTRY ADDRESS
	MOVEM	T1,XITBLK
	HRRI	T1,XITBLK
	HRRM	T1,.JBINT	;ENABLES BREAK INTERCEPT
	MOVE	T1,SAV1		;RESTORE T1
	POPJ	P,
 
;	ENTER HERE ON AN INTERCEPTED BREAK OR OTHER ERROR
 
INTLOC:	MOVEM	T1,XITTMP	;SAVE A REGISTER
	HLRZ	T1,XITCOD	;COPY ERROR CODE
	MOVEM	T1,@VALADR
	MOVE	T1,XITTMP
	JRST	@XITPC
 
;	ENTER HERE ON A REENTER MONITOR LEVEL COMMAND
 
RENLOC:	SETZM	.JBREN
	MOVEM	T1,XITTMP	;SAVE A REGISTER
	HRRZI	T1,200		;GET BIT MEANING REENTER
	MOVEM	T1,@VALADR	;AND GIVE IT TO A USER
	MOVE	T1,XITTMP	;RESTORE SAVED REGISTER
	SETOM	XITPC		;TURN OFF ABEND INTERCEPT AS WELL
	JRST	@.JBOPC
 
;	LOW SEGMENT AREA: NEEDED FOR MONITOR COMMUNICATION
 
SAV1:	BLOCK	1	;SAVE T1
VALADR:	Z		;ADDRESS OF PASCAL INTEGER VARIABLE
XITBLK:	Z		;BEGINNING OF MONITOR PARAMETER BLOCK
XITFLG:	Z		;DEFINES WHAT MONITOR SHOULD GIVE US
XITPC:	Z		;PROGRAM COUNTER ON EXIT
XITCOD:	Z		;WHY MONITOR EXITED
XITTMP:	Z		;TEMPORARY USED INTERNALLY
 
		PRGEND
	TITLE	UUO    - PASCAL LIBRARY FUNCTION FOR UUO CALLS
;
;		PASCAL LIBRARY FUNCTION: UUO
;		ALLOWS USER TO EXECUTE UUOS FROM A PASCAL PROGRAM
 
;	UUO	CALLING SEQUENCE:
;			RETURNTYPE := UUO(OPCODE (* OPERATION CODE TO USE *),
;					  ADDRESS (* ADDRESS FIELD OF UUO *),
;					  ACVALUE (* VALUE TO PUT IN AC, RETURN *));;
;			RETURNTYPE IS A BOOLEAN; SET TRUE IF RETURN SKIPS.
;			THE VALUE OF 'ACVALUE' IS LOADED INTO THE AC BEFORE THE
;			UUO IS EXECUTED. THE VALUE LEFT IN THAT REGISTER AFTER
;			THE UUO IS STORED BACK IN THAT PARAMETER (WHICH BETTER BE
;			A 'VAR' PARAMETER IF YOU WANT TO USE IT).
 
;		THERE IS ONE ADDITIONAL KLUDGE: IF THE LEFT HALF OF THE
;		'OPCODE' PARAMTER IS NON-ZERO, IT IS TAKEN AS A REGISTER
;		FIELD SPECIFICATION AND PUT IN THE AC FIELD OF THE INST.
 
;	GETTAB	CALLING SEQUENCE:
;
;		VALUE := GETTAB(GETTAB AC PARAMETER);
;
;		THERE IS NO ERROR RETURN.

	HISEG			;THIS CODE IS ENTIRELY REENTRANT
	ENTRY	UUO		;ENTRY POINT FOR PASCAL CALLS IS AT UUO
	ENTRY	GETTAB		;ENTRY POINT FOR PASCAL CALLS TO GETTAB
 
	T1=1
	T2=2
	T3=3
	T4=4
	P=17

UUO:	BLOCK	0		;ENTRY POINT
	MOVEM	T1,1(P)		;PRESERVE T1
	HLRZ	T1,T2		;COPY POSSIBLE REGISTER FIELD TO AC 1
	SKIPN	T1		;SEE IF IT IS ZERO (MEANS NONE GIVEN)
	MOVEI	T1,T3		;IF SO, USE AC 3
	LSH	T2,^D4		;SHIFT OP CODE, LEAVE ROOM FOR AC FIELD
	ANDI	T1,17		;MASK AC FIELD
	IOR	T2,T1		;PUT IN REGISTER FIELD
	LSH	T2,^D5		;NOW PUT IN RIGHT PLACE IN INSTRUCTION
	HRL	T2,T2		;POSITION OPCODE,AC IN LEFT HALF
	HRR	T2,T3		;REGISTER 3 HAS ACTUAL ADDRESS FIELD
	MOVE	T3,0(T4)	;PUT GIVEN VALUE IN ACCUMULATOR
	XCT	T2		;EXECUTE THE UUO INSTRUCTION
	TDZA	T1,T1		;NON-SKIP RETURN FROM MONITOR
	MOVEI	T1,1		;SKIP RETURN, VALUE = 1
	MOVEM	T3,0(T4)	;STORE RESULT IN PARAMETER
	EXCH	T1,1(P)		;STORE RETURN FLAG AND RECOVER T1
	POPJ	P,		;RETURN TO PASCAL PROGRAM
 
GETTAB:
	CALLI	T2,41
	SETZ	T2,
	MOVEM	T2,1(P)
	POPJ	P,

	PRGEND
	TITLE	GETDAY - GETDAYOFWEEK FUNCTION FOR PASCAL LIBRARY
 
;	THIS FUNCTION REQUIRES A SINGLE ARGUMENT - A DEC-STYLE CODED
;	DATE - AND RETURNS THE DAY OF THE WEEK (SATURDAY=0, SUNDAY=1,
;	ETC.) OF THAT DATE. THE CODE WAS STOLEN FROM MIKE CHURCH'S
;	ALLOCATOR PROGRAM
 
		T1=1
		T2=2
		T3=3
		T4=4
 
		ENTRY	GETDAY
 
GETDAY:	MOVEM	T3,SAVET3
		MOVEM	T4,SAVET4
		CAME	T2,THEDAY	;SEE IF SAME ARGUMENT AS LAST CALL
		JRST	DAYTS1		;NO, MUST COMPUTE THINGS
		MOVE	T4,WDAY		;YES, USE LAST RESULT FOR DAY OF WEEK
		JRST	DAYTS3		; TO SAVE TIME
DAYTS1:	MOVEM	T2,THEDAY	;SAVE THE ARGUMENT
		IDIVI	T1,^D31*^D12	;GET YEAR IN T1
		IDIVI	T2,^D31		;AND MONTH, DAY IN T2,T3
		MOVEI	T4,4(T3)	;1-1-64 WAS A WEDNESDAY
		MOVEM	T4,DAY		;STORE IT
		MOVEM	T1,YEAR		;STORE YEAR
		MOVEM	T2,MONTH	;AND MONTH
		MOVE	T1,DAYPNT	;GET BYTE POINTER
		ILDB	T3,T1		;GET OFFSET FOR THE MONTH
		SOJGE	T2,.-1		;STOP ON THE CORRECT MONTH
		ADDB	T3,DAY		;STORE DAY
		MOVE	T1,YEAR		;GET YEAR BACK
		MOVE	T2,MONTH	;GET MONTH BACK
		TRNE	T1,3		;A LEAP YEAR?
		AOJA	T3,DAYTS2	;NO
		CAILE	T2,1		;YES, JAN OR FEB?
		AOS	T3		;NO, MUST BE AFTER LEAP DAY
DAYTS2:	ADDM	T1,T3		;PLUS YEAR COUNT
		ASH	T1,-2		;DIVIDE BY 4 FOR NUMBER OF LEAP YEARS
		ADDM	T1,T3		;ADD TO DAY COUNT
		IDIVI	T3,7		;DIVIDE BY DAYS PER WEEK, REMAINER IN T4
		MOVEM	T4,WDAY		;SAVE DAY OF WEEK WHICH IS IN T4
DAYTS3:	MOVEM	T4,-1(17)	;RETURN THE FUNCTION VALUE TO CALLER
		MOVE	T3,SAVET3
		MOVE	T4,SAVET4
		POPJ	17,		;RETURN TO CALLER

DAYPNT:	440300,,.+1		;BYTE POINTER FOR MONTH OFFSET
		OCT	033614625035	;OFFSET TABLE
MONTH:	OCT	0
YEAR:	OCT	0
DAY:	OCT	0
THEDAY:	OCT	0		;COPY OF THE ARGUMENT
WDAY:	OCT	0		;DAY OF THE WEEK 0 - 6 SAT - FRI
SAVET3:	Z
SAVET4:	Z
 
		PRGEND
	TITLE	BIT

;PASCAL CALLABLE FUNCTION TO PULL BIT(S) OUT OF A WORD
; I := BIT (WORD, BIT)		(* BITS NUMBERED 0..35 *)
;OR
; I := BITS (WORD, LAST BIT, NUMBER OF BITS)

	ENTRY	BIT,BITS

;AC'S
	P=17
	T1=1
	T2=2	;FIRST ARGUMENT
	T3=3	;SECOND ARGUMENT
	T4=4	;THIRD ARGUMENT

BIT:	MOVEM	T1,SAVET1
	MOVEM	T4,SAVET4
	MOVEI	T4,1		;NUMBER OF BITS IN 2 ARG CALL
CONT:	JUMPL	T3,ERR
	CAILE	T3,^D35
	JRST	ERR
	MOVEI	T1,^D35
	SUB	T1,T3
	DPB	T1,[POINT 6,T3,5] ;BUILD BYTE POINTER IN T3 TO BIT(S)
	DPB	T4,[POINT 6,T3,11]
	HRRI	T3,T2
	LDB	T1,T3
XIT:	MOVEM	T1,1(P)
	MOVE	T1,SAVET1
	MOVE	T4,SAVET4
	POPJ	P,

ERR:	SETZ	T1,
	JRST	XIT

BITS:	MOVEM	T1,SAVET1
	MOVEM	T4,SAVET4
	JRST	CONT

SAVET1:	BLOCK	1
SAVET4:	BLOCK	1

	END
 