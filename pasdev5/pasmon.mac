
incore==0
virtual==0
debugf==0
HASH==4*INCORE+2*VIRTUAL+DEBUGF
	IFE	HASH-5,<
	TITLE	INIT5
	ENTRY	VINI5.>
	IFE	HASH-3,<
	TITLE	INIT3
	ENTRY	VINI3.>
	IFE	HASH-1,<
	TITLE	DEBMON
	ENTRY	VINI1.
	ENTRY	DEBUG.>
	IFE	HASH-4,<
	TITLE	INIT4
	ENTRY	VINI4.>
	IFE	HASH-2,<
	TITLE	INIT2
	ENTRY	VINI2.>
	IFE	HASH,<
	TITLE	PASMON
	ENTRY	VINI0.
	ENTRY	INITP.>
	SUBTTL	INTRODUCTION
	SEARCH	PASSYM		;GET PASCAL SYMBOL DEFINITIONS
	OPDEF	ZRO	[0]
;
; THIS MODULE HANDLES INITIALIZATION OF AND EXIT
; FROM THE PASCAL ENVIRONMENT, AND INTERCEPTS RUN-TIME
; ERRORS.
;
	INTERN	EXIT.
	INTERN	END.
	INTERN	DIE.
	INTERN	WRTPC.
	INTERN	WRTDC.
	INTERN	TRACE
	INTERN	CSTMT.
	IFN	DEBUGF,<
	INTERN	DBUG$
	EXTERN	DEBUG$
	EXTERN	ST$AREA
	INTERN	PNTRY.
	INTERN	KI10N.
	INTERN	KA10N.
	INTERN	PRTRN.
	INTERN	KI10X.
	INTERN	KA10X.
	INTERN	C$TMT	;POINTER TO LAST "STMT_BLOCK"
	INTERN	BA$I$	;POINTER TO CURRENT STACK FRAME
	INTERN	REA$ON	;MAJOR PARAMETER FOR DEBUG
	INTERN	STEP$	;COUNTER FOR STATEMENT STEPPING
	INTERN	P$KIP	;IF TRUE, DON'T STEP OVER PROCEDURE CALLS
	INTERN	BR$KIP	;COUNT OF BREAKPOINTS TO SKIP
	INTERN	BREAK$	;CURRENT BREAKPOINT (0 THRU 9)
	INTERN	BRK$TABLE	;ARRAY[0..MAXBREAKPOINT-1] OF ^STMT_BLOCK
	INTERN	BRK$MAX	;MAX BREAKPOINT SET (-1 IF NONE)
	INTERN	REG$AVE	;SAVED REGISTERS 0-15
;
; DEBUG PSEUDO-PARAMETERS PASSED IN "REA$ON"
;
NOREASON==0		;SHOULD NOT HAPPEN
INIT==1		;FIRST CALL TO DEBUG
TRAP==2		;ILL MEM REF, ETC.
RUNTIMERROR==3	;E. G., UNITITIALIZED POINTER
STEP==4		;STATEMENT STEPPING
BREAKPOINT==5	;USER SET BREAKPOINT REACHED
BREAK==6		;CONTROL-C
MAXBREAKPOINT==^D9
;
; SIZE OF DEBUGGER SYMBOL TABLE AREA
;
BLOCKSIZE==^D128		;WORDS PER DISK BLOCK
STBLOCKS==^D16			;BLOCKS TO BE RESERVED
STSIZE==STBLOCKS*BLOCKSIZE	;TOTAL SIZE
>
	EXTERN	TWAIT.
	EXTERN	.JBSA,.JBREL,.JBREN,.JBOPC,.JBTPC
	$RELOC			;THIS IS A TWO SEGMENT MODULE

	SUBTTL	ENVIRONMENT INITIALIZATION AND TERMINATION
;
; ENVIRONMENT INITIALIZATION
;
; CALLED BY PASCAL PROGRAM MAIN PROCEDURE.
;
; AT ENTRY,
;	(BASIS) = DESIRED STACK SIZE
;	(REG5) = RETURN ADDR
;
; AT EXIT,
;	(BASIS) = <0,,STACK ADDRESS>
;	(TOPP)  = <-STACK SIZE,,STACK ADDR>
;	FURTHER, ALL ENVIRONMENT INITIALIZATION IS COMPLETE.
;
; ALL REGISTER ARE ASSUMED TO BE FREE.
;
NIL==377777
	IFN	HASH-5,<
	INTERN	VINI5.>
	IFN	HASH-4,<
	INTERN	VINI4.>
	IFN	HASH-3,<
	INTERN	VINI3.>
	IFN	HASH-2,<
	INTERN	VINI2.>
	IFN	HASH-1,<
	INTERN	VINI1.>
	IFN	HASH,<
	INTERN	VINI0.
	INTERN	INITP.>
	ifn	debugf,<
	intern	vtran$
	ife	virtual+incore,<
	intern	dtran$>
	ifn	incore,<
	extern	vtr2.>
	intern	v$offset
	intern	v$poffset
	intern	v$rtual
	intern	v$ncore
	intern	v$nil
	ifn	virtual+incore,<
	extern	amask.
	extern	omask.
	extern	vtrns.
	extern	vnilo.
;
; V$POFFSET called from debugger to dereference a pointer
; and load a packed offset. On entry:
;	(REG) = translated pointer
;	(REG1)= bitoffset of offset (0=lefthw,18=righthw)
;
v$poffset:
	jumpe	reg1,left
	hrrz	reg1,0(reg)	;get offset
	jrst	loaded
left:	hlrz	reg1,0(reg)
loaded:	cain	reg1,777777	;check for nil offset
	jrst	setnil
setarea:
	tdz	reg,omask.	;clear all but areaid
	add	reg,reg1	;propagate areaid
v$done:
	movem	reg,fv(topp)
	popj	topp,

;
; V$OFFSET called from debugger to load an (unpacked) offset 
; through a translated pointer. On entry:
;	(REG) = pointer
;
v$offset:
	move	reg1,0(reg)	;get offset
	came	reg1,vnilo.	;check for nil
	jrst	setarea
setnil:	move	reg,v$nil
	jrst	v$done
;
; VTRAN$ is called to translate a possibly virtual address.
; on entry:
;	(REG) = address to be translated
;
vtran$:
	tdnn	reg,amask.	;check if virtual
	jrst	v$done		;no translation if not
	pushj	topp,vtrns.	;else translate
	cai	reg,0		;may not skip in incore case
	jrst	v$done

v$rtual:exp	1	;boolean true
v$ncore:exp	incore	;boolean value

v$nil:	exp	-1	;nil virtual pointer
>
	ife	virtual+incore,<
;stub virtual pointer supports for debugger
vtran$:				;should not be called
dtran$:			;dummy
v$poffset:			;unused
v$offset:			;unused
	popj	topp,

v$ncore:
v$nil:				;unused
v$rtual:exp	0		;boolean false
>>
VINI5.:
VINI4.:
VINI3.:
VINI2.:
VINI1.:
VINI0.:
DEBUG.:
INITP.:
	IFG	HASH-1,<
	EXTERN	FIRST.,LAST.
	MOVEI	REG,LAST.	;GET NUMBER OF "INITn." SYMBOLS REF'D
	SUBI	REG,FIRST.
	CAILE	REG1,2		;NO MORE THAN TWO ALLOWED
	JRST	VERROR
	CAIE	REG1,2		;OK IF ONLY ONE
	JRST	VOK
	MOVE	REG,FIRST.
	XOR	REG,FIRST.+1
	CAIN	REG1,1		;OK ONLY IF 1
	JRST	VOK
VERROR:	OUTSTR	[ASCIZ /
?	Illegal mixture of allocation strategies.
/]
	EXIT	0,		;CAN'T CONTINUE
VOK:>
; OBTAIN NEEDED CORE
	HLRZ	AC1,.JBSA	;PICK-UP HOW MUCH CORE WE HAVE
	IFN	DEBUGF,<
	ADDI	BASIS,^D1000>	;DEBUGGER NEEDS SPACE, TOO
	MOVEI	0,STACK.##	;CHECK IF STACK DEFINED TO LINKER
	CAMLE	0,BASIS
	MOVEI	BASIS,STACK.	;USE IT IF LARGER
	ADD	AC1,BASIS	;ADD IN STACK REQUIREMENTS
	CAMGE	AC1,.JBREL	;DID USER SPECIFY EVEN MORE?
	MOVE	AC1,.JBREL	;YES, USE HIS LARGER SPEC.
	IFN	DEBUGF,<
	ADDI	AC1,STSIZE	;ALLOCATE SPACE FOR DEBUG SYMBOL TABLES
>
	CORE	AC1,		;ASK MONITOR FOR LOW CORE
	JRST	INI.90		;IT REFUSED!
; RESERVE ROOM FOR STACK, AND CONSTRUCT STACK POINTER
	HLRZ	AC1,.JBSA	;FIND FIRST FREE IN LOW CORE
	ADD	AC1,BASIS	;INCR BY STACK REQUIREMENTS
	IFN	DEBUGF,<
	ADDI	AC1,STSIZE
>
	HRLM	AC1,.JBSA	;SAVE NEW FIRST-FREE POINTER
	SUB	AC1,BASIS	;DECR BY STACK SIZE
	MOVN	TOPP,BASIS	;CONSTRUCT STACK POINTER
	ADDI	TOPP,40		;RESERVE 40 LOCS FOR RUNTIME
	HRLI	TOPP,(TOPP)
	HRRI	TOPP,(AC1)
	HRRZI	BASIS,(AC1)	;MAIN HAS ZERO LEFT HALF OF BASIS
; CLEAN-UP JOB'S STATE
	RESET			; (ALSO SETS (.JBFF) = LH(.JBSA))
; SAVE ADDRESS OF MAIN'S CALL ON STACK FOR LINK TO DEBUG INFO
;
	HRRZM	REG5,0(BASIS)
;
; SET UP FOR REENTRY
;
	MOVEI	AC1,CONT.
	HRRM	AC1,.JBREN
	IFN	DEBUGF,<
;	.JBDDT SET AT LOAD TIME TO CAUSE .JBSYM TO ALSO BE SET BY LOADER
;	MOVEI	AC1,JBDDT
;	SETDDT	AC1,		;HAVE MONITOR SET .JBDDT
	MOVEI	REG,-STSIZE(BASIS)	;BASE ADDRESS OF DEBUG SYMBOL TABLE AREA
	MOVEI	REG1,STBLOCKS	;NUMBER OF DISKBLOCKS IN SAME
	PUSHJ	TOPP,ST$AREA	;INFORMS DEBUGGER
	MOVE	REG5,0(BASIS)	;RESTORE RETURN ADDRESS
	MOVEI	AC1,INIT
	MOVEM	AC1,REA$ON
	PUSHJ	TOPP,DBUG$	;DEBUGGER GETS FIRST SHOT
>
	IFN	INCORE,<
	EXTERN	CINIT.
	PUSHJ	TOPP,CINIT.>
	IFN	VIRTUAL,<
	EXTERN	VINIT.
	PUSHJ	TOPP,VINIT.>
; RETURN TO MAIN LINE CODE
	JRST	1(REG5)
;
; HERE, MONITOR REFUSES TO HONOR OUR CORE REQUEST
;
INI.90:
	OUTSTR	[ASCIZ /
?Insufficient core for program; decrease S parameter.
/]
				;FALL INTO EXIT
;
; TERMINATION HANDLER
;
EXIT.:
END.:
	IFN	VIRTUAL+INCORE,<
	EXTERN	VEND.
	PUSHJ	TOPP,VEND.>
	EXIT	0,		;EXIT AND PERFORM RESET
;
; "REENTRY" POINT
;
CONT.:	MOVEM	AC0,1(TOPP)	;FREE A REGISTER
	MOVE	AC0,.JBOPC	;GET RETURN ADDRESS FOR CONTINUE
	MOVEM	AC0,RETADR	;AND SAVE IT
	JRST	DIE1
;
; AFTER A RUNTIME ERROR
;
DIE.:	MOVEM	AC0,1(TOPP)
	IFN	DEBUGF,<
	MOVEI	AC0,RUNTIMERROR
	MOVEM	AC0,REA$ON
>
	SETZM	RETADR		;CON'T CONTINUE AFTER A RUNTIME ERROR
DIE1:
	ADDI	TOPP,6
	HRLI	AC0,1
	HRRI	AC0,-4(TOPP)
	BLT	AC0,0(TOPP)	;SAVE REGISTERS AC1-REG3
	SKIPN	REG,CSTMT.	;FILE/PAGE/LINE # INFO KNOWN?
	JRST	DIE2		;NO
PCHECK:	HLRZ	REG1,0(REG)	;BACKLINK TO STMT OR PAGE BLOCK
	HRRZ	REG2,0(REG)	;GET LINE NUMBER OR LINK TO LAST STMT
	CAIL	REG2,0(REG)	;FOUND PAGE?
	JRST	PFOUND		;YES
	MOVE	REG,REG1	;NO, BACK UP ONE STMT
	JRST	PCHECK
PFOUND:	PUSH	TOPP,REG	;SAVE PAGE BLOCK ADDRESS
FCHECK:	HLRZ	REG1,0(REG)	;BACKLINK TO PREVIOUS PAGE OR FILE BLOCK
	HRRZ	REG2,0(REG1)	;GET LINK TO LAST STMT OR LAST PAGE
	CAIL	REG2,0(REG)	;FOUND THE FILE?
	JRST	FFOUND		;YES
	MOVE	REG,REG1	;NO, BACK UP 
	JRST	FCHECK
FFOUND:	MOVEI	REG1,2(REG1)	;ADDRESS OF FILE NAME
	OUTSTR	[ASCIZ /
 File /]
	PUSHJ	TOPP,WRTSTR	;PRINT IT
	POP	TOPP,REG1	;RETRIEVE ADDRESS OF PAGE BLOCK
	OUTSTR	[ASCIZ / page /]
	MOVE	REG,2(REG1)	;DETERMINE IF PAGE NAME NON-BLANK
	CAMN	REG,[ASCII/     /]
	JRST	PNMPRI		;IF BLANK, THEN PRINT PAGE NUMBER
	MOVEI	REG1,2(REG1)	;ELSE, PRINT PAGE NAME
	PUSHJ	TOPP,WRTSTR
	JRST	LNMPRI		;AND THEN PRINT LINE NUMBER
PNMPRI:	HRRZ	REG1,1(REG1)	;FETCH PAGE NUMBER, AND PRINT IT
	PUSHJ	TOPP,WRTDC.
LNMPRI:	HRRZ	REG1,@CSTMT.	;GET LINE NUMBER
	OUTSTR	[ASCIZ / line /]
	PUSHJ	TOPP,WRTDC.	;WRITE IT
	OUTSTR	[ASCIZ /
/]
DIE2:	EXIT	1,		;CONTinue for trace
	PUSHJ	TOPP,TRACE	;DUMP STACK STRACE
	HRLI	AC0,-4(TOPP)
	HRRI	AC0,1
	BLT	AC0,REG3	;RESTORE SAVED REGISTERS AC1-REG3
	SUBI	TOPP,6
	MOVE	AC0,1(TOPP)	;RESTORE LAST REGISTER
	EXIT	1,
;
; If user CONTinued again check RETADR to see if can return to his program
;
	SKIPN	.JBTPC
	SKIPN	RETADR
	EXIT	0,		;FORGET IT
	JRSTF	@RETADR		;RETURN TO HIS PROGRAM
	IFN	DEBUGF,<
;
; COME HERE IF DDT TYPED TO MONITOR PROMPT
;
JBDDT:	SKIPE	0,INDDT		;IF DEBUGGER WAS NOT RUNNING...ENTER IT
	JRSTF	@.JBOPC		;ELSE...CONTINUE WITH IT
	PUSH	TOPP,AC1
	MOVE	AC1,.JBOPC
	MOVEM	AC1,RETADR	;MIGHT WANT CONTINUATION
	MOVEI	AC1,NOREASON
	CAME	AC1,REA$ON	;DEBUG PARAMETER ALREADY KNOWN?
	JRST	JBDDT1		;YES, KEEP IT
	MOVEI	AC1,BREAK
	SKIPE	.JBTPC		;CAN THIS BE CONTINUED?
	MOVEI	AC1,TRAP	;NO
	MOVEM	AC1,REA$ON
JBDDT1:	POP	TOPP,AC1
	PUSHJ	TOPP,DBUG$	;SAVE REGISTERS AND CALL DEBUGGER
	SKIPN	.JBTPC		;SKIP IF CONTINUE NOT POSSIBLE
	SKIPN	RETADR		;CONTINUE IF WE KNOW WHERE TO RESUME
	EXIT	0,
	SETZM	.JBOPC
	JRSTF	@RETADR
;
; SAVE REGISTERS 0-15 PLUS BASIS BEFORE CALLING DEBUG$
;
DBUG$:	SETOM	0,INDDT		;FLAG DEBUGGER RUNNING
	MOVEM	AC0,REG$AVE
	HRLZI	AC0,1
	HRRI	AC0,REG$AVE+1
	BLT	AC0,BA$I$
	PUSHJ	TOPP,TWAIT.	;FORCE OUT ANY PENDING TTY OUTPUT
	PUSHJ	TOPP,DEBUG$
	HRLZI	AC0,REG$AVE+1	;RESTORE 0-15 AFTER RETURN
	HRRI	AC0,1
	BLT	AC0,BASIS-1
	MOVE	AC0,REG$AVE
	SETZM	0,INDDT		;FLAG DEBUGGER NO LONGER RUNNING
	POPJ	TOPP,
>
WRTPC.:	OUTSTR	 [ASCIZ/ at user PC /]
WRADR.:	HRRZI	 REG2, 6
	MOVE	 REG3,[POINT 3,AC0,17]
	ILDB	 AC1, REG3
	ADDI	 AC1, "0"
	OUTCHR	 AC1
	SOJG	 REG2,.-3
	POPJ	TOPP,
;
; WRTDC. outputs a decimal number to TTY
;
; On entry, (REG1) = #
; On return, REG1 and REG2 are destroyed
;
WRTDC.:	IDIVI	REG1,^D10		;DIVIDE BY 10
	PUSH	TOPP,REG2	;SAVE REMAINDER MODULO 10
	CAIE	REG1,0		;DONE IF QUOTIENT = 0
	PUSHJ	TOPP,WRTDC.	;ELSE RECURSE
	POP	TOPP,REG2	;RETRIEVE REMAINDER
	ADDI	REG2,"0"	;CONVERT TO ASCII
	OUTCHR	REG2		;AND PRINT IT
	POPJ	TOPP,
;
; WRTSTR outputs a 10 character ASCII string to TTY
;
; On entry, (REG1) = address of the 2-word string
;
; On return, REG1, REG2, and REG3 are destroyed
;
WRTSTR:	HRLI	REG1,440700	;MAKE IT A BYTE POINTER
	MOVEI	REG2,12		;CHARACTER COUNT
	ILDB	REG3,REG1
	OUTCHR	REG3
	SOJG	REG2,.-2
	POPJ	TOPP,
;
; TRACE outputs to TTY a trace of procedure/function calls 
; by chasing the dynamic BASIS chain up the stack to the main program.
;
TRACE:	PUSHJ	TOPP,TWAIT.	;EMPTY TTY BUFFER FIRST
	OUTSTR	[ASCIZ /
 Trace of active procedures:
 Name	    Location   Address of call
 ----	    --------   ---------------
/]
	MOVE	REG,BASIS	;STACK PTR.
TRACE2:	TLNN	REG,777777	;AT MAIN?
	JRST	INFO.		;YES, RETURN THROUGH INFO.
	HLR	REG,REG		;NO, SET STACK POINTER TO CALLER'S FRAME
	PUSHJ	TOPP,INFO.	;AND PRINT IT'S INFO
	MOVE	REG,1(REG)	;BACK ONE FRAME
	JRST	TRACE2
;
; INFO. prints the name (if any), address, and caller's address of the
; procedure whose BASIS stack pointer is in REG.
;
INFO.:	TLNE	REG,777777	;CHECK FOR MAIN
	JRST	INFO1		;NO
	HRRZ	REG1,0(REG)	;LINK WORD STORED DIFFERENTLY FOR MAIN PROC
	SKIPA
INFO1:	HRRZ	REG1,3(REG)	;ADDRESS OF ENTRY POINT + 1
	PUSH	TOPP,REG1	;SAVE IT
	HRRZ	REG1,0(REG1)	;ADDRESS OF PROCEDURE NAME OR NIL
	JUMPE	REG1,.+3	;IF NOT IN TRACE MODE
	CAIE	REG1,NIL	;COMPILED WITH TRACE IN EFFECT?
	JRST	.+3
	OUTSTR	[ASCIZ /Unknown   /];NO
	JRST	.+2
	PUSHJ	TOPP,WRTSTR	;WRITE IT
	OUTSTR	[ASCIZ /   /]	;PAD
	POP	TOPP,REG1
	HRRZ	AC0,0(REG1)	;LINK WORD TO TRACE BLOCK
	CAIN	AC0,NIL		;IF TRACE BLOCK EXISTS USE ITS ADDRESS
	MOVEI	AC0,-1(REG1)	;ELSE GET ADDRESS OF ENTRY POINT
	PUSHJ	TOPP,WRADR.	;PRINT IT
	OUTSTR	[ASCIZ /      /]	;PAD
	MOVE	REG1,0(REG)	;ADDRESS OF CALL + 1
	MOVEI	AC0,-1(REG1)	;CORRECTED
	TLNE	REG,777777	;NO CALLER IF MAIN
	PUSHJ	TOPP,WRADR.	;GO PRINT CALL ADDRESS
	OUTSTR	[ASCIZ /
/]
	POPJ	TOPP,
	IFN	DEBUGF,<
PNTRY.:
KI10N.:
;
; PROCEDURE ENTRY SEQUENCE FOR KA, KI, AND KL
;
KA10N.:
	SKIPL	STEP$		;IF STEPPING
	SKIPG	P$KIP		;AND IF SKIPPING CALLS
	JRST	ENTRY1
	PUSH	TOPP,AC1	;THEN DUMMY UP RETURN ADDRESS
	MOVEI	AC1,BACK$TEP
	PUSH	TOPP,AC1
	MOVE	AC1,STEP$
	EXCH	AC1,-1(TOPP)	;SAVE OLD STEP COUNT
	SETOM	STEP$		;NO LONGER STEPPING
ENTRY1:
	MOVEM	BASIS,1(TOPP)
	MOVEM	TOPP,2(TOPP)
	MOVEI	BASIS,(TOPP)
	HRLI	BASIS,(BASIS)
	HRRZM	AC1,3(BASIS)
	JRST	1(AC1)
BACK$TEP: POP	TOPP,AC1	;RETRIEVE OLD STEP COUNT
	MOVE	AC0,FV+2(TOPP)	;MUST SHIFT FUNCTION VALUE UP 2 WORDS
	MOVEM	AC0,FV(TOPP)
	MOVE	AC0,FV+3(TOPP)
	MOVEM	AC0,FV+1(TOPP)
	SKIPGE	STEP$		;IF NOT CURRENTLY STEPPING
	SKIPG	P$KIP		;AND IF STILL SKIPPING CALLS
	POPJ	TOPP,
	MOVEM	AC1,STEP$	;THEN RESTORE STEP COUNT
	POPJ	TOPP,
;
; PROCEDURE EXIT SEQUENCE FOR KA, KI, AND KL
;
PRTRN.:
KI10X.:
KA10X.:	MOVE	TOPP,2(BASIS)
	MOVE	BASIS,1(BASIS)
	TLNE	BASIS,777777
	HLR	BASIS,BASIS
	POPJ	TOPP,
>
	$LOW
RETADR:	EXP	0		;"CONTINUE" ADDRESS AFTER ^C
BFPAD.::EXP	0		;POINTER TO FILE BUFFERS ALLOCATED IN STACK
C$TMT:	BLOCK	0
CSTMT.:	EXP	0		;POINTER TO LAST "STMT_BLOCK"
	IFN	DEBUGF,<
INDDT:	EXP	0		;SET NON-ZERO WHILE DEBUGGER RUNNING
REA$ON:	EXP	0		;DRIVING PARAMETER FOR DEBUG
STEP$:	EXP	-1		;COUNT OF STATEMENTS YET TO BE STEPPED BEFORE CALLING DEBUG
P$KIP:	EXP	0		;IF TRUE (1) THEN DON'T STEP OVER PROCEDURE CALLS
BR$KIP:	EXP	-1		;COUNT OF BREAKPOINTS TO SKIP
BREAK$:	EXP	0		;BREAKPOINT REACHED
BRK$MAX:EXP	-1	;MAX BREAKPOINT SET
BRK$TABLE:	BLOCK	MAXBREAKPOINT+1	;BREAKPOINT TABLE
REG$AVE:	BLOCK	BASIS		;STORAGE FOR REGISTER 0-15B
BA$I$:	BLOCK	1			;POINTER TO LOCAL STACK FRAME
	.JBDDT==74		;SET DDT LOCATION SO SYMBOL TABLE LOADED
	LOC	.JBDDT
	EXP	JBDDT
>
;	SET RELOCATION BACK TO HIGH SEGMENT SO LITERALS GO THERE
	$HIGH
	PRGEND
	title	stack.
	entry	stack.
	search	passym
	$reloc
stack.==0
	end
    